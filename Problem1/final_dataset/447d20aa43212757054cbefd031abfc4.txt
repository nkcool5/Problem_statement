td`.
/lib/ld-linux.so.2
Dng['
H$@P
X{yhfUa
h~}&
libstdc++.so.6
__gmon_start__
_Jv_RegisterClasses
_Znwj
_Znaj
_ZdlPv
__gxx_personality_v0
_ZdaPv
libm.so.6
libgcc_s.so.1
_Unwind_Resume
__divdi3
libc.so.6
_IO_stdin_used
socket
fflush
strcpy
htonl
htons
readdir
_IO_putc
srand
fopen
strncmp
inet_aton
strrchr
isalpha
perror
statvfs64
connect
getpwuid
closedir
inet_ntoa
nanosleep
ftell
inet_ntop
strncpy
signal
fsetpos64
__stack_chk_fail
unlink
putchar
listen
select
mkdir
realloc
stdin
vsprintf
memchr
tolower
getpid
strdup
strftime
chmod
isspace
gmtime
strtol
isatty
symlink
isprint
fgetc
fgets
strlen
ungetc
isxdigit
__cxa_atexit
send
memset
isalnum
getchar
strstr
__errno_location
rmdir
bind
fseek
chdir
memcmp
toupper
clearerr
shutdown
vsnprintf
stdout
fputc
recv
inet_addr
fputs
memcpy
fclose
strtoul
pthread_setschedparam
vprintf
setsockopt
malloc
strcat
umask
remove
tzset
opendir
getenv
__ctype_b_loc
sscanf
recvfrom
stderr
system
gethostbyname
getuid
fgetpos64
getifaddrs
strncat
strtoull
fileno
chown
getcwd
fwrite
fread
gettimeofday
rename
atoi
atol
localtime
strchr
getsockname
utime
sendto
mktime
fdopen
readdir64
qsort
accept
fcntl
atoll
memmove
pthread_self
fopen64
access
strcmp
strerror
__libc_start_main
ferror
vfprintf
ntohs
free
ispunct
__timezone
__xstat
__lxstat
__xstat64
UzpMessagePrnt
ReportMsg
_Z7myMsgFnPvPhmi
glblDummyFile
central_hdr_sig
SeekMsg
_Z9myInputFnPvPhPii
UzpInput
end_central_sig
local_hdr_sig
CompiledWith
_Z10myPasswdFnPvPiPciPKcS3_
CentSigMsg
UzpPassword
mask_bits
_Z9myPauseFnPvPKci
nGlblZipCoreMemLimit
ExclFilenameNotMatched
TruncEAs
ydays
Zipnfo
oem2iso
TruncNTSD
prog
EndSigMsg
fnames
TGZsuffix
aunzmod
_Z10myStatCBFnPviPKcS1_PKv
CXXABI_1.3
GLIBCXX_3.4
GCC_3.0
GLIBC_2.0
GLIBC_2.4
GLIBC_2.3
GLIBC_2.2
GLIBC_2.1.3
GLIBC_2.1
PTRh
0[^]
0[^]
gfff
$`x"
$`x"
$@l!
$@l!
$@l!
<}u;
|[^_]
[^_]
< t(
< tE
<	t>
<"u]
<"u3
<\u1
<<u$
<\u>
< t&
<$uJ
,[^_]
D$ `
@h=2P
@h=2P
@l=2P
@l=2P
Ph+U
@[^]
@[^]
,[^_]
0[^]
[^_]
 [^]
@[^]
$< u
VUUU
<]u&
<#uW
@4;E
[^_]
<st.
<st+
<it$
<it!
<st.
QZ^&
-V8I
-o,y
[^_]
[^_]
<.uK
</t;
<.uF
</t6
<.uH
</t8
`[^]
[^_]
<;uP
VUUU
<-u"
<"u<
< t.
<	t!
<"ub
<"u<
< t.
<	t!
<"ub
<+uw
<-uP
<-uE
<-uT
[^_]
[^_]
L[^_]
[^_]
<[^_]
[^_]
<du;
<hu;
<mu5
<su3
P[^]
D$ `
[^_]
`[^]
[^_]
\[^_]
<.t?
</uf
P[^]
p[^]
[^_]
<[^_]
[^_]
[^_]
[^_]
[^_]
<\u	
|'9U
D$ `
<\u	
<\u	
[^_]
@[^]
gfff
[uPf
<.uH
<*u&
<)u)
<)u)
<\tS
<\tb
<	u.
<	t0
<,t(
<,t(
<,t(
<	u 
<	u&
p[^]
,[^_]
|P;U
|:;U
[^_]
E ;E$v2
[^_]
[^_]
[^_]
gfff
gfff
< u1
[^_]
|.9U
|.9U
p[^]
</t<
</t/
[^_]
$`j"
$`f"
[^_]
<-t"
[^_]
[^_]
[^_]
<2t 
[^_]
[^_]
[^_]
[^_]
[^_]
<=uP
</u%
</u'
</t 
t =(
</u7
</u-
<-u"
</uZ
<-u"
<-u"
</uZ
[^_]
< t-
<\t#
p[^]
< u7
L[^_]
<*u^
$ D!
$0h!
$0h!
$0h!
$0h!
$@E!
$@E!
$@E!
$@E!
$@E!
`[^]
l[^_]
l[^_]
$@E!
[^_]
0[^]
<:uW
D$h;E
D$`;E
D$\3
D$\D%
;D$T~	
<+u;
<.uY
</u2
<.uZ
<.u'
<:u7
</u'
$`h!
$0h!
<it(
gfff
gfff
<-uU
D$ `
<:uB
<:uG
<fu'
<:ti
<,u"
<su>
<#u%
< u*
<+u8
</t.
<>t!
<%te
< uM
<	u4
[^_]
@[^]
[^_]
[^_]
@[^]
[^_]
@[^]
[^_]
$@E!
$0h!
[^_]
,[^_]
[^_]
$@`#
$@`#
$@`#
$@`#
@[^]
[^_]
$@`#
$@`#
[^_]
$@`#
[^_]
0[^]
,[^_]
,[^_]
 [^]
0[^]
0[^]
0[^]
$`b#
$`b#
\[^_]
[^_]
,[^_]
\[^_]
\[^_]
0[^]
<:ud
`[^]
<:u\
<:uR
<:ud
[^_]
[^_]
[^_]
[^_]
[^_]
[^_]
 [^]
 [^]
[^_]
|[^_]
|j9U
|g9U
p[^]
[^_]
P[^]
P[^]
0[^]
< t"
< t+
<#uq
<]u	
<]t$
gfff
gfff
gfff
gfff
gfff
gfff
gfff
gfff
gfff
gfff
gfff
gfff
[^_]
[^_]
[^_]
$@`#
[^_]
L[^_]
</u(
<*u?
[^_]
<fu	
<hu	
<Ru	
@\<w
@\<wuw
@\<wt
0[^]
@\<wu
@\<ru
@\<rt
@\<ru
@\<wt
@\<wt
@\<rt
@\<rt
@\<wu]
@(;E
0[^]
@$;E
@H;E
@H)E
@H;E
@H)E
@D;E
@D+E
@0;E
@0)E
@(+E
@0+E
@@;E
l[^_]
@(;E
@(+E
0[^]
@$xP
@8;E
@4;E
@4;E
@4;E
@4;E
@$xP
@[^]
[^_]
[^_]
<[^_]
@ ;E
@ +E
@ ;E
@ +E
@ ;E
@ +E
@4;E
@4;E
[^_]
;E |
;E |
@$3E
@L3E
[^_]
|[^_]
@[^]
l[^_]
<Pub
<Pu^
<Pu^
`[^]
 [^]
 [^]
t0=UT
0[^]
 [^]
t5=nu
0[^]
</u$
,[^_]
0[^]
\[^_]
L[^_]
 [^]
@|;E
@|;E
@|;E
[^_]
<[^_]
;E$~
;E$~
<\u~
E$;E
;E$~
|[^_]
[^_]
t+=AL
ta=At
L[^_]
\[^_]
<[^_]
}$8t
@4#E
$[^_]
[^_]
<[^_]
@l;E
@l+E
@l+E
@l;E
`[^]
`[^]
<[^]
 [^]
0[^]
0[^]
P[^]
[^_]
8[^]
VUUU
VUUU
@D;E
@|;E
gfff
gfff
gfff
gfff
[^_]
</t3
 [^]
@|;E
p[^]
 [^]
;}$r
;} r
l[^_]
l[^_]
[^_]
[^_]
<[^_]
<[^_]
\[^_]
=VFABum
@[^]
0[^]
@[^]
L[^_]
<(u3
<2u8
<(u3
<2u9
<.u.
<[^_]
,[^_]
|[^_]
L[^_]
[^_]
<[^_]
[^_]
[^_]
<\u	
0[^]
[^_]
[^_]
$version:vernum=1.7.4,name=sfk,title=Swiss File Knife,info=-,os=linux-lib6,type=Base/XD,fix=5,date=Apr 15 2015$
Base
SFK_CONFIG
wildstar:
%0*lld
%0*llX
%*lld
program version: SFK 1.7.45
=== last steps: ===
=== see also: 
 ===
=== fatal error during execution ===
sfk exits due to segment violation.
Swiss File Knife 1.7.4 %s (linux-lib6)
Swiss File Knife 1.7.4 (linux-lib6)
{%04X}
%03u.%03u.%03u.%03u%s
%u.%u.%u.%u%s
127.0.0.1
-s%s
-u%s
directory tree processing stopped by error.
[nopre] [using %s]
ping: unknown host %s
ping: out of memory
ping: missing admin rights
ping: sendto error
select()
ping: receive error
ping: reply too short
ping: got an echo reply
ping: received sequence #%u
ping: received id %u
ping: received a non-echo reply
ping: elapsed time = %u msec
ping: no reply within %d msec
out of memory
incomplete hex slash pattern: %.4s   (use \%.4s instead?)
wrong hex slash pattern: %.4s   (use \%.4s instead?)
incomplete decimal slash pattern: %.4s   (use \%.4s instead?)
wrong decimal slash pattern: %.4s   (use \%.4s instead?)
undefined slash pattern: %.2s   (use \%.2s instead)
incomplete dec slash pattern: %.5s   (use \%.5s instead?)
wrong dec slash pattern: %.5s   (use \%.5s instead?)
undefined slash pattern: %.2s   (use \\%.2s instead?)
:file:
                                                                                                
\|/-
# sfk alias batch
%.20s%d
%%%d
outofmem
internal #2310271958
unexpected: file left open for write: %s
open for write on %s not registered
bright
dark
theme:black
theme:white
,nobold
,bold
head:
examp:
file:
link:
hit:
rep:
err:
warn:
pre:
def:
time:
traceinc:
traceexc:
</font>
</b>
<font color="%06X">
using color sequence: \x1b[0;0m
%c[0;0m
using color sequence: \x1b[%d;%dm
%c[%d;%dm
&gt;
&lt;
&amp;
%s%s
%.*s
green
blue
yellow
cyan
magenta
default
white
warn
head
examp
file
time
unsupported color name: %s (try "sfk help color")
printx overflow.1: %.30s ...
<help>
<file>
<head>
<prefix>
<examp>
<hit>
<rep>
<err>
<warn>
<time>
<def>
[red]
[green]
[blue]
[yellow]
[cyan]
[magenta]
[def]
[CR]
[LF]
<not>
<run>
<wild>
<sla>
<exp>
export
<nofo>
-nofo 
printx overflow.2: %.30s ...
%s<file>%.*s<def>
%s%.*s
%s   #%.*s<def>%.*s
%s$%.*s<def>
int. 187281850
int. 187281919
wrong keymap key for index %d
color string failure, %p "%.10s" "%.10s" "%.10s"
version
$%s:
http://
ftp://
http/
http\
ftp/
ftp\
int. #9529106
index.html
.html
text
.txt
html
.dat
int. #21161820
out of memory: coi.ctr.1
url has %d refs open, cannot dtr: %s
missing close on %s
ref.cnt underflow (%d): %s
0123456789ABCDEF
fileid="%s" len=%d for "%s"
missing closeDir() after dir traversal, %p
.zip
.jar
.ear
.war
.aar
.xpi
.tar.gz
.tar
.tgz
.tar.bz2
.tbz2
.bz2
SFK_ZIP_EXT
Error: too many extensions in SFK_ZIP_EXT
stat
coi.rootrelname: %s
coi.rrname.noroot: %s
unable to read: %s
out of memory: %s
cannot read: %s
cannot read: %s (%d %d)
write not supported: %s
write to utf-16 file not supported: %s
unsupported mode "%s": %s
zip dir entry, cannot open: %s
utf16%s%s: %s
:snapfile sfk,
:cluster sfk,
int. #62 %d %d
int. #63 %d %d
int. #65
int. #60
int. #61
int. #62
int. #63
cannot read ucs-2, buffer too small: %s
cannot read ucs-2, uneven buffer size: %s
zip dir entry, cannot read: %s
read on non-open file: %s
internal: seek: supports only SEEK_SET
seek failed: %s
cannot seek to position %s
cannot seek on http file
cannot seek on ftp file
cannot seek on zip entry
seek on non-open file: %s
internal: seek: failed to read position
write: conflict with cached data
cannot write on http file
cannot write on ftp file
cannot write on zip entry
write on non-open file: %s
zip dir entry, cannot close: %s
close on non-open file: %s
applying -keeptime after write close: %s
cannot set file time (rc=%d) for: %s
skipping -keeptime after non write close: %s
failed to set file times (rc=%d): %s
no filesystem directory, cannot open: %s
int. #1310281137
no directory, cannot read: %s
no directory, cannot close: %s
..%c
zz-shadow-01
nextEntry() called without openDir()
nostat: %s (non-regular file)
nofile: %s (non-regular file)
closeDir() called on non-open dir
illegal index: %d
internal #141272256
illegal set index: %d
illegal CoiTable index: %d tline %d
columns:
SFK_COLORS
ConsoleColumns=%d
... 
%02d%% 
100%% 
[progress: cur=%d max=%d perc=%d]
...%s
%-*.*s
<head>%-*.*s %s<def>
<head>%-*.*s <time>%c<def> 
bytes
[cmd]: 
cmd  : [none]
Press ENTER to continue.
Borrow or rob
error: %s
[nopre] 
warn : %s
note : %s
%d,%s
fwrite
the target volume may have no space left on the device.
if the target is a network drive, a file size limit may apply.
cerno: %d,%s
match: enter matchstr "%s" "%s" flags %u
match:  direct at %d len %d
match:  process %c index %d "%s"
match:   check part "%s" cnext "%c" with hay at "%.10s"
match:   from %.10s
match:   submatched "%s"
match:   submiss
match:   full inner match, %d %d
match:   full inner miss
match:   cont hay "%.10s" pat "%.10s"
match:   miss at haychr "%c" msk %c position %d
match:  1) ifirst %d ilast %d bmatch %d
match:  c) no line-end hit, %d != %d
match:  2) ifirst %d ilast %d bmatch %d for hay "%s" pat "%s"
<interleaved-attributes-text version="1.0" prefix="">
%02X
{%02X}
out of memory: finfo
[pipe %s contents (%d lines):]
[   "%s"]
#sfk
example overflow: %s
help.overflow.1 %s
help.overflow.2 %s
[indata]
[infiles]
redirect file already open
cannot create dir: %s
cannot write: %s
:file:
written: %s
[chain converts text data to filename list]
out of memory while collecting binary chain data (%s)
invalid chain binary data format: %s
output overflow while collecting chain binary data
data size mismatch while collecting chain binary data (%d/%d)
checksum mismatch while collecting chain binary data (%X/%X)
internal 200706102039
line buffer overflow: cannot join "%s" and following
buffered lines may have %d characters max.
[chain flushes %d binary data]
command chaining: cannot use text data AND filename list in parallel.
[chain swaps out and in, text2files=%d files2text=%d]
command chaining stopped: cannot execute text2files AND files2text
[chain autoselects ftt from %d filenames.]
[chain autoselects ttf from %d text lines.]
[chain converts filename list to text data, %d records]
chaining stops before %s: no more filenames
[chain passes %d files to %s]
records
text lines
[chain passes %d %s to %s]
[chain passes %s bytes of binary]
[white]
] %.*sstringtable %p, %d entries:
<null>
]   %.*s%s
]  stringtable %p added %s, have %d
]  stringtable %p set %s, have %d
illegal StringTable index: %d tline %d
] array %s dump:
]   row %p:
%s: illegal row %d
] array %s: add to row %d entry %s. [%d rows total]
] array %s: add NULL to row %d. [%d rows total]
] array %s: set row %d:%d entry %s. [%d rows total]
%s: no string entry type at %u %u
] array %s: add to row %d entry %d [tline %d]
no long entry type at row %u col %u
array %s extended to %d rows [tln %d]
%s: illegal row index: %d on setRow, tline %d
array %s setrow %d
error: no entry at index %d, table %p, within array %p
no string type at %s:%d:%d
%s: illegal row index: %d on hasRow
wrong index for updateEntry: %d
illegal LongTable index: %d %d tline %d
illegal index for updateEntry: %d
illegal NumTable index: %d %d tline %d
ERROR: SFKMD5 internal #1
Out of memory. Please select smaller folders to scan.
data integrity error, disable -fast option
internal 279122205
internal 279122206
out of memory: dsa.1
files
%d files of size %s
scan
int. #2116181
int. #2116182
int. #2116183
int. #2116184
out of memory: dsab.1
   %s
out of memory: dsab.2
RootDirs
DirMasks
FileMasks
=== fileset begin ===
] ROOT "%s" -> layer %d, cmd %d
] layer %d:
]  dmsk:
]   %s
]  fmsk:
]   
%s, 
=== fileset end ===
directory tree %d:
... uses %d dir masks:
... uses no dir masks.
... uses %d file masks:
... uses no file masks.
internal #60 %d
wrong -dir and -file sequence (%d)
specify -dir ... before -file
] select root %d
]  select layer %d
] add root dir: %s, referencing layer: %d [tline %d]
] impl. create first fileset layer
internal #20
%s%c
file mask "%s" may produce no results, because
option -arc is set, treating %s files as directories.
say -dir ... %c%s -file ... instead to use %s as a path mask.
-all
-all or %s supplied multiple times.
wrong sequence: positive file pattern already given, specify "%s" before this.
positive file pattern already given, "%s" is unexpected.
wrong sequence: negative file pattern already given, specify "%s" before this.
-all or * already given, "%s" has no effect.
] autocomplete %d:
]  yes, at layer %d
] adding dir .
%u files, %u dirs
:file %s
%s :
 %c %04u 
 %c 
   %04u 
SFK_HOME
HOME
%s/.sfkhome
no SFK Home Dir exists to store or read data.
%s%c%s
TEMP
/tmp
cannot create temporary file: no TEMP or TMP environment variable found.
zz-tmp-sfk-
cannot create temporary file.
%03u%s
using temporary file: %s
-dir
-file
-from=
-fileset
-view
ignoring memlimit, illegal value: %d
-stest
-debug
-coi
-noop
-quiet
-quiet=2
-nohead
-nocheck
-noinf
-nofile
-noname
-noind
-sim
-norec
-nosub
-withsub
-verbose
-verbose=0
-verbose=2
-verbose=3
-verbose=4
-showip
-justrc
-hid
-nohid
-yes
-umlauts
-noumlauts
-noacc
-utf
-noutf
-wchar
-nowchar
-nocol
-col
-case
-nocase
-withdirs
-wdir
-justdirs
-names
-rel
-absname
-quot
-nocconv
-cconv
-incref
-force
-lit
-spats
-spat
-nospat
-xpat
-xmaxlen=
invalid -xmaxlen
-bright
-dark
-nochain
-showrc
-exectime
-nowarn
-noerr
-nonote
-nofo
-rawflags
-ltarg
-stoponerr
-echoonerr
-rcfromerr
-waitonerr
-wait
-exterr
-detail
-showskip
-allowdup
-fast
-nover
-verify
-noprog
-notext
-test
-oldmd5
-withbin
-textandbin
-text
-textfile
-nobin
-bin
-binfile
-binaryfile
-keepdate
-keeptime
-snap
-snapw
-upat
-qarc
-zip
-arc
-nozip
-noarc
-extdom
-cacheall
-cachestat
-nocache
-noipex
-crashtest
-pure
-allbin
-include-all-binaries
-wrap
-rewrap
-wrap=
-rewrap=
-wrapbin
-wrapbin=
-memcheck
-memlimit=
-keepstale=
-html
file:1,head:4,examp:8
-htmlpage
<font face="courier" size="2"><pre>
-sincedir
-sinceadd
-sincedif
-sincech
missing parameter after %s
need directory name, no option allowed after %s
no such directory: %s
-ignoretime
-ignore3600
-noignore3600
-tracesel
-tracedir
-tracefile
-usectime
-utc
-gmt
-proxy
-minsize=
-maxsize=
-since
-before lower or equal than -since was specified.
-before
-since greater or equal than -before was specified.
-tofile
-tmpdir
-keeptmp
-showtmp
-today
today
-flist
cannot read filename list file: %s
] add2flist.1: %s
-prio=
-dirdelay=
-filedelay=
-slow=3
-slow=2
-slow
-broad
-firsthit
-xchars
-perf
-crlf
-toiso=
-toiso
-iso
-toutf
-toutfsafe
-useragent=
-rawhelp
processFlatDirParms
token: <<%s>>
2filt
1ffilt
1filefilt
1list
0sel
1md5gento
1snapto
1scantab
2detab
1entab
1lf-to-crlf
1crlf-to-lf
1addcr
1remcr
1find
1grep
1ftext
1run
1inst
1deblank
0noop
1rep
1xhex
1hexfind
2view
1del
1rmtree
0sleep
0label
3tail
3head
2ttail
2thead
2toclip
2tolog
2tonetlog
0beep
0loop
2hextobin
0echo
1hexdump
1dup
1copy
2script
1fscript
0end
1ftee
2tee
2toterm
2tofile
2append
2appendto
0sfk
0then
1stat
0fromclip
0pause
2dec
2hex
2sort
2count
1ftp
1sft
0mkdir
0getcwd
0cwd
0ver
1md5
2wget
2strlen
2linelen
2webreq
Beeb
1call
2require
2difflines
1media
1filetime
1touch
2xml
2storetext
0gettext
6xed
6xex
2csvtotab
2csvtab
2tabtocsv
2tabcsv
detab
list
fromclip
+ftt
+filenamestotext
+files
+ttf
+texttofilenames
+text
+then
missing +command after %s
[chain from %s to %s. collect f=%d t=%d, idir %d %p]
[found chain type %d at %s]
[but using default type mapping %d]
find
grep
unknown chain command: %s
missing filename after %s
process long format
-enddir
-enddir is not allowed as last option
] "%s" [
] -dir: begin layer
] -dir: begin layer.3
] -dir: begin layer.2
] -dir: no begin layer
-sub
-subdir
-sub[dir] is allowed only after -dir
-any
-copy
freezeto=
no -file masks supported with freezeto command.
you specified a dir name in short syntax. -file is not allowed then.
-pat
-addbin
-include-binary-files
wrong context for -all. use within -file.
unknown dir or file parameter: %s
try to specify %s before -dir ... -file
add2flist.2: %s
mixing of short and long syntax not allowed. you may try -dir %s -file ...
mixing of short and long syntax not allowed. you may try -dir %s ...
unexpected option in short filename list: %s
try specifying %s directly after %s
%c*%s
auto-converting %s to path mask %s
wrong context or unknown option: %s
add2flist.3: %s
please supply a list of file extensions after -addbin or -include-binary-files.
please supply some pattern words after option -pat.
please supply some file extensions after option -file.
please supply some directory names after option -dir.
-sincedir/add/diff requires two directories.
directory not found: %s
internal: myfseek: supports only SEEK_SET
internal: myfseek: failed to read position
int. #66 missing file handle
int. #64
] pre size %d index %d free %d nread %d
] siw: %s
] sid: %s
int. #50
[no ref]
[no root]
] wfl: %s   %s   %s   dir=%d
no filenames to process. command chaining stopped.
] wat: tree %s
] wat: edir %s
internal #1090: statbuf too small
unable to get free space of %s
%Y%m%d %H%M%S
%Y%m%d%H%M%S
%Y-%m-%d %H:%M:%S
tomonth
toyear
cannot calc time: %s
wrong date/time format.0: %s
%4u %2u:%2u:%2u
%4u-%2u-%2u %2u:%2u:%2u
wrong date/time format.1: %s
%4u%2u%2u%2u%2u%2u
wrong date/time format.2: %s
wrong date/time format.3: %s
%2u %2u:%2u
%2u  %4u
wrong date/time format.4: %s
wrong date/time format.5: %s
%2u %4u
wrong date/time format.6: %s
%4u-%2u-%2u
wrong date format.7: %s
%4u%2u%2u
wrong date format.8: %s
wrong date and/or time format.9: "%s"
unexpected year: %u
unexpected month: %u in "%s" %d
unexpected day: %u
unexpected hour: %u
unexpected minute: %u
unexpected second: %u
invalid date/time: %s (%d %d %d)
unexpected %s value: %s
supply a value like 1000 500k 100m 5M [k=kbyte,m=mbyte]
---- 
internal 612112005
diff: mtime %s sec 
(= %s hours)
      ctime %s sec 
mtime 
, atime 
, ctime 
%s%s%s
mtime
atime
ctime
%Y%m%d
%H%M%S
%Y-%m-%d
%H:%M:%S
%s%s%s%s
 utc
%s%s%s
 sec
missing stat filename, cannot write filetime (%d)
missing stat data, cannot write filetime (%d)
none
newer, wft
time, wft
newer, uft
time, uft
size
isreadable
iswriteable
attributes
unknown
wft diff %d [3]
newer, uft by %s sec
wft diff %d [4]
time, uft by %s sec
filestat: "%s" => "%s"
NTFS
%s time adapted, %02d.%02d., %d
%s time not adapted, %02d.%02d., %d
missing stat filename, cannot write file time (%d)
no attributes to set for %s
failed to set file attributes (rc=%d): %s
SFKSIG10
outofmem.1
%s-%02d.dat
unexpected record data at end of %s
error while reading %s: wrong content format (%d)
signature db not found: %s
signature db modified: %s - retrying on copy
invalid signature db: %s - retrying on copy
all signature databases unreadable or modified.
internal #11571940
error while reading %s: wrong content format
no such file: %s - cannot read checksum
no such file: %s - cannot read shadow file
unexpected filedb entry at record %d
internal #0605071204
%u files ok, %d failed, %u mb %u kbs
%u files %u mb %u kbs
verfy
file not found: %s
DEL: %s - was modified, please resync
cannot delete: %s
content modified  : %s
cannot read shadow: %s
content modified: %s
shadow file ok  : %s
shadow modified : %s
time difference (%s sec), content ok: %s
cannot remove filename from metadb: %s
cannot read file infos: %s
time: %s
cont: %s
wrong signature db version: "%s"
metadb: header block too large (%u), cannot load.
metadb: header block too small (%u), cannot load.
internal #11571945
cannot write file meta db: %s
error while writing file meta db: %s
internal: no lastrec saved %d %d
failed to write any metadb copy.
%d metadb copies written, %d failed.
verify stopped by user.
file %d/%d
[nopre] verify skipped.
unable to read for verify: %s   
verify failed, file differs: %s   
<warn>##<def>
<prefix>]<def>
<warn>]<def>
<prefix>><def>
 <warn>[sync'ing older file]<def>
unable to read: %s
internal 612112001
internal 612112002
internal 612112009
internal 612112029
internal 612112006
internal 612112006.2
cache
cannot open input file %s   
while reading %s: incomplete data
internal #113701
internal #113702
internal #113703
internal #113733
internal #113704
internal #113704.2
internal #113705
[%s : about to copy time]
[%s : time copied]
-----
write
cannot open output file %s (rc %d)
failed to fully write %s, user interrupt
failed to fully write %s   
stop
verify failed, file differs: %s - retrying write
verify failed, file differs: %s - giving up
file not found: %s
cannot fully write (disk full?): %s
buffer overflow #213461 %d
buffer overflow #213462 %d %d
mname %s %s
0 = MATCH (msk %.100s, str %s) r2
PART %s neg %d
%d = MATCH (msk %s, str %s) %d^%d r3 %p
CHK0 bneg %d (msk %s,str %s)
0 = MATCH (msk %s, str %s) r4
CHK2 bneg %d (msk %s,str %s)
CNT2 bneg %d
%d = MATCH (msk "%s", str "%s") %d^%d
file-exclud: %s due to "%s"
1 = msbm (msk %s, str %s)
file-wmatch: %s to "%s"
0 = mswm (msk %s, str %s)
God A red nugget A fat egg under a dog
file-keep  : %s (wmask=%d/%d bmask=0/%d)
file-exclud: %s (wmask=%d/%d bmask=0/%d)
dir-exclude: %s due to "%s"
dir-wmatch : %s to "%s"
dir-keep   : %s (wmask=%d/%d bmask=0/%d)
dir-exclude: %s (wmask=%d/%d bmask=0/%d)
scan 
cannot read: %s%s
max line length %d reached, splitting input line(s) in file %s
%05d : %s
%05d : %s
%05u %s%s%.*s%s
%s%s%s%s%s
%s%s%s%s%s
%u files
[dir]
%*.*s
%*s kb
%*s mb
%*s gb
[dif] 
[tim] 
[add] 
%s,              %.*s%s%s
%s kb,              %.*s%s%s
%5d mb,               %.*s%s%s
t=%04x m=%04x l=%04x 
%s%c%s%s
%s%c%s%c%s%s
%d files
.bat
%.*s	= 
%s%.*s
$totouch:<def> %s
cannot change time: %s
$touched:<def> %s
path
purepath
ppath
quotpath
qpath
purefile
pfile
quotfile
qfile
pure_file
p_file
quot_file
q_file
relfile
rfile
purerelfile
prfile
quotrelfile
qrfile
qrelfile
base
purebase
pbase
quotbase
qbase
pureext
pext
quotext
qext
since
puresince
psince
quotsince
qsince
quottext
qtext
orp %u %u - %s row %d
orp none in %s
missing reference name, cannot replace "since" token.
-sincedir/add/diff may not have been specified before.
a previous command may not support passing -since names.
[%s] 
no valid token in run command. type "sfk run" for help.
command buffer overflow
 >"%s"
 2>&1
cannot read command output file: %s
cached %d lines, rc %d
rc %d
wrote
%d lines, rc %d
... rc %d - stopping due to return code.
... rc %d
... error, rc %d
%5d mb %s
%s, %5d files, %.*s%s
%s kb, %5d files, %.*s%s
%5ld mb, %5d files, %.*s%s
internal 812064
%d = isEmptyDir(%s)
fileid already set: %s
skipping content, already done: %s
cannot read dir: %s
empty dir: %s
] esd: %d %s files=%d ts=%d sd=%d
\u%02x%02x
0x%x,
import java.io.*;
public class %s {
	public static void main(String args[]) throws Throwable {
		byte abData[] = %s_getBlock();
		FileOutputStream fout = new FileOutputStream(args[0]);
		fout.write(abData, 0, abData.length);
	public static int %s_BlockSize = %d;
	static String %s_RawBlock[] = {
	public static byte[] %s_getBlock() {
	   int iout=0, nblen=%s_BlockSize;
	   char atmp[] = new char[%d];
	   byte aout[] = new byte[nblen];
	   for (int i=0; i<%s_RawBlock.length; i++) {
	      String stmp = %s_RawBlock[i];
	      int nlen = stmp.length();
	      stmp.getChars(0,nlen,atmp,0);
	      for (int k=0; k<nlen; k++) {
	         char c = atmp[k];
	         byte bhi = (byte)(c >> 8);
	         byte blo = (byte)(c >> 0);
	         aout[iout++] = bhi;
	         if (iout < nblen)
	            aout[iout++] = blo;
	      }
	   }
	   return aout;
#define %s_BLOCK_SIZE %u
static unsigned char %s_abRawBlock[%u] = {
// input : target buffer and buffer size.
//         must have size >= %s_BLOCK_SIZE.
// result: 0 if OK, 9 on buffer overflow.
// note  : output data is not null terminated.
int %s_getBlock(uchar *pOut, uint nOutSize)
   uchar *pCur    = %s_abRawBlock;
   uint nInSize  = %u;
   uchar *pMax    = pCur + nInSize;
   uchar *pOutMax = pOut + nOutSize;
   while (pCur < pMax)
   {
      uchar ncmd = *pCur++;
      if (ncmd >= 64) {
         uchar nsiz = ncmd >> 6;
         uchar nrep = ncmd & 0x3F;
         for (; nrep > 0; nrep--)
            for (uchar i1=0; i1<nsiz; i1++) {
               if (pOut >= pOutMax) return 9;
               *pOut++ = *(pCur+i1);
            }
         pCur += nsiz;
      } else {
         uchar nrep = ncmd;
         for (; (nrep > 0) && (pCur < pMax); nrep--) {
            if (pOut >= pOutMax) return 9;
            *pOut++ = *pCur++;
         }
      }
   }
   return 0;
sum: "%s"
info   : outdated file "%s" in archive "%s"
info   : if you want to cleanup your archive tree later, see 10-stale-list.txt
error  : size mismatch of "%s" in archive "%s"
error  : maybe the file is too large, empty, unaccessible, or not zip compatible.
getpos failed on %s
setpos failed on %s
unable to open: %s
fseek err #3
fseek err #5
upd: %s
check failed: %s - content modified
%s - not found in database
%02x
 *%s
read 
spot-checking %02u%% of files (skip=%u).
illegal format in line %d:
"%s"
%u files %u mb %u kbs skip %u
MD5 mismatch: %s
%u files of %u failed verification.
info : %u files checked
OK. %u files checked
, %u mb, %u sec, %u kb/sec.
:# %s
too many snapfile targets
%.*s%s
                                                                                                                                                                
skipping snap file: %s
 mtime=
 size=
 code=utf16%s
webrc
 content=%s_error_page
%.50s%.*s%.40s%.40s%.40s%.40s
%u files, %u lines, %u mb
skip
failed to fully write %d bytes, possibly disk full
%u files, %u mb
snap
max line length %d reached, splitting. file %s, line %d
%u targets
%u sources
%d files of %d
file too large, skipping: %s
internal #278242039
REL *%s* 
BAS *%s* 
%s	%s	[by text "%s" within "%.*s"]
%s	%s	[by text "%.*s"]
buffer overflow #ld01 %d %d
internal: unexpected NULL in RefDst %d %d %d
buffer overflow #ld02 %d %d
%s -> %s
rename failed on %s
---------
%b %d %H:%M
%b %d %Y
Dez 31 9999
%c%s%s 1 ftp ftp %s %s 
<a href="
</a>
< %s
rwxr-xr-x
%c%s%c 1 ftp ftp %s %s 
file.name
file.relname
file.path
file.base
file.ext
missing outlen parameter for expression output function
invalid parameters for expression output function
missing filename data for expression output function
execSingleFile: %s
[nopre] cannot read file status: %s
file-exclude: %s too small
file-exclude: %s too large
binary
file-exclude: %s is %s
file-include: %s is %s
cannot get file time: %s
CMP src %s ref %s
cannot read file time: %s
file-exclude: %s is added file, %s does not exist
file-include: %s is added file, %s does not exist
file-exclude: %s same time as %s
differs by content: %s
file-exclude: %s differs against %s
file-include: %s content differs against %s
file-exclude: %s time but no content diff against %s
file-exclude: %s just time diff against %s
file-include: %s just time diff against %s
to single output file: %s
same output used twice: %s
specify -tofile filename or -nowarn to avoid this warning.
%04u %4.4s %4.4s %03u %.*s 
----
mkdir.1: %s
mkdir.2: %s
createOutDirTree for: %s
mkdir.3: %s
mkdir.4: %s
]  esdir: %s files=%d
]  esdir: path mask mismatch
]  esdir: using file masks
]  esdir: no file masks, process all
no reference dir: %s
cannot get dir time: %s
[line break near %d]
cannot write output file: %s
cannot fully write output file, probably disk full
out of memory (%d)
define: %d "%s" -> "%s"
int. #213131
abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz0123456789
0123456789
0123456789abcdef
invalid part number: %d
internal: missing token prio for part %d
part %d is always empty as part %d will block it: %s
part %d includes all characters of part %d and has same or higher priority.
because part %d is of variable length this means it will not collect anything.
you may rewrite part(s) as [bytes of ...] or [bytes not ...] without overlaps.
you may insert literals or other commands to search more precisely.
out of memory, cannot create output buffer (%d)
pattern %u: [part%u] is not used in output, may loose line endings.
internal: define() called with undefined char class type: %s
internal: multiple define on same index %d: %s
int. #213841
undefined part buffer %d to add to
overflow: part #%u at pos=%d maxlen=%d
sfkmatch: %s
syntax error while preparing: %s
found ] without [: %s
buffer overflow: %s
=== parseFrom.%d: "%s" ===
match.parse: $%02u %.30s
match.parse: added literal: %s (%d)
missing or wrong placed "]": %s
invalid "[" within enumeration: %s
use "\[" instead.
invalid "]" within enumeration: %s
use "\]" instead.
invalid "(" within enumeration: %s
use "\(" instead.
syntax error within enumeration: %s
syntax error in pattern: %s
literal too long: %s
missing blank: %s
chars
byte
char
xwhite
digits
digit
hexdigits
hexdigit
lstart
start
[start] is allowed only as first token.
match.class: set %i dynamic
lend
unknown command: "%s"
[others] requires a previous character class.
[others] requires a previous character class: %s
match.other: set %i dynamic
[others] searches nothing: %s
inversion of the part before others produces an empty character class
 with 
 not 
 of 
match.class: set %i static
int. #2144292
empty character list not allowed: %s
use \(\) or )( to select brackets as literals
bad range start: %s
use \x%02x- to start a range with non-alphanumeric character
use \- to use literal '-' in this enumeration
bad range end: %s
use \x%02x-\x%02x for a range with non-alphanumeric characters
bad sequence: %s
range end lower than start: %s (%X-%X)
internal: class not allocated (21.1)
internal: class not allocated (21.2)
match.init: tokens=%d lasttok=0x%X
[lend] must be preceeded by another command like [1 byte].
use [eol] to process (CR)LF line endings.
use [lstart] to search from line starts.
int. #2137241
int. #2137242
int. #2137243
tokstartor/end copied headmatch
using headmatch:
to.parse: $%02u %.30s
to.parse: added literal: %s (%d)
[all]
to.init: %d tokens
syntax error: %s
unexpected number: %s
parts 
invalid part range end: %s
invalid part range: %d
part
strip(part
,\0)
strip(... accepts only ,
) to strip null bytes
expression output function did not set max length for: %s
to.parse: added outfn: %s (%d)
unknown command in totext: "%s"
tail(
subset(
strtoi(
hextoi(
octtoi(
leftpart
invalid part reference: %s
invalid tail statement: %s
invalid sub statement: %s
swap(
allowed only at top level: %.20s
not allowed after -/+: %.20s
unexpected: "%.5s" within: "%s"
invalid part%d referenced in: %s
swap and strtoi cannot be combined: %s
part%d has no data
sub offset/length does not fit (%d,%d/%d): %s
tail length too large (%d/%d): %s
part%d has unexpected data length: %d
invalid input length function (rc=%d)
int. #2144291
match.miss%u:  literal: %s
tokendoreol.1
match.miss%u:  end
lend must be last token
match.miss%u:  eol
int. #2144281
match.miss%u:  char class at eod
match.miss%u:  char class fixed len
match.miss%u:  #%u char class single 0x%02X %s
int. #2144282
match.miss%u:  start or code
tokend.1 (%d)
int. #2144283
tokend.2
match.miss%u:  unknown
match.enter: len=%d start=%d lastrec=%d
match.step : off=%d imask=%d tok=%d
match.eodl : check endtok st=%d
match.eod  : #%u $%u %u last=%d
match.exec : #%u $%u t%u o%u %02d.%04d %-30.30s   %03d
int. #2144284
match.2next:  #%u t%d %u.%u bmcc=%d bmnc=%d bmnn=%d
MATCH : /[start]/ at file start
MATCH : /[end]/ at file end
MATCH : /[lend]/ at file end
match.empty: return miss
MATCH : len=%d "%s"
SFKMatch internal error: zero length hit for "%s"
missing call: provideBuffer
output overflow.1
internal #2137185
render: invalid text%d length %d
render: add text%d len=%02d: %s
internal #2137189
render: error %d while rendering %s
render: null result while rendering %s
render: invalid output token %d (value=%d)
wrong part number: %d
no such part: %d
render: invalid part%d length %d
render: add part%d len=%02d: %s
int. #2138211
output overflow.2: %d %d
int. #2131211
invalid lend on output rendering
    ==> len=%d "%s"
out of memory (bitfields)
invalid call to setbits: len=%u
int. #21212901
out of memory, trying tempfile fallback
out of memory. use -memlimit to avoid this.
memory limit reached, but no tempfile is configured to write to.
add -usetmp to allow temporary files.
memlimit reached : store %d mb in tempfile
create tempfile  : %s
int. #21212903
cannot write tempfile: %s
cannot write tempfile (disk full?): %s
flushed to temp  : %d mb
failed to write (disk full?): %s
output in RAM, would overwrite input. (%d mb)
output in RAM, overwrite input. (%d mb)
cannot rewrite file: %s%s
cannot write (disk full?): %s
mem-flush: %d msec for %d bytes
failed to fully write (data lost): %s (%d/%d)
output in RAM, unchanged.
close-flush: %d msec for %d bytes
would copy output from : %s
would copy output to   : %s
output in tempf. : copy over input.
temporary output missing, cannot copy back: %s
cannot replace file (write protected?): %s
move output from : %s
move output to   : %s
copy output from : %s
copy output to   : %s
cannot copy back temporary file, INPUT FILE GOT LOST.
input file was: %s
temporary file: %s
... stopping further processing.
output in tempfile is unchanged. will discard.
int. #215141,%p,%p,%d
[...]
wwwww
buffer overflow in dumpcontext (%d,%d)
execReplaceNew: %s
wrong recordsize value
unable to read: %s - skipping
empty file: %s - skipping
read
repl
out of memory, record size too large
cannot open: %s - skipping
interrupted by user.
replace @%s: %.*s -> %.*s
error %d on output
at offset 0x%.20s
 reldist %u (0x%x)
change
%s : %s %s%s
int. #21211502
int. #21211501 (%ld)
hits
changes
%02d%% %s%s : %s %s 
%s : pattern not found: %s
%s : pattern not found: 
hex 
 text 
[%s/%d/%d] %s%s
   %s%s bytes
%6d msec for input   read  (%d mb)
%6d msec for output  write (%d mb)
%11d file read   calls
%11d file write  calls
%11d file seek   calls
replace.file
replace -repeat and -to or -tofile cannot be combined.
-repeat can be used only with replace.
done %d repeats but remaining hits in %s
done %d repeats on %s
execReplaceFix: %s
failed to read: %s - skipping%s
failed to read+write: %s - skipping
 - stopping write. file may be damaged.
failed to seek within %s%s
... stopped reading at %d bytes (demo limit).
failed to fully read %s%s
int. #58281821
%02d%% %s%s : %s hits 
failed to seek within %s - stopping write. file may be damaged.
fseek
failed to write to %s - stopping write. file may be damaged.
%02d%% %s%s : %s changes 
 [binary]
some file(s) are larger than the memory limit. see option -memlimit under "sfk help opt"
execReplaceVar: %s
file too large to load: %s, %s mbytes
cannot load: %s
cannot load (2): %s
memory limit exceeded: %s requires %s mbytes for processing
say "sfk -memlimit=500m replace ..." to change the limit to 500 mbytes.
internal: memory overwrite past target block, on expand
internal: memory overwrite past target block, on shrink
tmp%crep%03dpat.txt
:binary
tmp%srep%03dsrc.dat
tmp%srep%03ddst.dat
tmp%srep%03ddst2.dat
cannot fully write, disk full: %s
.%csfk replace -quiet=2 -yes -bylist %s %s -to %s
cannot read checksum
Replace result mismatch:
   %d = %s
   %02X%02X%02X%02X : %s
binary  : %s
list of files containing tabs:
indent %d: %s
%2.2d/%3.3d 
DEL : %s
   <time>(was write protected)<def>
DEL : %s
dir not empty, cannot delete: %s
cannot get version from: %s
int. #28281250
vernum
no version number found.
name
type
title
date
info
%s	%s	%s	%s	%s	%s	%s	%s	%s
%s	%s	%s	%s	%s	%s	%s	%s	%s
no version found within: %s
[nopre] skip: %s - file too large
[nopre] skip: %s - text contains null byte(s)
<file>%s<def>
over
cannot %swrite %s
%5d tabs
entab
cannot overwrite %s
>                                   <                                   >                                   <                 
%c                                   %c                                   %c                                   %c                 
>                 <                   >                 <                 
%c                 %c                   %c                 %c                 
%s : cannot read - skipping
    
%s:file %s
%s:file %s
%s : cannot seek - skipping
dump from %s 
to %s 
a total of %s bytes
0x%02X,
 [binary, skipping %u bytes]
                                                    #                      
%04X
%02X 
illegal size
cannot open
expected / written: 
... block write failed
cannot open output file %s   
cannot write shadow file %s   
failed to write %s   
copy stopped, cleaning up: %s
copy stopped, cleanup done.
failed to read attributes: %s
failed to write attributes: %s
stop 
internal #0505071820
%s not relative to %s (1)
%s not relative to "%s" (2) %c
internal 812063
%u files %u dirs
%s : skip, no files copied.
cannot read dir time: %s
%s : no time / attrib change
%s : ignore time difference (%d)
%s : copying attribs, ndif %d
copy time
copy: missing source root dir. file=%s
copy.check %s => %s [root=%s]
unexpected target name format: %s
%c%s
%czz-shadow-01%s%s
source is older
no diff, skip: %s
same time/size, but content diff: %s
, same content
, diff. content
[%s : differs, rc %d%s]
[%s : differs, rc %d]
check failed: %s - content changed, skipping copy
%s - not found in metadb, skipping copy
master file modified, using shadow: %s
check failed: %s - skipping copy (%d)
stale: %s / %s - %d days until deletion
stale: %s - %d days until deletion
DEL: %s / %s
DEL: %s
failed to delete: %s
zz-shadow-
wrong metadb name: %s
<time> +shadow<def>
DIF: %s   (%s)
DEL: %s
failed to delete: %s
$skip <def> %s - binary
$skip <def> %s - nothing to change
crlf
$%s %s %s %s<def> %s
missing arguments. type "sfk" without parms for help.
PATH
no PATH variable found.
skip: %s
probe: %s
hit: %s
failed to receive %s, %s
< %s
SKIP 
SKIP
/../
\..\
failed to send %s, %s
cannot get size of %s
send
cannot read %s
cannot fully read %s (1)
connection closed while sending %s %s
the file cannot be written at receiver.
send stopped by user.
> send incomplete: %s (%s/%s)
< %s sent, %s bytes.       
internal #201
SKIP %d
cannot fully read %s (2)
metalen
flags
[using sft101 for compatibility.]
failed to send md5, %s
> waiting for i/o commands.
unexpected EOD or close, %s
> got cmd: %s
SREAD 
failed to send requested %d bytes
< sent %d
SSUM
unexpected verify request
< sending sum
SCLOSE
< send skip
waiting for ack. if this blocks, try CTRL+C.
> wait for ack
transfer or write of file failed: %s    (%s)
recv
cannot write to "%s"
> set attr=%s for %s
out of disk space: %s
failed to write %s (disk full?)
> incomplete file, cleaning up: %s (%s/%s)
> %s received, %s bytes.       
unsupported SFT protocol version
illegal length received (%s). use -maxsize to change limit.
< sread %d, remain=%d
SREAD %d
failed to send SREAD for "%s" %s
data
failed to fully receive "%s"
failed to fully write, probably disk full: "%s"
SSUM
failed to receive checksum, %s
> wait for sum
send close
SCLOSE
failed to send close, %s
wait for skip
EE01
unexpected data received, transfer broken.
md5 mismatch - transfered file corrupted.
local: %02X %02X %02X %02X
remot: %02X %02X %02X %02X
check if the file is in use by another process.
failed to send reply, %d, %s
cannot create socket
cannot get host, rc=%d
cannot connect to %s:%u, %s
. sft 
> server speaks sft %d.
> unexpected sft info "%s"
USER %s
PASS sft%d@%s
PASS %s
PASS sft%d@
500 
TYPE I
SCHK 1
PASV
%d.%d.%d.%d
pasv data
MDTM %s
213 
time: local=%u far=%u diff=%d
Old SFT server, verify enforced.
 -yes
help
client commands:
   cd lcd dir !dir put get mput mget bye
   run (with sfk sft server)
server commands:
HELP
CWD %s
lcd 
cannot cd to %s
ccd 
no such local dir: %s
ccd stopped, no such remote dir: %s
cannot cd local to %s
LIST%s
226 
SLST%s
NLST%s
RC: %d
run 
cannot run, remote server speaks no SFT.
SRUN %s
put 
STOR %s
SPUT %s
mput
cput
missing mask. supply a name fragment or just "*"
mask: "%s"
$[simulating:]
skip: %s - unchanged. (or use -all)
cannot send: %s
would be 
%d files of %d %ssent, %d failed, %d sec.
add option -force to continue transfer after errors.
%d files of %d %ssent, %d sec.
$[add -yes to execute.]
ftp: have no filenames from previous commands.
int. #204292351
get 
RETR %s
SGET %s
mget
cget
missing mask. supply a name fragment (without *), or just "*"
LIST
SLST
> received %d filenames
wrong format: %s - skipping
%s %s %s
] skip, size=%s: %s
> %s, %s bytes.
] filetime set: %s, %d
%d files received, %d failed, %d sec.
%d files %sreceived, %d sec.
int. #204292352
> %s
would receive %d files, skip %d unchanged.
would receive %d files.
%d files received, %d unchanged skipped, %d sec.
%d files received, %d sec.
connection closed.
cannot create %s (%u)
cannot bind on port %u, using alternative port %d.
cannot bind %s (%u)
info : maybe a different app is running, or firewall blocks access.
info : you may retry with a different port, e.g. -port=30199.
getsockname failed, %d
- local port %u (%u, %u)
cannot listen on %s (%u)
cannot create %s
cannot get host for %s
< connect to %s:%u
cannot establish connection for %s
first GA part must be a number: "%s"
2nd GA part must be a number: "%s"
3rd GA part must be a number: "%s"
data length must be a number: "%s"
missing number data value: "%s"
KNX: %d/%d/%d len=%d data=%02X
KNX: %d/%d/%d len=%d data="%s"
tunnel
route
%u/%u/%u
 KNX: %s %s bit(s): %X
 KNX: %s %s byte  : %03u (0x%02X)
 KNX: %s %s data%02u: "%s"
 KNX: %s %s data%02u: %03u (0x%02X) total=%d
 KNX: nmc=%X addil=%X ctl1=%02X ctl2=%02X src1/2=%02X%02X dest1/2=%02X%02X
 KNX: tcpi=%u ncnt=%u acpitype=%u acpidata=%u
 KNX: search request
 KNX: search response
 KNX: service %04X
cannot bind UDP socket to port %d (%d %s).
bad address: %s
no default route to support multicast.
try 'route add -net 224.000 netmask 240.000 eth0'
[waiting on %s port %d for data.]
[waiting on port %d for data.]
%d.%m.%Y %H:%M:%S
%s----- #%03d from %s at %s (%d bytes) -----
%-15.15s%s
$%-15.15s<def>%s
[#%03d received %d bytes from %s]   
[#%03d received %d bytes from %s]
[echoing back]
[forwarding to %s:%d]
cannot drop multicast membership.
%sNTP-time %s %s from %s
udpsend
failed to send data (%d)
[sent %d bytes, %s]
[received %d bytes from %s %s]
[timeout]
cannot get host %s, rc=%d
[received reply with binary, %d bytes. dumping first %d:]
[received reply with binary, %d bytes:]
[received reply, %d bytes:]
server main port
waiting on port %u for connections
, to forward to %s:%d
. timeout is %d milliseconds.
accept on server main port failed
[got connection, trying forward-connect]
cannot create forward socket
cannot get host: %s
[forward-connected to %s:%d]       
[got connection]
GET 
POST 
HTTP
[received request from back: binary, %d bytes]
[received request from back with %d bytes:]
[forwarded %d bytes]
[forwarded %d bytes of %d - incomplete]
[received reply from front with binary, %d bytes. dumping first %d:]
[received reply from front with binary, %d bytes:]
[received reply from front:]
[backwarded %d bytes]
[backwarded %d bytes of %d - incomplete]
[timeout, no data over %d msec]
[%c waiting for input, %d/%d sec]
[closing forward connection]
[client disconnected]
<p><form method="POST" enctype="multipart/form-data" action="/">
<table><tr><td>
<input type="file" name="filename"/>
</td><td>
<input type="submit" value="upload"/>
</td></tr></table>
</form>
HTTP/1.1 500 server error
Server: Swiss File Knife 1.7.4 linux-lib6
Content-Type: text/html
<html><body>
</body></html>
< ERROR: %.80s
SFK Instant HTTP Server. For help, type "sfk httpserv -help".
 or 
Waiting on port %u. Try http://%s/ in your browser.
Waiting on port %u. Try http://%s in your browser.
Waiting on port %u.
> connect from %s
POST / 
writing not allowed
wrong POST format
content-type
multipart/form-data
boundary=
wrong content-type: %s
content-boundary too long
--%.*s--
content-length
wrong content-length: %s
missing boundary header
missing content length
filename="
missing filename
missing quote
path traversal not allowed: %s
cannot write: %s
int. error during POST read, %d %d %d
cannot fully write (disk full?): %s
failed: %s (error %d)
saved : %s (%s bytes) md5=%s
GET / HTTP/1.1
HEAD 
500 unsupported command: %.200s
HTTP/1.1 200 OK
Cache-Control: no-cache
Swiss File Knife Instant HTTP Server, 1.7.4, linux-lib6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="/">refresh</a>
<pre>
</pre></body></html>
< sent content listing.
HTTP/1.1 404 no such file
404 no such file: %.200s
application/octet-stream
image/jpg
.png
image/png
.gif
image/gif
favicon.ico
image/x-icon
text/plain
.htm
text/html
Content-Type: %s
Content-Length: %s
failed to open: "%s"
< [%d bytes data]
failed to send data (%d/%d) %s
< sent %s bytes, content-type: %s
< transfer incomplete.
SFK_FTP_USER
_USER
SFK_FTP_PW
SFK_FTP_RUNPW
_RUNPW
[using SFK_FTP%s for authentication]
string too long: %s
work dir parameter cannot be combined with -usedir: %s
-usedir cannot be combined with work dir parameter: %s
too many -usedir statements
FROM %s TO %s
no mapping for: %s
map.sys: %s
use.abs: %s
550 Invalid path
use.sys: %s
550 forbidden path
552 No disk space info
# out of disk space. free=%s mb, limit=%s mb
552 Out of disk space
550 invalid path
] invalid path: %s
500 internal error
unknown error
Stopped by admin
Out of disk space
Write failed
%03u %s
, IP 
SFK Instant FTP %d. For help, type "sfk ftpserv -help".
waiting on port %u%s%s%swrite allowed, %u MB limit per file. 
waiting on port %u%s%s%sonly read allowed. 
%d sec timeout.
220 sfk instant ftp, %d sec timeout. sft %d.
500 wrong protocol (http), please use ftp://
feat
211-Features:
 MDTM
 SIZE
211 End
user 
530 missing username
331 User name ok, need password
PASS sft
> client speaks sft: %d
PASS 
> missing client username
530 missing authentication.
> wrong client username (%s/%s)
530 wrong authentication.
> client user ok.
> missing client pw
> wrong client pw
> client pw ok.
230 User logged in
> client connected.
# new incoming connection, closing current
226 closing connection due to new client
500 inactivity timeout (%d sec)
> client disconnected (timeout).
214-Possible commands:
   USER   PASS   QUIT   CWD    PWD    PORT   PASV
   CDUP   RETR   STOR   SIZE   DELE   SYST   MDTM
   LIST   NLST   MKD    RMD    RMTREE FEAT
   TYPE  (only binary transfer supported)
214 Command list end.
NOOP
ALLO 
200 OK
SYST
215 UNIX emulated by SFK.
TYPE 
200 Command OK
SCHK 
200 CheckMode=%d
502 checkmode not supported
XPWD
257 "%s" is current directory.
SIZE 
213 %s
MDTM 
550 no such file
RETR /
550 File not found
CWD 
550 Invalid dir
250 CWD OK. "%s"
550 No such directory
CDUP
XCUP
MKD 
XMKD 
532 Write not allowed
550 Cannot create. err=%d/%s
257 "%s" created.
passive server port
- reply pasv with ip %s
227 Entering Passive Mode (%s,%u,%u)
- wait for accept on %s:%u
accept on passive port failed
accept timeout for passive port
> accept done
passive accept failed
PORT 
active data
200 Okay
503 Wrong command sequence
501 unsupported option: %s
150 Listing Directory %s
550 invalid work dir
- done list "%s"
- done list, rc=%d: "%s"
226 Closing data connection
NLST
RETR 
500 internal error 1
150 Sending File
send file: "%s"
send file done, RC %d
STOR 
500 internal error 2
150 Receiving File
> recv file: "%s"
> recv file done, RC %d
RNFR 
550 file not found: %s
350 File exists, please send target name.
RNTO 
550 file exists: %s
503 Bad command sequence
550 rename failed (%s)
250 rename successful
DELE 
550 delete failed (%s)
250 OK DELETED
RMD 
XRMD 
550 no such directory
300 DELETE FAILED. err=%d,%s. (try rmtree?)
RMTREE 
300 DELETE INCOMPLETE
QUIT
SGET 
SOPEN 
550 no such file, or unreadable
200 OK, data follows
send sft file done, RC %d
SPUT 
500 cannot write: %s
200 OK, send data
recv sft file done, RC %d
SLSB
226 Listing done
SRUN
500 run forbidden
530 run requires authentication
/%s/%s/
530 wrong run authentication
200 Run Done, RC %d
500 not supported: "%.20s"
disconnecting client
unable to load %s
wrong record format in %s line %d
unable to write %s
%s:%s
format string too long: "%s"
illegal value for \xnn in format string. use 01 to FF, e.g. \x09
illegal value for \dnnn in format string. use 001 to 255, e.g. \d065
 create symbol: %s
   %s collects "%s"
   %s now holds "%s"
 %s %p solves "%s"
   sel "%s"
syntax error: probably too many commas in line: %s
   cat "%s"
  call "%s"
no such symbol: "%s"
   now on "%s"
upper
anycase
upper2
too many symbols
buffer overflow.1
all: %s
LINE "%s"
state %d on "%s"
syntax error: missing "symbol:" in line %d
syntax error: missing content after "%s:"
syntax error in line %d
encodeUrl buffer overflow
%%%02X
wrong url entity code: %%%s
buffer overflow: pattern too large: "%s"
%s: %s [within %s:%d]
%s: %s
unexpected command
use :text or :binary followed by pattern lines
use -text ... or -binary ...
patterns must look like "/from/to/" or "_from_to_"
with three times a delimiter character like / or _
if "%s" is a single filename, specify it as first parameter.
surround your expression by two double quotes "
escape inner quotes as \" or \q (with -spat option)
say -dir ... -file ... to specify multiple target files.
illegal replacement string "%s"
source pattern is empty
source pattern too large "%.*s"
destination pattern too large "%.*s"
wrong replacement string syntax "%s"
if "%c" is the delimiter then "%s" is unexpected.
aprep: input src %.*s
wrong source pattern. try \%c or option -literal to replace %c
aprep: fromleft %d toright %d szsrc %s
rleft "%s" ifirst %d
buffer overflow during replace
input lines might be too long, or too many changes per line.
if input is stream text, you may try filter -wrap +filter ...
rmid  "%s"
rrite "%s"
rout: "%s"
format overflow: %s
unexpected: %s
string buffer overflow
not a number: %s
line
count
%s%%%ss%s
col(start:
%%%ss
missing ')' on expression: %s
cannot evaluate: %s (rc=%d)
(count
(count not closed by ')'
wrong syntax or not supported: %s
-(pre)context supports only up to %d lines
-ls+
-le+
+ls+
-ls!
-le!
-ls:
-le:
-no-empty-lines
-no-blank-lines
-unique
-keep-empty
-keep-blank
1-pat
Degas are we not drawn onward no In union drawn onward to new eras aged
1-notpat
3-inc
3-ex
3-cut
1-addmark
1-keep
-encode-
-decode-
-ansitodos
-todos
-dostoansi
-toupper
-tolower
-ltrim
-rtrim
-trim
-rep
-lsrep
-lerep
-sep
-blocksep
-form
-tabform
-where
-lswhere
-lewhere
-within
-lswithin
-lewithin
-lnum
-count
-cnt
-join
-hitfiles
-global-unique
-precontext=
-precon=
-postcontext=
-postcon=
-context=
selection options (%s) are not allowed after processing options.
say +filter %s instead.
-addmark
missing parameter(s) after %s
-high
-lshigh
-lehigh
try to use quotes "" with %s parameters.
%s must be followed by separator characters, e.g. %s "; "
-write
-rewrite
-writeall
unexpected parameter: %s
you may forgot -form or -tabform
filter input is coming from a previous command.
if you try to redirect output, there might be a quote count problem.
try using -spat ... and \q instead of \"
filter does not support short dir+file selection syntax.
specify a single input file, or -dir ... -file ... format.
[filter npats=%d before %s]
unknown option: %s
line selection option(s) AND -write may cause massive changes.
-lnum or -count AND -write will change all selected files.
-wrap together with -write is not supported.
OPTIONAL 
 %s"%s"
 %sLINE START "%s"
 %sLINE END "%s"
AND 
 LINE MUST START "%s"
 NOT "%s"
-keep
-keep-
-inc
filter -inc: missing "to" keyword
filter %s: only one -inc or -cut with * allowed
... you may try "+filter %s" instead of "%s".
filter -inc: found end of block without start: %s
file %s line %d
add option -nocheck to ignore unexpected block endings.
-cut
filter %s: missing "to" keyword
-cut-
filter %s found end of block without start: %s
 ALL LINES: no filters given.]
missing arguments after %s
lswithin
lewithin
missing -replace after %s
buffer overflow on %s ...
-noshow
missing argument after %s
-rep must be followed by a pattern
-noop must be followed by a parameter (which is ignored)
-sep must be followed by separators, e.g. -sep ;
illegal value for \xnn in -sep. use 01 to FF, e.g. \x09
-form must be followed by %ccol1 etc., e.g. -form "%ccol2 %ccol5"
-encode-perc
-decode-perc
%03u 
out of memory
<prefix>%03u<def> 
skipping binary file: %s
input file too large: %s (adjust -memlimit)
readonly file, cannot overwrite: %s
cannot read file: %s%s
-write requires a filename.
lprefix=
%d mb, %d subfiles
[read file %s, find:
[read stdin, find:
wrong chaining mode: filter collects text but not filenames.
try to insert +ttf or +texttofilenames.
int. #141271849
filter -cut from * end marker not found, will not rewrite.
add -noinfo to hide this message.
filter -cut from * end marker not found, stopped processing.
add -nocheck to continue with empty text.
%5d changes
failed to write to: %s
%d filter -inc block(s) open at end of: %s
one or more blocks starts were not followed by a block end.
add option -nocheck to ignore missing block endings.
%d filter -cut block(s) open at end of: %s
one or more block starts were not followed by a block end
cannot read: %s %s
input line %d wrong format (%d): %s
[warning:%d]	%s
unable to open test file %s
unable to fully write test file %s
unable to re-read test file %s
Testing Volume %s, FileSystem %s, over %u mbytes.
test range too large: volume has only %d free mbytes
Writing 100 temporary files of %s mbytes each. Press ESC to stop.
out of memory, cannot allocate working buffer.
%s%stmp-test-%02u.dat
%03u%% > %.50s < 
%03u%% > %.50s < - 1st half written.
%03u%% > %.50s < - 2nd half written.
Write done at %u kbytes/sec.%.40s
Reading and verifying temporary files.
1st half contains Errors.
1st half OK.
%03u%% > %.50s < - %s 
2nd half contains Errors.
2nd half OK.
Read done at %u kbytes/sec.%.40s
%02u%% cleanup test files ... 
%s mb of file system checked, errors detected:
%s bytes failed to re-read after write.
%u test files with bad sectors are left over, to cover the bad areas.
%s mb of file system successfully written and re-read.
.part
non-digit character '%c' is not allowed
expecting input filename ending like .part1, .part001 etc.
first input file not found: %s
%s output file exists, overwrite? (y/n) 
cannot write output file: %s
%s.part%0*d
int. error while building name: %s
open.read: %s
%s mb [Esc to skip]
verify skipped.
%s mb
read.blck: %d maxbuf=%d
writ.blck: %d
A Santa lives evil at NASA
clos.read: %s totalDone=%d
tested join of %d files, %s total bytes.
%s created from %d files, %s total bytes.
[verify]
md5 = %s   %s 
checksum mismatch - re-read of output files failed.
- OK
 ----- changes to -----
-help
/help
missing parameter after option %s
createddirs list has remaining entries:
syntest
rc %d : 
%d syntax checks failed (%d passed).
: OK : %d syntax checks passed.
command "%s" does not support chaining.
command "%s" does not support chaining (+%s).
say "sfk -nochain ..." if you want to process a file with name "+%s"
done in %s msec. 
failed to sort, probably out of memory
int. #168281033
%0*u	
int. #168281035
int. #168281034
int. #168281039
cannot open: %s
- : %s
> : %s
< : %s
%-10.10s 
write to single output file: %s
wrong URL format: %s
write to joined output path: %s
need -path2name or -fullpath on URLs like : %s
cannot write: %s%s
cannot fully write %s, probably disk full.
download will not be cached (too large).
int. #228290640
done : %s (%s bytes).
	name	sfk-index-
invalid index format, skipping: %s
index files must contain a headline with {tab}name{tab}sfk-index-
   $see also
      $--- open source commands ---
      #sfk find<def>      search  fixed    text in   text/binary files
      #sfk ftext<def>     search  fixed    text in   text        files
      #sfk hexfind<def>   search  fixed    text in        binary files
      #sfk replace<def>   replace fixed    text in   text/binary files
      #sfk filter<def>    filter and edit  text with simple wildcards
      $--- freeware commands ---
      #sfk xfind<def>     search  wildcard text in   text/binary files
      #sfk xtext<def>     search  wildcard text in   text        files
      #sfk xhexfind<def>  search  wildcard text in   text/binary files
      #sfk extract<def>   extract wildcard data from      binary files
      #sfk view<def>      GUI tool to search text as you type
      $--- xe commercial commands ---
      #sfk replace<def>   replace fixed    text with high performance
      #sfk xreplace<def>  replace wildcard text in   text/binary files
      #sfk help xe<def>   about SFK XE and xreplace with SFK Expressions.
   $wildcards and SFK expressions
      SFK Expressions are simple patterns containing literal text,
      wildcards * and ? and character classes in square brackets [].
      basically, the syntax provides extended wilcards but no
      further logic and is not related to regular expressions.
      search patterns are surrounded by a separator character which
      can be anything not contained in the search text, like / or _
      $within a pattern #/fromtext/totext/<def> $the #fromtext<def> $may contain:
      $within a search pattern #/fromtext/<def> $the #fromtext<def> $may contain:
        $*<def>                       - 0 to 4000 characters in the same
                                  text line or paragraph, i.e. all
                                  bytes not being CR, LF or NULL.
                                  4000 is just a default maximum
                                  that can be changed by:
        $[0.100000 chars]<def>        - 0 to 100000 characters in the same
                                  text line or paragraph, i.e. the
                                  same as * but with a larger range.
        $?<def>                       - one character.
        $?????<def>                   - same as $[5.5 chars]<def> or $[5 chars]<def>
        $[bytes]<def>                 - 0 to 4000 bytes (with CR,LF,NULL)
                                  i.e. it collects stream text
                                  across lines, even in binary data
        $**<def>                      - the same as [bytes].
        $[0.100 bytes]<def>           - 0 to 100 bytes
        $[.100000 bytes]<def>         - up to 100000 bytes
        $[1.* bytes]<def>             - 1 to default maximum bytes
        $[30 bytes]<def>              - exactly 30 bytes
        $[byte of aeiou]<def>         - one vocal (a OR A OR e OR ...),
                                  case insensitive by default.
                                  "aeiou" is a character list.
        $[byte of \\\x2f]<def>        - a backslash \ or forw. slash /
        $[bytes of \r\n \t]<def>      - whitespace incl. line ends
        $[bytes of (\r\n \t)]<def>    - the same, () are optional
        $[bytes not \r\n\0]<def>      - up to 4000 bytes as long as no
                                  CR, LF or NULL byte appears
        $[chars]<def>                 - the same as $[bytes not \r\n\0]<def>,
                                  i.e. collect text in a line
        $[char not ( \t)]<def>        - same as $[byte not ( \r\n\0\t)]<def>,
                                  everything not blanks and tabs
        $[char not )( \t]<def>        - not brackets, blanks and tabs,
                                  same as $not (\(\) \t)<def>
        $[chars of a-z0-9]<def>       - means a-zA-Z0-9 as search is
                                  case insensitive by default
        $[chars of \x61-\x7A]<def>    - search a-z but not A-Z, or use
                                  option -case for case search
        $[eol]<def>                   - end of line by characters:
                                  CRLF or LF or CR
        $[white]<def>     = chars of (\t )     - 0 or more whitespaces
        $[xwhite]<def>    = bytes of (\t \r\n) - same but across lines
        $[1 white]<def>   = byte  of (\t )     - 1 whitespace
        $[digit]<def>     = byte  of (0-9)     - 1 digit
        $[digits]<def>    = bytes of (0-9)     - 0 or more digits
        $[hexdigit]<def>  = byte  of (0-9a-f)  - 1 hexadecimal digit
        $[hexdigits]<def> = bytes of (0-9a-f)  - 0 or more hex digits
        anchors that have no length of their own:
        $[start]<def>  - start of file
        $[end]<def>    - end of file
        $[lstart]<def> - line start, i.e. start or CRLF or CR or LF
        $[lend]<def>   - logical line end, i.e. eol or end of file
        $how to search or replace special characters:
        - to search or replace text containing the literal characters
          $* ? \ [ ]<def> then these must be escaped like #\\* \? \\ \[ \]<def>
        - $( )<def> are escaped only within character lists, like #\( \)<def>
        - to search or replace the $forward slash '/'<def> type $\x2f<def> or use
          another char around from/to text, e.g. #_fromtext_totext_<def>
        - parameters with #blanks and non trivial characters<def> need double
          quotes "", see also "about Shell Command Characters" below.
        $expansion priorities:<def> (highest first)
        if two search parts are side by side, and the same input
        character matches both, then these priorities apply:
          5: start, end, lstart, lend
          4: literal text, eol
          3: whitelist classes: byte of, bytes of
          2: blacklist classes: chars not, bytes not
          1: plain wildcards: ?, *, **, byte, bytes, chars
        this means in "/[bytes]foo/" the [bytes] will stop to collect
        characters as soon as "foo" is found, as "foo" is a literal.
        on same or higher priority the right side stops the left side.
      $the #totext<def> $may contain:
        $[part 1]<def>          - use first text part of the fromtext.
                            e.g. the fromtext #/*foo[.100 chars]bar*/<def>
                            contains parts    # 1 2         3    4 5
        $[part1]<def>           - the same (blank is optional).
        $[parts 1,2,3]<def>     - use parts 1, 2 and 3.
        $[parts 1-10]<def>      - use parts 1 to 10.
        $[strip(part1,\0)]<def> - use part 1 but remove zero bytes.
                            only zero bytes "\0" can be removed.
        $[file.name]<def>       - full input filename with path
        $[file.relname]<def>    - input filename without path
        $[file.path]<def>       - input file's path
        $[file.base]<def>       - relname without last .extension
        $[file.ext]<def>        - input filename extension
        $[all]<def>             - use all parts from fromtext.
        although anchors like lstart, lend count as a separate part
        they need NOT be specified in the totext. this means that
        /[lstart]foo[lend]/bar/ just changes the word "foo".
   $supported slash patterns
      $\t<def>    = TAB
      $\r<def>    = CR
      $\n<def>    = LF
      $\x00<def>  = one byte with code 00 hexadecimal
      $\0<def>    = short form for \x00
      $\q<def>    = a double quote "
      $\\ <def>   = the backslash character \ itself
      $\[<def>    = the bracket open character [
      $\]<def>    = the bracket close character ]
      $\\*<def>    = the literal star character *
      $\?<def>    = the literal question mark  ?
      $\-<def>    = to use literal "-" in a command
      Within multi line -bylist files:
      $\ <def>    = slash+blank is changed to a single blank
      Only within "char of" or "byte not" lists:
      $\(<def>    = to use literal character "("
      $\)<def>    = to use literal character ")"
   $SFK expression options
      -showpart(s)  print /from/ part numbers, range statistics
                    and expansion priority points per part.
                    done automatically if a required /to/ text
                    is not given with a command.
      -showbest     if a /from/ pattern finds nothing, use this to
                    see how many parts would match so far, and with
                    up to how many bytes per part. anchors like [lstart]
                    may show a non zero length when matching (CR)LF.
      -showlist     with -bylist, show the internal joined list if
                    commands are spread across multiple lines.
      -showall      show all of the above.
      -xmaxlen=n    set default maximum length for chars or bytes commands,
                    e.g. -xmaxlen=10000 means /foo*bar/ matches with up to
                    10000 characters between foo and bar. the default max
                    length without this option is 4000 characters.
   $performance notes
    - always use a string literal, or single byte or char, at the start
      of your search expressions, like in $/foo*bar/ starting with 'f'.
      #Do not use a wildcard like * at the start like in #/*foobar/<def>
      when searching huge input data, as your search will #slow down by
      #factor 256.<def> Use $/[lstart]*foobar/<def> instead.
    - the system may cache output file(s), writing to disk in background
      after sfk has finished. subsequent batch commands may execute slower.
   $about example numbers with [brackets]
      if you see [1] type "sfk cmd 1" for whole command in one line.
   $bad examples with corrections
      #if input text contains:
         bool bClFoo;
         bool bClBar   ;
      #sfk xfind in.txt "/bool[xwhite]bCl*[xwhite];/"
         does NOT match "bool bClFoo;" because * eats the
         whole input line including ";" so no input is left
         for "[xwhite];" and the whole expression fails.
      #sfk xfind in.txt "/bool[xwhite]bCl[* not ;][xwhite];/"
         does both match "bool bClFoo;" and "bool bClBar   ;".
         this means whenever your search fails to work write
         in detail which characters (not) to collect where.
      #sfk xex in.txt "/[lstart]foo/[lstart]goo/"
         there is no need to write an anchor like [lstart]
         within totext as it contains no data. use instead:
            sfk xex in.txt "/[lstart]foo/goo/"
      #sfk xex in.txt "/foo[lend]bar/goo[part2]bar/"
         anchors like [lend] must be at start or end of fromtext
         and cannot be referenced within totext. use instead:
            sfk xex in.txt "/foo[eol]bar/goo[part2]bar/"
   $working examples
    $SFK Extended Edition only:
      #sfk xrep mydir "/foo*bar/"
         an incomplete command (missing "totext" part in pattern).
         sfk shows an info text telling about part numbers
         and runs a search for "foo*bar" in all files of mydir.
         nothing is changed so far.
      #sfk xrep mydir "/foo*bar/[part1]goo[part3]/"
         same as above, but now the /fromtext/totext/ is complete.
         again sfk runs a search for "foo*bar", but now it displays
         the changed output text (totext), with everything between
         "foo" and "bar" being changed to "goo". add option
         -dumpfrom to display the original found text instead.
      #sfk xrep -text "/class* CFoo/[part1][part3]/" -dir mydir -file .hpp
         search only .hpp files within mydir, and replace for example
         "class IMPORT CFoo" by "class CFoo".
      #sfk xrep -pat "/[byte not \n][end]/[part1]\n/"
       #-dir mydir -file .cpp .hpp -dumpall
         find all .cpp or .hpp files in mydir whose last line is not
         ending with a linefeed, and add the linefeed. to check exactly
         what is changed dump both input and output text. [23]
      #sfk xrep -dir mydir -file .hpp -enddir
       #-text "/[byte not \n][end]/[part1]\n/" -dumpall
         same as above but with dir parameters first. [25]
      #sfk xrep io.txt "/[lstart][20 chars]*/[part3]/"
         cut first 20 characters in every line of io.txt.
      #sfk xrep io.txt "/[lstart][9 bytes]1001*/[part2]9009[part4]/"
         in fixed position text file data like:
            rec. 001:5318 aef3 2751 1001
            rec. 002:1001 aef5 275a 1001
            rec. 003:ef49 aef7 2763 1001
         replace "1001" where it appears in columns 10 to 13,
         in this example only the first "1001" in record 2.
      #sfk xrep in.dat "/\xFF\xFE[1 byte]\x80\x81/\xFF\xFE\x00\x80\x81/"
         replace byte sequences (not ASCII text strings) in binary data.
         searches byte groups starting with values 0xFF 0xFE, then any
         single byte, then 0x80 0x81, and replaces the variable byte
         by always a binary 0x00 value.
    $SFK Base/XD and Extended Edition:
      #sfk xfind -text "/class [bytes]{[bytes]}/[all]\n\n/"
       #-dir mydir -file .hpp +tofile out.txt
         collect class definitions from mydir and write output
         indirectly (via command chaining) to out.txt [13]
      #sfk %s in.txt -text "/foo*bar/"
         search in.txt for patterns starting with foo and ending
         with bar, in the same line, with up to 4000 characters inbetween.
      #sfk xhex -text "/foo[0.100000 bytes]bar/" -dir mydir
         search all text and binary files of mydir for patterns of
         foo and bar with 0 to 100000 bytes (including NULL, CR
         and LF) inbetween and print output as hex dump.
      #sfk %s -text "/printf(**);/" -dir mydir -file .cpp
         find all printf statements in source code, including statements
         across multiple lines.
   $beware of Shell Command Characters.
      to find or replace text containing #spaces<def> or special characters like #<>|!&?*<def>
      you #must add quotes "" around parameters or the shell will #destroy your command<def>.
      it splits the command into parts and gives SFK only one part, causing errors.
      therefore #-replace _ _&nbsp;_<def> must be written like: #-replace "_ _&nbsp;_"
      within a $bash batch file the #dollar $$ must<def> be escaped like #\$$<def> even
      within quoted strings: #sfk echo -spat "dollar \$$ is a dollar \x24"<def>
   $beware of Shell Command Characters.
      to find or replace text patterns containing #spaces<def> or special
      characters like #<>|!&?*<def> you #must add quotes ""<def> around parameters
      or the shell environment will #destroy your command<def>. for example,
      pattern #/foo bar/other/<def> must be written like #"/foo bar/other/"
      within a $bash batch file the #dollar $$ must<def> be escaped like #\$$<def> even
      within quoted strings: #sfk echo -spat "dollar \$$ is a dollar \x24"<def>
      -arc%.*sXE: include content of .zip .jar .tar etc. archives
          %.*s    as deep as possible, including nested archives.
          %.*sXD: demo will read first 1000 bytes of each entry.
      -qarc%.*squick read top level archives but not nested ones.
dupfind
filefind
bintosrc
sleep
sample
script
partcopy
patch
pathfind
ftpserv
httpserv
filetrans
remcrlf
joinlines
filter
snapto
winshell
vmftp
md5list
clip
hexdump
charset
split
sincedir
alias
tcpdump
echo
runloop
hsel
hopt
hchain
hpat
deblank
tail
hextobin
fview
findclass
inst
reflist
deplist
netlog
copy
space
filetime
touch
media
license
index
iname
xtext
ftext
hexfind
xfind
xhexfind
extract
xrep
csvtotab
tabtocsv
rename
xmlform
addcrlf
sort
replace
   $web reference
      #http://stahlworks.com/sfk-%s
buffer overflow lrep.9
:@%06u 
buffer overflow lrep.1
buffer overflow lrep.2
line %d empty line not allowed within a command:
%.60s
check if the previous command was completed correctly.
line %d missing "%c" or blank at start:
tab character is not allowed, use space instead.
line %d: TAB character(s) are not allowed, use space instead:
line %d: separator "%c" must be placed at line start or end:
use a different separator character if '%c' should be searched.
line %d: wrong total number of "%c" separators:
a %cfromtext%ctotext%c pattern requires "%c" 3 times,
and search-only terms must end with %c[all]\n%c as totext.
if you have only search terms you may use -bylinelist
which allows one %cfromtext%c per line without any totext.
line %d: missing dot '.' at end of multi line command "%c.":
buffer overflow lrep.3
buffer overflow lrep.4
missing separator(s), use -showlist to see joined text: %s
$----- -bylist commands were joined to: -----
$----- -bylist was kept unchanged: -----
$-------------------------------------------
$Swiss File Knife is a program for the command line.<def>
It cannot be used by double clicking on the 'sfk' icon.
- create a simple folder with a short path
  that is easy to locate, for example
     /home/youruser/tools
- store sfk.exe into that folder
- open a shell (command prompt window)
- then type:
  cd /home/youruser/tools
  ./sfk
- then continue reading the help text shown.
  for example, typing
     ./sfk stat /
  will list folder tree sizes.
Press Enter to continue.
#:sfk-phrase-db:100:
# content is converted as:
# ,  -> random selection
# \, -> tab
# ;  -> ,
# \; -> ;
# \+ -> nothing
# \n -> linefeed
# $1sym -> remember a random index in slot 1
#          for later repeat as $1sym
$company: $namecom\,$stradr\,$city $statecode $zip
$person: $nameper\,$stradr\,$city $statecode $zip
$nameper: $name1 $name2
$name1: $preperm,$preperf
$preperm: Arthur,Alexander,Brian,Colin,Donald,Edward,Henry,
          Jack,James,Larry,Neil,Richard
$preperf: Alice,Brenda,Dora,Ellen,Grace,Helena,Ilona,Laura,
          Lena,Sandra,Susan
$name2: Smith,Jones,Harris,Young,Scott,Cole,Ellis,Porter,
          Anderson,Johnson,Peterson,Miller
$namecom: $comsyl1$comsyl2 $combra $comtype
$pvrfile: $nametv-$date-$timemin-$tvshow.mts
$tvshow:  $tvshow1,$tvshow2,$tvshow3
$tvshow1: The $nameper $tvwhat
$tvshow2: $nameper $tvwhat
$tvshow3: $newstype News
$newstype: Market,Technology,World
$tvwhat:  Show,News,Talk
$nametv:  $typetv$jointv$nameflat
$jointv:  $dig,_
$typetv:  Channel,Station,TV,News,Cable
$nameflat: $comsyl1$comsyl2
$comsyl1: Wel,Gen,Fram,Nap,Ken,Can,New,Al,Be,Dan,El
$comsyl2: ton,mond,dale,ney,kin,port,tree,way,nex,car,dyne
$cnsyl1: Che,Wo,Fi,Gu,Kan,Sel,Ben,Chong,Ching,Wing,Fon,Bun
$cnsyl2: che,wo,fi,gu,kan,sel,ben,chong,ching,wing,fon,bun
$combra: Machinery,Printing,Design,Furniture,Computers
$comtype: Inc,Ltd
$stradr: $num3 $namestr $strtype
$date: $year$month$day
$time: $hour$minsec$minsec
$timemin: $hour$minsec
$hour: 01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,16,17,18,19,20,21,22,23
$minsec: 01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,16,17,18,19,20,
         21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
         41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59
$year: 2011,2012,2013,2014
$month: 01,02,03,04,05,06,07,08,09,10,11
$day:  01,02,03,04,05,06,07,08,09,10,11,12,13,14,
       15,16,17,18,19,20,21,22,23,24,25,26,27,28
$num9: $dig1$dig$dig$dig$dig$dig$dig$dig$dig
$num8: $dig1$dig$dig$dig$dig$dig$dig$dig
$num7: $dig1$dig$dig$dig$dig$dig$dig
$num6: $dig1$dig$dig$dig$dig$dig
$num5: $dig1$dig$dig$dig$dig
$num4: $dig1$dig$dig$dig
$num3: $dig1$dig$dig
$dig1: 1,2,3,4,5,6,7,8,9
$dig: 0,1,2,3,4,5,6,7,8,9
$namestr: $comsyl1$comsyl2
$strtype: Dr,Rd
$zip: $num5
$city: London,Melville,Hertford,Denton,Framingham,Orlando,Irvine,
       Seattle,Toronto,Victoria,Portland,Wellington
$statecode: AL,MT,AK,NE,AZ,NV,AR,NH,CA,NJ,CO,NM,CT,NY,DE,NC,FL,
            ND,GA,OH,HI,OK,ID,OR,IL,PA,IN,RI,IA,SC,KS,SD,KY,TN,
            LA,TX,ME,UT,MD,VT,MA,VA,MI,WA,MN,WV,MS,WI,MO,WY
$char1: A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z
$country: USA,England,Australia,Canada,Argentina,Chile,China,
          France,Germany,Greece,Japan,Spain,Taiwan
$countrycode: US,EN,AU,CA,AR,CL,CN,
          FR,DE,GR,JP,ES,TW
$ip4: $ip4part.$ip4part.$ip4part.$ip4part
$ip4part: 1$dig$dig
$news: $1preperm $name2 created a new product; the $2verb $3sub with $social connectivity.\n
       It allows to $4get $images from all $5friend\+s around your $area live on $your $watch.\n
       "Everyone needs a $2verb $3sub"; $1preperm says; "it's the smart and social way to $4get $5friend\+s".
$verb: flying, rolling, jumping
$sub: watch, saucer, robot, rubber duck, camera
$get: keep track of, share, post
$images: images, sounds, videos
$your: your, a friends
$watch: watch, tv, smartphone, tablet
$friend: friend, dog, cat, squirrel, turtle
$area: area, house, couch, toilet, fridge
$social: facebook, twitter, google, tumblr, whats app
[101]sfk csvtotab in.csv +xed "/[start]*[eol]//" "/</&lt;/" "/>/&gt;/" +xex "_[lstart]*\t*\t*_<record>\n <id>[part2]</id>\n <name>[part4]</name>\n <city>[part6]</city>\n</record>\n_"
[102]sfk xed in.xml "/\q/\x27/" +xex "_<record>**<id>*</id>**<name>*</name>**<city>*</city>**</record>_" -showparts
[103]sfk xed in.xml "/\q/\x27/" +xex "_<record>**<id>*</id>**<name>*</name>**<city>*</city>**</record>_\q[part4]\q,\q[part8]\q,\q[part12]\q\n_/"
[104]sfk xed messages.txt "/+message*[eol]-de*[eol]=en*[eol]=it*[eol]/[parts 1-3]-en[parts 8,9]=de[parts 5,6,10-12]/" "/+message*[eol]-de*[eol]=it*[eol]=en*[eol]/[parts 1-3]-en[parts 11,12]=de[parts 5,6,7-9]/"
[105]sfk xex in.txt "/[1.100 white][2 chars of a-z][1.100 chars of ( \t\r\n)]/[part2],/"
[106]sfk csvtotab in.csv +xed "/*\t*\t*\t*\t*\t*/"
[107]sfk csvtotab in.csv +xed "/*\t*\t*\t*\t*\t*/[part9]\t[part11]\t[parts 1-3]/" +sort
SIGPIPE
SIGCONT
SIGWINCH
SIGTRAP
signal %u (%s) caught and ignored.
To get help, type the command without any parameter.
For example: "sfk", "sfk list", "sfk run".
SFK_CRASH_LOG
active-file-age:
skip-hour-jump
xdemo
memlimit:
tmpdir:
echoonstart
echoonerr
xchars
,xchars
noacc
,noacc
xmaxlen:
xmaxlen
,xmaxlen:
fixedbylist
,fixedbylist
dump-main-help
 (-verbose for more)
<time>%d utf-16 file(s) decoded%s.<def>
<time>%d utf-16 file(s) found. (see "sfk help utf")<def>
not 
<time>peak cache usage = %d mb. the memlimit was %sreached (%d drops).<def>
%d errors
, %d warnings
 occurred. 
add -exterr after sfk for more.
 occurred.
%d warnings occurred.
%d msec for cleanup
sfk rc: %d
using
many
every
only
within
from
into
command
calculate
calc
with
three
some
computer
example
specific
given
1bigger
1directory
3converting
4splitting
4comparison
2converter
4conversion
2colored
7tabulation
2sorted
search
determine
check
show
string
word
phrase
.bin
 binary
filename
generate
create
shortname
hexadecimal
coloured
colored
linefeed
cr-lf
execute
duplicated
duplicate
executable
colour
color
rejoin
join
subfolder
multiple
communication
connection
unix
linux
.exe
folder
director
tree
[eod]
[chain process index %d, "%s", cmd=%s, nparm=%d, "%s" uf=%d %d ud=%d %d cf %d cd %d]
chain.indata
dumphelp
<help>$sfk ask word1 [word2 word3 ...]
   search the help text of all sfk commands for lines containing
   all given words. keep your query short and up to the point,
   listing only the most important words.
   if your query produces no results, rephrase it:
   - use singular instead of plural: directory vs. directories,
     file vs. files
   - use synonyms: directory vs. folder, list file vs. find file,
     old file vs. most recent files
   $no option processing by default
      by default, "sfk ask" does NOT process any options itself,
      but treats them as text to search for. if you want to set any
      options although, say "sfk ask word1 word2 ... -opt -youropt"
   $no output chaining support
      output of sfk ask can NOT be post-processed in a command chain.
      instead, words starting with "+" are searched for as well:
         #sfk ask +filter
            searches for help text lines containing "+filter".
      if you really need to post-process output from sfk ask, pipe it
      to another sfk process like "sfk ask foo | sfk filter -+bar".
   $examples
      #sfk ask walk subfolders
      #sfk ask find oldest files
      #sfk ask replace binary
         search for the given words.
      #sfk ask -nocol
         search where the word "-nocol" appears.
      #sfk ask -nocol -opt -nocol
         the same, but also use -nocol to switch off color output.
<help>$sfk cmd commandnumber
   extract an example command from the help text
   and print it as one long text line.
   $options
     -run        execute the command
     -tofile x   write to an output file x
     -force      overwrite existing output file
-run
supply only a single command number
not a command number: %s
[%s]
list -zip -time -since 5d -size xdir .dat
list -late -since 2006-01-01_12:01:01 -dir xdir -file .dat
list -old -stat -since today .
list -big -withdirs -since 20060101 .
list -small -hidden -quot .
list -late=20 -pure .
list -late=all -notime -nosize
list -late -sincedir rdir xdir
list -sincedif rdir -relnames .
larc
late
<help>$sfk list [-time] [-size|-size=digits] [...] dir [mask]
$sfk sel[ect] -dir dir1 dir2 -file .ext1 .ext2 !.ext3 [...]
   list all or just selected files from a directory tree.
   select is the same, but it ignores command chaining input.
   $options
      -time      show date and modification time
      -flattime  show date and time in a more compact format
      -tab       separate columns by tab characters, not blanks
      -size[=n]  show size of files [n characters wide]
      -kbytes    or -kb lists sizes in kbytes instead of bytes
      -mbytes    or -gbytes lists sizes in mbytes or gbytes
      -kbpure    list without "kb" postfix
      -stat      show statistics (number of files, dirs, bytes)
      -nofollow  or -nofo does not follow symbolic directory links.
                 use this if list runs in an endless recursion.
      -withdirs  list also directories
      -justdirs  list just directories
      -verbose   list also non-regular files
      -showskip  tell whenever dir contents are skipped to avoid
                 double processing caused by symbolic links.
      -allowdups disable detection of duplicate dir contents.
      -arc       list contents of .zip .jar .ear etc. archives
                 and also .gz, .bz2, .tar, .tar.gz and .tar.bz2
                 as deep as possible, including nested archives.
                 type "sfk help opt" for supported file extensions.
      -qarc      quick list archives, lists only archive entries
                 at the top level, skipping nested archives.
      -sort[=n]  sort by name, list all or last n files
      -sortrev   sort by name, in reverse order
      -late[=n]  sort by time, list latest   [n] files last
      -old[=n]   sort by time, list oldest   [n] files last
      -big[=n]   sort by size, list biggest  [n] files last
      -small[=n] sort by size, list smallest [n] files last
      -minsize=s list only files >= size, like 10b or 100k
      -maxsize=s list only files <= size, like 10m or 4g
                 b=bytes k=kbytes m=megabytes g=gigabytes
      -late=all  sort by time, list all files
      -notime    don't list time, after -late or -old
      -nosize    don't list size, after -big  or -small
      -pure      pure list of filenames, leave out time, size,
                 headline or statistics.
      -quot      surround filenames by double quotes. needed when
                 post-processing filename lists containing blanks.
      -quiet     do not show the "scan" progress information
      -since     list only files since this timestamp, e.g.
                    "2006-01-31 12:15:59" or 20060131121559
                    2006-01-31 or 20060131
                    today : files changed since midnight of today
                    1d    : changed since 1 day, i.e. not counting
                            from midnight, but 24 hours into the past
                    5h, 30m, 10s : 5 hours, 30 minutes, 10 seconds.
      -before    select files modified before that timestamp.
      -today     short replacement for "-since today".
      -usectime  use or list creation time instead of modification time.
                 may not be available on some filesystems.
      -utc       or -gmt lists UTC/GMT time instead of local time.
      -sincedir  compare against another directory, list files that
       or -sd    have been added, have different time, or content.
                 does not list files which have been removed.
      -sinceadd  like -sincedir, list only added files.
      -sincedif  like -sincedir, list only changed files.
                 does not list files with diff. time but same content.
                 does not list added files.
      -sincechg  list files with different content, and added files.
       or -sc    does not list files with diff. time but same content.
      -relnames  list filenames relative to specified directory(s),
                 i.e. strip root directory names at the beginning.
      -tofile x  write all names directly to file x (using less memory
                 than the chain command +tofile x).
      -maxfiles=n      list a maximum of n files only.
      -fileoff[set]=n  from all selected files, list only a subset,
                 starting at index n. first file has index 0.
   $important details of file name / extension selection:
      - when specifying a filename pattern beginning with a dot "."
        and no wildcard, only files with this extension will be selected.
      - otherwise the pattern is searched anywhere within the filename.
        to force a filename start comparison, say <sla>pattern (with a slash).
      - filename means the relative filename, not directory or path name.
   $command chaining difference between list and select:
      +list accepts files from previous commands. +select ignores them,
      allowing scripts to run many independent selects in one chain.
   $no default archive content processing:
      .zip .jar .tar .tgz .bz2 archive contents are NOT listed by default,
      as this is not desirable if you just want a quick dir tree overview.
      specify -arc or -qarc to activate archive content listing.
      type "sfk help opt" to list all supported archive extensions.
   $aliases
      #sfk dir<def>          same as "sfk list -stat".
      #sfk select<def>       same as list, but ignoring chain input.
      #sfk larc<def>         same as "sfk list -arc".
      #sfk late<def>         same as "sfk list -late".
   $see also
      #sfk help select<def>  the sfk file selection syntax.
      #sfk help opt<def>     for further general options.
      #sfk stat<def>         to list directory tree sizes.
      #sfk filetime<def>     list all times of a file.
   $examples
      #sfk list .
         list all files of current directory and all subdirectories.
      #sfk list mydir <not>.bak <not>.tmp.txt
         list all files within mydir, except .bak and .tmp.txt files.
      #sfk list -dir . -file foo .htm .java\%c
         this will find and list the following sample filenames:
            thefoobar.dat     - matches anywhere-pattern "foo"
            biginfo.htm       - matches exact extension  ".htm"
            test.java.9.15    - matches anywhere-pattern ".java\%c"
         the command will NOT list the following sample filenames:
            foosys\thebar.dat - pattern must match filename, not path.
            biginfo.html      - does not match extension ".htm"
      #sfk list -dir mydir <not>tmp <not><sla>save<sla> -file .txt
         list all .txt files within mydir, excluding all sub folders
         having "tmp" in their name, or called exactly "save".
      #sfk alias list = sfk list -noop
         after this, just typing "list" lists the current directory.
      #sfk list -dir src1 -file .cpp -dir src2 -file .hpp
         list .cpp files from src1, .hpp files from src2.
      #sfk list -dir src "*examples*"
         list contents of all directories having a name with "examples",
         located somewhere below src. note that "*examples*" defines a
         path mask, whereas "examples" would be another root directory.
         under linux, patterns with a * wildcard MUST have quotes "".
      #sfk list -late -dir . -sub foo -file .jsp .java
         list the most recent .jsp and .java files, in all dirs below
         the current one (.) having "foo" in their pathname.
      #sfk list -late -dir . <wild>foo -file .jsp .java
         the same, only shorter to type.
      #sfk list -justdirs -dir . <wild>foo<wild> -file .jsp .java
         list all folders having "foo" in their pathname
         and which contain any .jsp or .java files.
      #sfk list -sincedir src5 src1 .cpp
         provided that directory src5 is an older copy of src1, list the
         .cpp files that have been added/changed since src5 was created.
      #sfk list -pure -late=30 -quot | zip ..\update.zip -@
         collect the latest 30 files from current dir into a zip file,
         using InfoZIP's option "-@" to use a filename list from stdin.
      #sfk sel src .bak +del
         select all .bak files in src, then delete them.
      #sfk list -nosub -late mydir +sleep 5000 +loop
         list most recent files of mydir every 5 seconds,
         excluding all sub folder contents.
      #sfk list . .jpg +count
         tell the number of .jpg files in current directory tree.
      #sfk list -nosub -flattime -tabs . .jpg +filter -stabform
       #"ren <run>qcol3 \q<run>col1<run>col2-<run>col3\q" +run "<run>text"
         rename all .jpg files in current folder to be prefixed by
         their modification time (type whole command in one line).
      #sfk larc src.zip +view
         show content listing of zip file src.zip in Depeche View,
         to search filenames interactively ("sfk view" for details).
      #sfk list <nofo>. >lslr
         list files of the current directory and all subdirectories into
         an index text file "lslr" (named after the unix command "ls -lR").
         doing this in a root directory may take some while, but afterwards
         you will find the location of every file in realtime, by simply
         typing "sfk find lslr your_filename_pattern".
      #sfk list <nofo>-qarc -tofile lslrx .
         same as above, but including hidden and system files, as well as
         the first content level of every .zip and .jar file. using -tofile
         instead of ">lslrx" redirection allows you to see a progress info.
         doing this in a root dir like C:\ may produce a filename listing
         of several hundred MB in size.
      #sfk list <nofo>-hidden -arc -tofile lslrxl .
         produce an ultimate file listing, including hidden and system files,
         .zip and .jar contents, .tar, tar.gz and tar.bz2 contents, as well
         as archive contents embedded within archives, like .class files
         embedded within .jar files within a .tar.bz2 archive. running this
         command in a root dir like C:\ may take some hours, and it may
         produce a 1 GB or more file listing, so make sure there is enough
         disk space.
List
-twinscan
-twinscan was replaced by sfk dupfind.
-size
-kbpure
-mbpure
-gbpure
-size=
-small
-small=
-big
-big=
-sort
-sort=
-sortr
-sortrev=
-nosize
-time
-flattime
-stat
-old
-old=
-late
-late=
small
-notime
-abs
-absolute
-tab
-nofile cannot be used here
use it on a following command, e.g. +filefilter -nofile
-fileoffset
-fileoff
wrong syntax: %s
use -fileoffset=n or -fileoff=n to set first file to process
-maxfiles
use -maxfiles=n to set max. number of files to process
 AND 
cannot sort by %s
%s got filenames from command chain AND as parameters
say "+select" instead of "+%s" to ignore chain input
%s requires dir- or filename parameters, chain input is ignored.
say "+list" instead of "+%s" to use chained input filenames.
%s requires dir- or filename parameters.
-tofile excludes any further chain processing.
cannot open for writing: %s
<file>[listing %d of %d files by size:]<def>
internal 141271931
internal 61212
internal 61213
<file>[listing %d of %d files by date:]<def>
internal 141271933
internal 61211
internal 61214
<file>[listing %d of %d files by name:]<def>
internal 141271934
internal 61220
internal 61221
%d files, %d dirs, %s %s, %s bytes
%d files, %d dirs, %s bytes
%d hidden files, %d dirs.
skipped %d hidden files, %d hidden dirs.
skipped %d added files. 
most recent file is %s hours old.
most recent file is %s days old.
found %d matching and %d missing reference dirs (try -incref or -verbose)
%u non-regular files skipped.
chaining stops before %s, rc=%d
gindex
gindex2
lindex
<help>$sfk gindex[2] [opts] -dir rootDir [rootDir2] ...
<help>$sfk lindex [opts] -dir localDir ...
   create index file(s) containing file names with time
   and size info, for later realtime filename lookup,
   or just to archive folder meta data.
   $creating index files for use with sfk iname<def>
    to create a $local index of the current directory tree<def>, use
      #sfk lindex .
         which writes a local file $zz-index.txt<def>
    to create a $global index of the current machine<def>, use
      #sfk gindex -dir C:\ D:\
         which stores a base index file in your user folder:
         %s<sla>data<sla>zz-index.txt
    to create an $extended global index<def> of network drives, use
      #sfk gindex2 -dir T:\ P:\ V:\
         if drives T, P, V are network drives. this will write
         an extended index file in a user local folder:
         %s<sla>data<sla>zz-index-ext.txt
    in other words:
      $sfk lindex<def> writes an index locally onto the disk
         where you are standing, $visible for all users<def>.
         this is useful 1. under linux in the root dir "/"
         to make an index of all files available for all users
         2. on external media like USB hard drives, where an
         index in the drive root can be used on any machine.
      $sfk gindex<def> is your $personal global index<def> of whatever
         disk contents are important for you, $not for use<def>
         $by other users<def>, and maintained only by yourself.
   $creating special purpose meta data archives<def>
    to create a $local index of a sub folder "mydir"<def>, use
      #sfk lindex mydir
         which writes a file $zz-index-mydir.txt<def>. this file
         can $NOT<def> be used with $sfk iname<def>. it's just an archive
         of file meta informations for that sub folder.
   $using indexes for fast name lookup
       #sfk iname word [word2] [word3] [...]
         will use local index files:
            - in the current folder
            - in the parent folder
            - and so on, until the root folder "<sla>"
            - and also the global Base Index file
         and then lists all file names from those indexes
         having the given words in their name or path.
       #sfk iname2 word [word2] [word3] [...]
         does the same as iname, but also includes
         the global Extended Index file.
   $sfk index options
      -tofile f  write output into a file f instead of the
                 default index file. can be used then with
                 "sfk iname -from f ..."
      -follow    follows symbolic directory links. this is
                 no default as it may cause endless recursion.
      -verbose   show names of skipped non-regular files
      -showskip  tell whenever dir contents are skipped to avoid
                 double processing caused by symbolic links.
      -allowdups disable detection of duplicate dir contents.
      -arc       include contents of .zip .jar .ear etc. archives
                 and also .gz, .bz2, .tar, .tar.gz and .tar.bz2
                 as deep as possible, including nested archives.
                 type "sfk help opt" for supported file extensions.
      -qarc      quick list archives, lists only archive entries
                 at the top level, skipping nested archives.
   $see also
      #sfk iname<def>       lookup files in local and Base Indexes
      #sfk iname2<def>      lookup in local, Base and Extended Index
      #sfk help select<def> the sfk file selection syntax.
      #sfk help opt<def>    for further general options.
      #sfk dir<def>         list contents of a directory.
   $examples
      #sfk gindex /
          create a base index containing all file names
          from the machine.
      #sfk gindex -dir / -subdir :tmp -file :.bak
          create an index of / without any sub dirs
          having tmp in their name, and without .bak files.
      #sfk lindex .
          if standing in the root dir of an exernal hard drive,
          this will write a local index file for that drive,
          which can later be used on another machine by typing
          $sfk iname<def> while working on that drive.
-ext
-follow
data%czz-index%s.txt
missing -dir parameter
zz-index.txt
cannot lindex nested directory names.
use only plain dir names of the current folder.
zz-index-%s.txt
$making<def> %s
cannot open index file for writing: %s
date	time	size	name	sfk-index-v100
%d files indexed
including %d hidden files.
%u non-regular files skipped. (add -verbose to show)
md5gento x.dat xdir
md5gento=x.dat -quiet xdir
md5gento x.dat -rel -dir xdir
list xdir +md5gento xfile.md5
md5gento
<help>$sfk md5gento[=]outputfile [-rel[names]]]] dirname [-quiet]
   create list of md5 checksums over all selected files.
   $options
      -rel    create a list with relative filenames, i.e. strip
              the supplied dirname from the beginning of each name.
      -quiet  do not print progress output while reading files.
   $see also
      #sfk md5check<def>  to verify md5 lists.
      #sfk md5<def>       create md5 of a single file.
   $examples
      #sfk md5gento mydir.md5 mydir
         create checksum of all files in folder mydir and all
         sub folders and store them in mydir.md5.
      #sfk select -dir prod -file !.tmp +md5gento=checksums.md5
         first select all files from prod, excluding .tmp files,
         then create an md5 list to checksums.md5
missing output filename
md5gento with -(q)arc requires SFK XE.
cannot write %s
%u files hashed into %s. %u kb/sec
md5check x.dat
md5check=x.dat -quiet -skip=2
md5check x.dat -rel xdir -skip 10
md5check
<help>$sfk md5check[=]inputfile [-rel[ativeto]] dirname] [-quiet]
   verify a list of md5 checksums.
   $options
      -rel     if dirname is supplied, treat filenames from list
               as being relative to dirname. in this case, run the
               command from dirname's parent directory.
      -quiet   do not print progress output while checking files,
               and do not list kb/sec speed stats.
      -skip=n  do not check all files, perform just spot checking
               by skipping n files after every checked file.
   $return codes for batch files
      0   normal execution, all checksums matched.
      1   normal execution, checksum(s) mismatched.
      2   some files were missing, all other checksums matched.
      3   some files were missing, and some checksums mismatched.
    >=9   severe error occurred, e.g. wrong checksum file format.
   $see also
      #sfk md5gento<def>  to create md5 lists.
      #sfk md5<def>       create md5 of a single file.
   $examples
      #sfk md5check mydir.md5
         check if files listed in mydir.md5 still have
         the same checksums.
missing dirname after -rel
-skip
unexpected parameter: "%s" (2)
missing input filename
md5 xfile1
md5 -quiet -verify bfb9acc99d1811730687f49a09318e8f xfile1
<help>$sfk md5 [-quiet] [-verify md5sum] file1 [file2 file3 ...]
   calculate md5 hash of one or more files, and optionally compare the results.
   if md5 sums are compared, a message is shown, and the shell return code
   is set to 0 (all equal), or 1 (not equal), or >1 (any other error).
   $options
      -nonames   do not echo filename(s), show only the md5 sum.
      -verify    or -ver, or -v verifies the given filename(s) against
                 the given checksum.
      -nocomp    if multiple filenames are given, do not compare.
   $examples
      #sfk md5 test01.dat
         tell md5 sum of test01.dat
      #sfk md5 test01.dat test02.dat
         compare both files, if content is the same.
      #sfk md5 -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat
         check if test01.dat has an md5 matching the one specified.
-ver
-nocomp
supply filename(s) for reading
%s	%s
%s	%s
rc1 mismatch
rc0 equal
content mismatch (RC==1)
content is equal (RC==0)
done in %d msec
makepw
randhex
%02x%02x%02x%02x
Copyright (c) 2015 by Stahlworks Technologies, www.stahlworks.com.
All rights reserved.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
testchar
wname: %s
vname: %s
test
<help>$sfk test mode dbfile tctitle infile
   record/compare automated test results on a database.
      mode:
         rec   record checksum of infile
         upd   record only if not yet contained in db
         cmp   compare checksum against db entry
      dbfile : a database file, created by sfk in mode -rec
      tctitle: name of the testcase, e.g. T01.1.mytest
      infile : an output file resulting from a testcase
   the sequence of text lines within the infile is ignored.
   this may lead to a checksum of "0000" if the input file
   contains the same content twice.
   $examples
      #sfk test rec mycrc.db T01.1.encoding out1.dat
      -> creates checksum of out1.dat, writes to mycrc.db
         under the title T01.1.encoding
      #sfk test cmp mycrc.db T01.1.encoding out1.dat
      -> creates checksum of out1.dat, reads 2nd checksum
         from mycrc.db, and compares both.
workdir
"%s" != "%s"
missing arguments. type "sfk test" for help.
:REC : %s%.*s %s
:ADD : %s%.*s %s
no such entry: %s
: OK : %s
:FAIL: %s   - mismatch of %s
unknown test mode: %s
proctest
<help>$sfk proctest script.txt [testid] [ff]
   test text processing by running testcases
   from a script. per testcase,
   - an input file tmpin.txt is written
   - another file tmpout.txt is written
     with same content as tmpin.txt,
     to allow direct replace in tmpout.txt
   - a command from the script is executed
   - output file tmpout.txt is compared
     against the output template data in the script.
   $script syntax
      :test name of test case 1
      :from
      ... [any text data] ...
      :command
      ... [single line command] ...
      :to
      ... [any text data] ...
      :done
      :test name of test case 2
      ...
   $script example
      :test 01 replace foo
      :from
      the foo and the bar
      :command
      sfk rep tmpout.txt -text "/foo/bar/" -yes
      :to
      the bar and the bar
      :done
   $parameters
      testid    run only single test case
      ff        run all cases starting from testid
   $options
      -quiet    redirect terminal output to >nul
      -cmd=x    replace $cmd at line starts by x
   $examples
      #sfk proctest myscript.txt
         runs script myscript.txt
-cmd
unexpected parameter: %s
missing script filename
cannot load script
:done
:test 
missing :test
:from
missing :from after :test
:command
missing :command after :from
missing :to after :command
:done
missing :test or :done after :to
#TEST: ===== %s =====
FROM: %s
tmpin.txt
tmpout.txt
$cmd 
missing -cmd for $cmd entries in test script
%s %s
CMD : %s
%s >nul 2>&1
NEED: %s
tmpneed.txt
missing output file tmpout.txt
GOT : %s
... output differs (fuzzy).
  ... see tmpneed.txt and tmpout.txt
$sfk snapto=outfile [-pure] [-nosub] -dir mydir1 -file .ext1 .ext2
   Collect many text files into one large text file, specifying
   what sub folders and file (extensions) to include or exclude.
   The resulting file can be loaded directly by Depeche View,
   allowing interactive search and filtering of the content.
   $options
      -fileset x  instead of specifying long lists of -dir / -file
                  statements on the command line, you may write them
                  all into a text file, then use that. for more infos,
                  type "sfk help fileset".
      -allbin     include binary files as text extract (not default).
      -pure       don't insert filenames.
      -prefix=x   insert x before every file.
      -nometa     by default, sfk adds the file system's time and size
                  info to each :file: header. can be disabled here.
                  note that size= may not reflect the actual bytes used
                  within the snapfile, due to line ending conversions.
      -raw        collect faster by adding text file content as is,
                  without CRLF conversions, but still replacing any
                  null or EOF bytes. skips binary files completely.
      -nosub      or -norec does not include subdirectories (subfolders).
      -wrap[=n]   auto-wrap long lines [near column n], e.g. -wrap=80.
      -stat       show time stats at end.
   $see also
      #sfk view<def>    a GUI tool that can load and view sfk snap files
                  directly and search them at high speed.
      #sfk getdv<def>   instant download of Depeche View Lite (portable,
                  no installation) to browse snap file contents.
   $examples
      #sfk snapto=all-src.cpp . .cpp .hpp .dll <not>tmp
         includes .cpp, .hpp and even .dll text extracts, excludes all
         files with "tmp" in their name, e.g. tmp10.cpp
      #sfk snapto=all-src.cpp -dir src2 <not>src2<sla>old -file -all .doc
         includes all text files, and .doc binary extracts.
      #sfk snapto=all-src.cpp -fileset zz-myset.txt
         includes whatever dirs and files are specified in the
         fileset definition "zz-myset.txt" (sfk help fileset).
      #sfk select src5 .txt .exe +snapto=all.txt
         filenames provided by command chaining are always included,
         no matter if binary or not. in this case, extracts from .exe
         binary files are also placed into the output.
      #sfk select -text mydir <not>.bak +snapto=all.txt
         select all text files from mydir, excluding .bak files.
snapto=xfile.txt xdir .cpp .hpp -wrap
snapto=xfile.txt -pure -prefix=foo -dir xdir1 xdir2 -file .cpp
list xdir +snapto=xfile.txt
snapto=
-prefix=
prefix too long, only up to 40 characters are allowed.
-nometa
-raw
-rawest
raw,
:snapfile sfk,1.1,%slprefix=%s
,wrap=%u
msec
%u files collected into %s, %d lines, %u %s, %u %s, %u %s/sec
%u files collected into %s, %d lines, %u %s
text-join-lines xinfile xoutfile
text-join-lines
<help>$sfk joinlines infile outfile
   join text lines from text split by email reformatting.
missing arguments
%s does not support chaining (%s).
scantab2
%d files of %d contain tabs.
scantab -dir xsrc1 xsrc2 -file .cpp .hpp .txt
scantab -quiet -pure . .cpp .hpp
list xdir .txt +scantab
scantab
<help>$sfk scantab [-quiet] dir [mask] [-pure]
   list files containing tabs.
   $options
      -quiet   do not list filenames, show only statistics.
      -pure    list only filenames, but no statistics.
   $return codes for batch files
      0 = no tabs, 1 = tabs found, >1 = error occurred.
-indsel
-ind
%d files of %d contain tabs.
 %d files have indent %d
, %d/%d
, %d/unknown
detab=3 xfile
detab=3 xsrc .cpp .hpp
list xdir .txt +detab=3
detab=
<help>$sfk detab=tabsize dir ext1 [ext2 ...] [-to outmask]
   replace tabs by spaces within file(s) or text stream.
   $options
      -to outmask   do not overwrite original files, but write
                    to output files according to outmask, e.g.
                    #-to tmp<sla><run>path<sla><run>base.<run>ext<def> or #-to tmp<sla><run>file
      -yes          if files are selected, really (re)write them.
                    without -yes, detab is only simulated.
      -memlimit=n   process files with up to n mbytes (default=300).
      -nowarn       do not tell about skipped or unreadable files.
   $see also
      #sfk scantab<def>   list files containing TAB characters.
      #sfk help opt<def>  how to change the memlimit permanently.
   $examples
      #sfk detab=3 sources .cpp .hpp
         replace tabs by up to 3 blanks, within all .cpp and .hpp
         files of directory tree "sources".
      #sfk select -dir src -file .java +detab=4 -to tmp<sla><run>file
         list all .java files of src, then detab with tabsize 4,
         writing all outputs to directory tree "tmp".
      #sfk detab=4 src .java -relnames -to tmp<sla><run>file
         nearly the same, however stripping the "src" input directory
         name from output file paths (not possible with "+detab" form).
      #sfk filter mytext.txt +detab=8
         detab content of a single file to the console.
invalid tab size
%d files checked, %d %sdetabbed, %d tabs in total.
use -memlimit=1000 to process larger files.
rmtree
<help>$sfk delete dir ext1 [ext2 ...] [-yes]
$sfk deltree targetdir [-yes]
$sfk del -dir dir1 dir2 -file .ext1
   delete files or dirs, even if they're write protected.
   deltree or rmtree deletes a directory tree with all contents.
   $options
      -yes         really delete the files. without option -yes,
                   del only lists the files that would be deleted.
      -withdirs    if you supply a file mask other than "<wild>",
      or -wdir     and file deletion leads to an empty directory,
                   then the directory is removed as well. if you
                   supply no file mask (or "<wild>"), then every
                   empty directory is always deleted. this option
                   cannot be used with chaining, as chaining passes
                   only filenames, but no processed directory names.
   $lazy confirmation on command chaining
      if you selected files in a command chain, then want to add +del
      you may type "+del." (with a dot) or "+del!" (windows only)
      instead of "+del -yes" to actually delete the files.
   $examples
      #sfk del -withdirs src .bak
         deletes .bak files within src and all subdirs.
         if a directory contained only .bak files,
         it is deleted as well.
      #sfk del -yes -withdirs -hidden tmp
         delete tmp with all files, including hidden files.
      #sfk deltree. tmp
         the same as above, with "." as a short for -yes.
      #sfk list -dir src -file foo*.hpp +del
         first list target files, then add +del
deltree
deltree.
deltree!
rmtree.
rmtree!
del.
del!
%d files, %d dirs %sdeleted. 
%d files %sdeleted. 
including 
<time>including %d readonly files<def>
<time>%s%d readonly dirs<def>
$[say -yes or %s. to execute.]
entab=3 xfile
list xdir .java +entab=4
entab=
<help>$sfk entab=tabsize dir ext1 [ext2 ...]
   replace groups of spaces by tabs within file(s).
   $options
      -to outmask   do not overwrite original files, but write
                    to output files according to outmask, e.g.
                    #-to tmp<sla><run>path<sla><run>base.<run>ext<def> or #-to tmp<sla><run>file
      -yes          if files are selected, really (re)write them.
                    without -yes, entab is only simulated.
      -memlimit=n   process files with up to n mbytes (default=300).
      -nowarn       do not tell about skipped or unreadable files.
   $see also
      #sfk scantab<def>   list files containing TAB characters.
      #sfk help opt<def>  how to change the memlimit permanently.
   $examples
      #sfk entab=3 sources .cpp .hpp
         replace 3 spaces each by a TAB character in all .cpp
         and .hpp files within folder sources.
      #sfk entab=3 singleFileName.txt
         the same, but only in a single file.
entab does not support chain text input.
%d files checked, %d %sentabbed, %d tabs in total.
addcr xfile
lf-to-crlf xsrc .cpp .hpp
list xdir .txt +addcr
list -dir xdir1 xdir2 -file .cpp .hpp +lf-to-crlf
lf-to-crlf
addcr
listle
<help>$sfk lf-to-crlf [options] dir .ext1 .ext2 [-to outmask]
   convert just-lf (unix) text format to cr+lf (dos/windows).
   if only a single filename, or list of filenames, is given
   then these are converted immediately.
   if a directory parameter is given then the command runs
   in simulation mode, requiring option -yes to convert.
   $options
      -forceend    if a file is changed and rewritten then
                   also add a line ending at the last line
                   even if there was none in the input file.
      -writeall    rewrite all files no matter if changed
   $aliases
      #sfk addcr<def>    same as sfk lf-to-crlf
   $examples
      #sfk addcr src .cpp .hpp
         add crlf on all .cpp and .hpp files within src.
      #sfk select -dir doc -file .txt +addcr -to tmp<sla><run>file
         add crlf on all .txt files within doc, saving to tmp.
-forceend
$%d files with CR/LF, %d with LF, %d unterminated, %d with CR.<def>
%d files %sconverted.
remcr xfile
crlf-to-lf xsrc .cpp .hpp
list xdir .txt +remcr
list -dir xdir1 xdir2 -file .cpp .hpp +crlf-to-lf
crlf-to-lf
remcr
<help>$sfk crlf-to-lf [options] dir .ext1 .ext2 [-to outmask]
   convert cr+lf (dos/windows) text format to just-lf (unix).
   if only a single filename, or list of filenames, is given
   then these are converted immediately.
   if a directory parameter is given then the command runs
   in simulation mode, requiring option -yes to convert.
   $options
      -forceend    if a file is changed and rewritten then
                   also add a line ending at the last line
                   even if there was none in the input file.
      -writeall    rewrite all files no matter if changed
   $aliases
      #sfk remcr<def>    same as sfk crlf-to-lf
   $examples
      #sfk remcr src .cpp .hpp
         reduce crlf to lf on all .cpp and .hpp files within src.
      #sfk select -dir doc -file .txt +remcr -to tmp<sla><run>file
         change crlf on all .txt files within doc, saving to tmp.
stat -minsize=10 .
stat -quiet -i
treesize
<help>$sfk stat [-minsize=n] dir [-i]
$sfk treesize[mb] dir
   show directory tree size statistics in mbytes.
   $options
      -minsize=n   list only dirs and files with a size larger
                   or equal to this, e.g. 100 = 100 bytes,
                   10k = 10 kbytes, 10m = 10 megabytes.
      -i           read list of directories from stdin.
      -nosum       print no summary at end of listing.
      -sum         print only the summary.
      -kbytes      list all sizes in kbytes.
      -bytes       list all sizes in bytes.
      -flat        show the no. of files and bytes per folder
                   without its subfolders (do not accumulate).
   $aliases
      #sfk stat10<def>       does the same as #sfk stat -minsize=10m<def>
      #sfk treesize100<def>  does the same as #sfk stat -minsize=100m<def>
   $limitations
      this command cannot summarize zip file contents.
   $examples
      #sfk stat . -minsize=10m
          list sizes of all directories below the current one
          having a size of at least 10 mbytes.
      #sfk stat50 docs
          list all directories and single files under the docs
          directory tree having a size of >= 50 mbytes.
      #type dirlist.txt | sfk stat -quiet -i
          list sizes of dirs listed in dirlist.txt
supply a number after stat, like stat10.
-minsize
-byte
-flat
-nosum
-sum
%s, %5d files, %d dirs, %s bytes.
%s kb, %5d files, %d dirs, %s bytes.
%5d mb, %5d files, %d dirs, %s bytes.
find -norec -text -lnum -nocol xdir xpat1 xpat2
grep -c -names -quiet -pat xpat1 -dir xdir1 xdir2 -file .dat
list xdir +find mypat
list xdir +find -pat mypat
<help>$sfk ftext [opts] singledir word [word2] [word3] ... [-names]
   case-insensitive text search for text files only.
<help>$sfk find [opts] singledir word [word2] [word3] ... [-names]
   case-insensitive text search for text and binary files.
   if multiple words are given then only areas containing
   all words are listed. sfk find tries to autodetect if a file
   is text or binary, adapting the output text formatting.
   $options
      -bin       do not autodetect file content, process all as binary.
                 can also be used for floating text files (one linefeed per
                 paragraph, not per line). may produce unwanted line breaks
                 with short-lined text.
      -len=n     increase the line length for text extracted from binary
                 to find longer strings. maximum is 600 approx.
      -wide      same as -len=300
      -delim=.,; set delimiters to enable soft word wrapping.
                 default is to soft wrap only on white space.
      -c         case-sensitive search (not default).
      -lnum      list line numbers of hits.
      -nocol     disable color highlighting of output (sfk help colors).
      -names     list only names of files containing at least one hit.
      -count     list no. of matching lines per file. implies -names.
                 requires -text option, cannot be used with binary files.
      -quiet     do not show "scan" progress info.
      -pure      do not list filenames, list only text hits without indent.
                 default when specifying a single file as first parameter.
      -verbose   tells in detail what find is actually searching for.
      -firsthit  show only first matching result per file.
      -justrc    print nothing to terminal, just set return code.
   $search limitations within binary data
      by default, only lines up to 80 characters are extracted
      from binary data, so strings longer than this may not be found.
      this can be changed by option -len=n or -wide.
   $pattern support
      no wildcards or slash patterns are supported, with one exception:
      if you need to find patterns starting with "-" or "+", prefix
      them with backslash \ to avoid misinterpretation as options.
   $return codes for batch files
      0 = no matches, 1 = matches found, >1 = major error occurred.
      see also "sfk help opt" on how to influence error processing.
   $aliases
      #sfk ftext<def>    same as sfk find but reads only text files.
   $examples
      #sfk find . foo bar include
         search all files in current dir for the words foo+bar+include.
         note that the short form syntax supports one directory name,
         and any number of text patterns, but no file name patterns.
      #sfk find -pat text1 text2 -dir src1 src2 -file .cpp .hpp
         searches within the specified directories and file masks.
      #sfk find -wide -pat http:// .html -dir mydir -file .dat
       #+filter -rep "_*http://_http://_" -rep "_.html*_.html_"
         find all http://*.hml references in binary .dat files,
         using -wide to find links beyond 80 characters,
         then reduce the output to just the link text.
      #sfk list src +find -verbose \-pat \\-foo \+list
         find lines containing words "-pat", "\-foo" and "+list"
         in all files of directory src, with verbose search infos.
-delim
-len
-length
specify 80 or higher for -len
-rtrim=
-wide
-nojoin
-count cannot be used only with text file search
say -text -count instead of -count
-to is not supported with find.
you may try xfind instead.
-tofile is not supported with find.
you may use +tofile or try xfind.
no such file or dir: %s
to search for this word, say \%s
please specify a directory or file name.
[searching lines with
 "%s"
 AND "%s"
no search patterns specified.
home
<help>$sfk home
   tells the location of the SFK Home folder
   for configuration and data storage.
gname
lname
<help>$sfk iname[2] word [word2] [<not>exclude] [.ext]
   find filenames as fast as possible by using
   index files created by $sfk lindex<def> or $gindex<def>.
   $sfk iname word [word2] [word3] [...]
     will use local index files $zz-index.txt
        - in the current folder
        - in the parent folder
        - and so on, until the root folder "<sla>"
     and also the global Base Index file from
     %s
     and then lists all file names from those indexes
     having the given words in their name or path.
   $sfk iname2 word [word2] [word3] [...]
     does the same as iname, but also includes
     the global Extended Index file.
   $sfk gname<def> uses only the global index.
   $sfk lname<def> uses only local index files.
   $pattern syntax
    - just type up to 10 words that must be contained
      somehere in the file name or it's path. the words
      are AND combined. the sequence is ignored.
    - words starting with <not> will exclude any file
      having the word in it's name.
    - words starting with "." are a file extension and
      must appear only at the END of a file name, or be
      followed in the filename by another "."
      like ".so" in foobar.so.1.2.3
   $options
      -size     include size info in result
      -size=n   pad size info to n characters
      -tab      create tab separated output
   $output sorting
      output is always sorted by $file modification time<def>,
      listing the $most recent files<def> at the list bottom.
   $chaining support
      output chaining is supported.
   $aliases
      #sfk x<def>  is the same as $sfk iname<def>
      #sfk x2<def> is the same as $sfk iname2<def>
   $see also
      #sfk gindex<def>   - create global index file(s)
      #sfk lindex<def>   - create local  index file(s)
   $examples
      #sfk iname .pdf
         lists all PDF files in the Base Index.
      #sfk iname part 2391 datasheet .pdf
         lists all PDF files in the Base Index having
         the words "part", "2391" and "datasheet"
         somewhere in their name, for example:
            C:\documentation\datasheets\parts\2391.pdf
            C:\server2391beta\subparts\datasheet.pdf
      #sfk iname2 part 2391 datasheet .pdf
         the same, but may list further results also
         from the extended index, for example:
            Z:\public\docs\part-2391\datasheet-03.pdf.old
      #sfk iname .hpp +find class tree
         search all .hpp header files from the index
         for the words "class" and "tree".
      #sfk iname tree .hpp +fview
         load and view all .hpp files having "tree"
         in their name or path. ("sfk view" for more)
name2
-from
too many %c exclusion patterns
too many file types
too many patterns
missing parameters for x
cannot get work dir.
%s%szz-index%s.txt
data%szz-index%s.txt
[nopre] noidx: %s
[nopre] using: %s
:sfk-internal-memory-end-marker:
index data check failed, files may contain zero bytes.
missing tab format in index file(s)
internal #213731
overflow.1
overflow.2
overflow.3
overflow.4
index file has wrong format (not tab separated).
output overflow while processing: %s
output overflow 2 while processing: %s
Found %d hits. (%d msec)
bin-to-src
$sfk bin-to-src [...] infile outfile namePrefix
   create sourcefile containing a binary data block. the outfile
   will contain variable definitions beginning with namePrefix.
   $options
      -java       create java source code output, default is C.
      -class      java: create a fully compilable class with a short
                  demo source code how to write the data to a file.
      -pack       C source: compress data with a simple RLE scheme.
      -hex        C source: produce hex numbers instead of decimal.
      -append     do not overwrite output, but append to it.
      -recsize=n  java: define number of bytes per record used
                  within the raw data. default is 500. higher values
                  produce less records, which may help if you get
                  a "code too large" error during java compile.
   $examples
      #sfk bin-to-src myimg.dat imgsrc.cpp img01
         create C source code containing content from myimg.dat.
      #sfk bin-to-src -java -class myimg.dat imgdata.java imgdata
         create a Java class "imgdata" with myimg.dat content.
-recsize
-pack
-hex
-java
-class
-append
missing parameters for bin-to-src
filter -no-empty-lines -count -lnum -case ++mypat
filter -no-blank-lines
filter -cnt -c -+mypat2 -+mypat3 -rep _foo_bar_
filter -+foo -+:bar -ls+start -le+end -ls:nstart -le:nend
filter -sep " " -form "#40col1_#-50col2" -join
filter -sep ; -form "#col3_#col5" -wrap
filter x.txt -blocksep _ -form #col1 -wrap=80
filt
ffilt
filefilt
<help>$sfk filter [fileOrDir] -selectoption(s) -processoption(s)
$sfk filt -selectoption(s) -processoption(s) -dir mydir -file .ext1 .ext2
$sfk filter [-memlimit=n] -write inoutfile -replacepattern(s)
   filter and change text lines, from standard input, or from file(s).
   input lines may have a maximum length of %u characters.
   $line selection options
      -+pat1 -+pat2 [...]   include lines containing pat1 OR  pat2
      ++pat1 ++pat2 [...]   include lines containing pat1 AND pat2
      -ls+pat1              include lines starting with pat1
      -le+pat1 -le+pat2     include lines ending   with pat1 OR pat2
      -<not>pat1 -<not>pat2         exclude lines containing pat1 OR  pat2
      -ls<not>pat1              exclude lines starting with pat1
      -le<not>pat1 -le<not>pat2     exclude lines ending with pat1 or pat2
      -no-empty-lines       exclude empty lines
      -no-blank-lines       exclude lines containing just whitespaces
      -inc[lude] p1 to p2   include only lines within blocks surrounded by
                            boundary lines containing patterns p1 or p2
      -inc-      p1 to p2   same, but exclude boundary lines on output
      -cut[-]    p1 to p2   remove block of lines from p1 until p2
      -inc[-]    "*" to p1  include all from text start until marker
      -cut[-]    p1 to "*"  cut all from marker line until end of text
      -nocheck              with inc, cut: ignore endings without a start
      -addmark txt          with inc, cut: insert txt after every block
      -context=n            select n lines of context around hit lines
      -precon=5:blue        select context before or after hit lines,
      -postcon=5:cyan:---   in blue or cyan, with separator "---".
      -unique [-case]       if same line occurs twice, keep only first.
                            default is case insensitive text comparison.
      -global-unique        when filtering multiple files in one command,
         then -unique applies to lines in the same file, and -global-unique
         applies across all files. this will cache the text of all files in
         memory and may not be used with very large files.
      -keep pattern         after -unique: make an exception for lines
         containing the given pattern, and keep them even if redundant.
      -keep-empty, -keep-blank always keep empty or whitespace lines.
   $text processing options
      applied <err>after<def> line selection options only.
      -rep[lace] _src_dest_
         replace string src by dest. first character is separator character (e.g. _).
         src is case-insensitive. to select case-sensitive search, say -case.
      -lsrep[lace], -lerep[lace]
         same as -replace, but replaces only once at line start or line end.
      -high[light] color pattern : highlight matching parts within lines.
         color   : red = dark red, Red = bright red, green, blue,
                   yellow, cyan, magenta, default.
         pattern : e.g. "GET * HTTP/"
         type "sfk help colors" for more about colors.
      -lshigh[light], -lehigh[light]
         same as -highlight, but only at line start or line end.
      -sep[arate] "; " -form "<run>col1 mytext <run>[-0n.nq]col2 ..."
         break every line into columns separated by any character listed after -sep,
         then reformat the text according to a user-defined mask similar to printf.
         when leaving out -sep, the whole line is packed into column 1. if -spat was
         specified, then -form also supports slash patterns like \t.
         google for "printf syntax" to get more details. example:
      -form "<run>40col1 <run>-3.5col2 <run>05qline <run>(10.10qcount+1000)"
         reformat column 1 as right-ordered with at least 40 chars, column 2 left-
         ordered with at least 3 and a maximum of 5 chars, then add the input line
         number, "q"uoted, right justified with 5 digits, prefixed by zeros,
         then the output line number plus 1000 within quotes. NOTE: some examples
         may not work in an sfk script, see section "common errors" below.
         adding values so far only works with (q)line and (q)count.
      -tabform "<run>col1 mytext ..."
         split and reformat columns of tab separated csv data.
      -trim  removes blanks and tab characters at line start and end.
             use -ltrim or -rtrim to trim line start or end only.
      -blocksep " " = treat blocks of whitespace as single whitespace separator.
      -join[lines] join output lines, do not print linefeeds.
      -wrap[=n]    wrap output lines near console width [or at column n].
                   set SFK_CONFIG=columns:n to define or override the console width.
      -toiso[=c]   or just -iso converts UTF-8 text to ISO-8859-1. some chars beyond
                   the 8 bit code range will be reduced to something similar, but
                   most of them are changed to a dot '.', or character c.
      -toutf       converts ISO-8859-1 text to UTF-8. if this is done with UTF-8
                   input text then existing UTF-8 sequences will be destroyed!
   $conditional text processing
      -[ls/le]where pattern -replace | -highlight | -sep ... -form
          replace, highlight or reformat lines matching the given pattern.
          all lines that do not match the pattern stay unchanged.
      -within pattern -replace _from_to_
          replace text in a part of the line matching the given pattern.
          the rest of the line text stays unchanged.
   $pattern support
      wildcards * and ? are active by default. add -lit[eral] to disable.
      slash patterns are NOT active by default. add -spat to use \t \q etc.
      if you need the wildcard * but ALSO want to find/replace '*' characters:
      add -spat, then specify \\* or \? to find/replace '*' or '?' characters.
      instead of typing "sfk filter -spat -rep" all the time, you may use the
      short form "sfk filt -srep". the same applies for -(s)sep, -(s)form etc.
      Linux users: add quotes "" around everything that contains * or ?,
      otherwise it will be misinterpreted by the linux command shell.
   $unified syntax
      since sfk 1.5.4 you can also use -: -ls: -le: under windows.
      filter ... -uform or filter -upat ... -form uses ## instead of $$.
   $further options
      -verbose        show names of all files which are currently scanned.
      -write          do not print output to console but overwrite input file(s).
                      only files with actual text changes will be rewritten.
                      this function may be used only with plain ASCII files, not with
                      binaries like .doc, .xls. see also "sfk replace".
      -write -to msk  do not overwrite input files, but save according to mask msk,
                      e.g. tmp<sla><run>file . saves only changed files. say -writeall
                      to write all files, including those without changes.
      -memlimit=mb    when using -write, output is cached in memory, which is limited
                      to 300 mb. use this option to extend, e.g. -memlimit=400
      -yes            -write simulates by default. add -yes to really write changes.
      -snap           detect snapfiles and list subfile names having text matches.
      -snapwithnames  same as -snap, but include subfile names in filtering.
      -nofile[names]  do not list filenames, do not indent text lines.
      -count, -cnt    preceed all result lines by output line counter
      -lnum           preceed all result lines by input  line number
      -case           compare case-sensitive (not default)
      -lit[eral]      treat wildcards * and ? as normal chars (read more above).
      -noinfo         do not warn on line selection combined with -write.
      -noop \"        no operation, take the \" parameter but do nothing.
                      may help if your (windows) shell miscounts quotations.
      -hitfiles       if another command follows (e.g. +run or +ffilter),
                      pass a list of files containing at least one hit.
      -justrc         print no output, just set return code on matching lines.
   $list of possible input sources
      from stdin                : type x.txt | sfk filter -+pattern
      from single input file    : sfk filter x.txt -+pattern
      text from chained command : sfk list mydir .txt +filter -+pattern
      from many files, directly : sfk filter -+pattern -dir mydir -file .txt
      from many files, by chain : sfk list mydir .txt +filefilter -+pattern
      in general, whenever you need to make sure that file contents (not the
      file names) are processed, prefer to say "filefilter" or "ffilt".
   $return codes for batch files
      0   normal execution, no matching lines found.
      1   normal execution,    matching lines found.
          with -write: returns rc 1 only if any changes were written.
     >1   major error occurred. see "sfk help opt" for error handling options.
   $common errors
      when using filter -form within sfk scripts, expressions like <run>10.10col1
      may collide with script parameters <run>1 <run>2 <run>3. to solve this, use brackets
      like <run>(10.10col1), or "sfk label ... -prefix=%%", or -uform.
   $examples
      #anyprog | sfk filter -+error: -<not>warning
         run command anyprog, filter output for error messages, remove warning messages.
      #sfk filter result.txt -rep "_\_/_" -rep "xC:/xD:/x"
         read result.txt, turn all \ slashes into /, and C:/ expressions to D:/
         the quotes "" are optional here, and just added for safety.
      #sfk filter index.html -rep "_<u>_<b>_" -rep "_</u>_</b>_" -write
         replace underlining by bold in an HTML text. quotes "" are strictly
         required here, otherwise the shell environment would split the command
         at the < and > characters. add option -yes to really rewrite the file.
      #sfk filter export.csv -sep ";" -format "title: <run>-40col2 remark: <run>-60col5"
         reformat comma-separated data, exported from spreadsheet, as ascii text.
      #sfk stat . +filter -blocksep " " -format "<run>4col1 mb in folder: <run>col5"
         reformats output of the stat command.
      #sfk filter mycsv.txt >out.txt -spat -rep _\"__ -rep _\t__ -rep "_;_\"\t\"_" -form "<run>qcol1"
         read semicolon-separated spreadsheet data mycsv, strip all double colons
         and tab characters from data fields. replace field separator ";" by TAB,
         and surround all fields by double colon. -form without -sep means "pack the whole
         line into <run>col1", allowing -form to add quotes at start and end of each line.
      #sfk filter logs\access.log "-+GET * 404"
         list all lines from access.log containing a phrase with GET and 404.
      #sfk filter log.txt "-ls<not>??.??.???? ??:??:?? * *"
         excludes lines from log.txt starting with a date, and having two more words,
         like "20.05.2007 07:23:09 org.whatever.server main"
      #%s | sfk run -idirs "sfk filt tpl.conf >httpd.conf -rep _AbsWorkDir_<run>path_"
         create httpd.conf from tpl.conf, replacing the word "AbsWorkDir" by the path
         from which the command is run. note we can NOT use -spat in this case, otherwise
         a pathname like C:\temp would produce garbage (contains slash pattern "\t").
      #sfk filter in.txt -spat -sep "\t" -rep _\q__ -form "INSERT INTO MYDOCS (DOC_ID,
       #DESCRIPTION) VALUES ('TestDoc<run>03line','<run>col2');"
         this example (typed in one line) creates a list of SQL statements, using tab-
         separated, quoted input data, and using the input line number for document ids.
         the -rep _\q__ means the same as -rep _\"__ - it strips quotes from the input,
         but using \q is safer then \" as it doesn't let the shell miscount quotes.
      #sfk list documents .txt +filter -+big*foo -+wide*foo
         from all .txt files in documents, filter the filenames (NOT the file contents)
         for big*foo OR wide*foo.
      #sfk list documents .txt +filefilter -+big*foo -+wide*foo
         from all .txt files in documents, filter the file contents (NOT the names)
         for text lines containing big*foo OR wide*foo.
      #sfk list logfiles .txt +filefilter -global-unique +tofile mixedlog.txt
         join all .txt files from logfiles into one output file mixedlog.txt,
         dropping all redundant text lines. works only if logfile records are
         prefixed by a unique record ID, and if overall text data is less than
         available memory, because all data is cached during processing.
      #sfk list logfiles .txt +ffilter -global-unique -write -to mytmp<sla><run>file
      #sfk snapto=mixedlog.txt mytmp
         same as above in two commands, using temporary files to allow more data.
      #./runserver.sh 2>&1 | sfk filter -+exception
         filter standard output AND error stream ("2>") for exceptions
      #sfk filter result.txt -+error -justrc
      #iReturnCode=$$?
      #if [ $$iReturnCode -eq 1 ]; then
         echo "error occured."
      #fi
         in a bash script: tells if text "error" was found within result.txt.
         due to option -justrc no output is printed to terminal.
      #sfk filt log.txt -high cyan "*.*.*(*.java:*)" -high green "sql select *"
         dump log.txt, listing java stack traces in cyan, and sql selects in green.
      #sfk filt x.html -where "000099" -rep "_<font*000099*>_<b>_" -rep "_</font>_</b>_"
         replaces html <font> commands by <b>, but only in lines with "000099" (=blue).
      #sfk filt foo.cpp -cut "ifdef barmode" to "endif // barmode"
         strip blocks of lines from foo.cpp, surrounded by the given patterns.
      #sfk filt csv.txt -spat -within "\q*\q" -rep _,_\x01_ -rep _,_\t_ -rep _\x01_,_
         change separators in comma separated data from comma to tab, also taking
         care of quotes, by replacing in-quote commas by a placeholder (\x01).
         if the data contains escaped quotes like "" then further prefiltering
         can be necessary, like removing those quotes by -sreplace _\q\q__
Filter
-justrc and -write cannot be combined.
filter cannot process input files from multiple sources.
info : source %d are filenames from previous command.
tip  : try to select all files within the previous command.
directory
info : source %d is input %s "%s"
info : source %d is directory or file parameter "%s"
options -snap and -rewrite not allowed together.
+copy
$[add -yes to really write changes.]
-write cannot be used this way, as it needs filenames.
maybe you want to use filefilter (ffilt) instead of filter?
[filter reads from chain data]
[filter reads from stdin (no chain data)]
<time>%d binary files skipped%s.<def>
<err>miss :<def> %s
<err>fail :<def> %s
addhead
$sfk addhead <in >out [-noblank] string1 string2 ...
   insert string(s) at the start of text lines.
   $options
      -noblank    does not add blank chars between added strings.
   $see also
      #sfk filter infile.txt -form "string1<run>col1"
         does the same and is more flexible.
-noblank
addtail
$sfk addtail <in >out [-noblank] string1 string2 ...
   add string(s) at the end of text lines.
   $options
      -noblank    does not add blank chars between added strings.
   $see also
      #sfk filter infile.txt -form "<run>col1string1"
         does the same and is more flexible.
ziplist
%s %s %s
ziplist2
<help>$sfk patch [-revoke|-redo] yourpatchfile.cpp [-sim|-verify]
   search text blocks in file(s) and replace them by other text blocks,
   including backup creation and optional restore of original files.
   -revoke: undo all patches, by replacing the modified targets
            by the backup files which sfk stores in save_patch.
            the target files are touched afterwards (date/time update)
            to enforce proper recompile. use -keep-dates to avoid this.
   -redo  : undo all patches and then re-apply patches.
            best used whenever you change the patchfile itself,
            to have your changes updated in the target files.
   -exact-match: by default, leading whitespaces are ignored.
                 use this option enforce exact 1:1 line matching.
   -keep-dates: by default, revoked files get touched. use this option
                to enforce original file dates (yet windows only).
   -sim     : simulate what the patch would do, don't change anything.
   -qs      : quick summary, just tell a one-line status.
   -stats   : show statistics of select-replace usage.
   -verify  : check if an applied patch is still intact.
   -nopid   : apply irrevocable patch without [patch-id].
   -anyroot : ignore the :root dir entry in a patch file.
   $patchfile rules:
   - patches are executed exactly in the order as given in the patchfile.
   - each :from/:to statement is executed exactly once.
   - if ANY of the :from/:to statements doesn't match the input,
     the whole file is NOT patched.
   - the first :to block for a new target file must contain the word [patch-id],
     by using a comment in the target file's syntax, e.g. in C++: // [patch-id].
     this marks the file as being patched -> sfk will not patch it again.
   it is recommended that your patchfiles have the ending .cpp (or .java etc.)
   to enable syntax highlighting with your favourite text editor.
   #sfk patch -example
      shows a detailed patchfile example.
   #sfk patch -template
      gives a simple, empty patchfile template.
<help>$sfk ... +if expression command1 ... +command2
   execute command1 if expression is true, then continue to command2.
   if expression is not true, skip directly to command2.
   can be used only in a command chain, after another command.
   $supported expressions
      rc=n   return code of previous command equal  to   n
      rc>n   return code of previous command higher than n
      rc<n   return code of previous command lower  than n
   $see also
      sfk call labelname - call sub functions in a script.
   $examples
      #sfk filter in.txt -+err +if "rc>0" run -yes "x.bat" +echo done
         if file in.txt contains the word "err", run x.bat.
         the "echo done" is always executed.
need an expression after if.
need a command after "if expression".
unsupported expression: %s
call
<help>$sfk ... +call label [parm1 parm2 ...]
   call a sub function in the current script,
   starting at the given label.
   $see also
      type "sfk tail" for a script example.
cannot use call outside a script.
label %s
label not found: %s
use "sfk label %s +..." to start with a label.
use "sfk ... +label %s +..." to insert a label.
unexpected format: "%s"
+end
loaded %d words from global script:
  run from "%s" (index %d)
run echo_$purefile xdir .cpp .hpp
list xdir +run echo_$pfile
<help>$sfk run "your command <run>file [<run>relfile] [...]" [-yes] [-nohead] [-quiet] [...]
   run a self-defined command on every file- or directory name.
   within your command string, you may specify:
      $<run>file<def>                     - insert full filename, including path.
      $<run>quotfile<def>    or $<run>qfile<def>    - just as <run>file, but with quotes "" around.
      $<run>relfile<def>     or $<run>qrelfile<def> - insert relative filename, without path.
      $<run>base<def>        or $<run>qbase<def>    - the relative base filename, without extension.
      $<run>ext<def>         or $<run>qext<def>     - filename extension. foo.bar.txt has extension .txt.
      $<run>path<def>        or $<run>qpath<def>    - the path (directory) without filename.
      $<run>since<def>       or $<run>qsince<def>   - with option -sincediff: the reference file name.
      $<run>text<def>        or $<run>qtext<def>    - one record of input text, similar to <run>file.
      always prefer 'q' forms over non-quoted forms: as soon as there is a filename
      containing blanks, e.g. X:\the src files\test one.txt, you will need quotations,
      or you have to manually insert \" or \q escaped quotes (see 3rd example below).
      you may also use <run>quotrelfile, <run>quotsince, <run>quottext for greater clarity.
      if you supply only <run>path expressions, only directories will be processed.
      on single word chain commands like "+run vi", " <run>qfile" is added automatically.
   $further pattern support:
      -spat       activates slash patterns like \t \q \xnn etc.
   $options
      -yes        really execute. default is just to simulate what would be done.
      -nohead     does not display the [simulating:] info text.
      -noinfo     unless you use <run>text, sfk checks the input filenames
                  1. if they contain blanks, but no quotes are given within command.
                  2. if they seem to use the wrong path separator character.
                  in both cases, a reminder is printed. if you know that your command
                  needs no changes, add -noinfo or use <run>text instead of <run>file.
      -quiet      does not echo the commands before execution.
      -relnames   strips the root directory names from filenames.
      -i[files]   process a text or filename list from stdin.
      -idirs      process a directory name list from stdin.
                  on stdin, '##' remark lines and empty lines are skipped. note:
                  "sfk.exe <list.txt" supports only 4 KB for list.txt under windows.
                  "type list.txt | sfk.exe" supports unlimited stream length.
      -nofile[names]   with chaining, does not create ":file " name records.
      -printcmd   print the full command which is executed to console.
      -stoprc=n   stop processing if a command returns return code >= n.
   $command string format
      with option -spat, slashpatterns like \t \q \xnn are supported.
      due to syntax limitations of the command shell, it may help
      - to use \q instead of \"   (avoids quote miscounting at shell)
      - to use \x26 instead of &  (if ampersand is behaving unexpected)
   $temporary or permanent output files
      if run output is post-processed by $command chaining<def>, e.g. run ... +filter,
      sfk creates temporary files to collect the output. by default, these files
      are deleted when run finishes. say "sfk help options" for more on this.
      specify $-to targetdir<sla><run>file<def> to write command output into a permanent
      target fileset. required directories are created automatically.
      -to accepts the same mask as run itself, e.g. -to "mydir<sla><run>path<sla><run>base.tmp"
      by default, standard output AND standard error stream are written to file.
      add $2>nul<def> to your command to strip the error stream.
   $command chaining notes
      sfk run "...<run>path..." +nextcmd: will pass directories, not filenames.
      sfk run ... -to tmp<sla><run>file +nextcmd: will pass output filenames, not input.
      sfk run ... +run: will pass unchanged input filename list.
   $see also
      sfk runloop - run commands using a loop counter.
   $examples
      #sfk run "attrib -R <run>qfile" -quiet testfiles\FooBank\BarDriver -yes
         removes readonly attribute on all files within BarDriver
      #sfk run "<img src=<run>quottext>" -dir . -file .jpg -nohead >index.html
         create html-style image list of all jpegs (using just simulation).
         note that option -nohead removes the [simulating:] info text lines.
      #type dirlist.txt | sfk run -idirs "xcopy \"x:<sla><run>path\" \"z:<sla><run>path\" /I /D" -yes
         update-copy all directories from dirlist.txt from x: to z:
      #sfk run "diff oldsrc<sla><run>file newsrc<sla><run>file" -relnames -sincediff oldsrc newsrc
         compare directories, run "diff" on all files with different content.
      #sfk run "diff <run>qsince <run>qfile" -sincediff oldsrc newsrc
         same as above, only shorter and safer (including quotes around filenames).
      #sfk run "zip update.zip <run>qfile" -since 20070131 . .java .jsp
         collect .java and .jsp files added/changed since 31-Jan-2007 into a zip file.
      #sfk list testfiles .txt +run vi
         open all .txt files in vi. <run>qfile is added automatically.
      #sfk sel . .avi +run "ffmpeg -i <run>file -f image -t .02 thumbs<sla><run>base-%%d.jpg"
         extract first image from all .avi movies, videos using ffmpeg.
      #sfk sel -since 30m . .cpp .hpp +run -printcmd "rm <run>path/<run>base.o" -yes
         delete all object files of source codes changed in the last 30 minutes
   Don't try to execute a full run statement in ONE GO. Almost certainly, something
   will go wrong (wrong files selected, syntax error in the command itself), and you
   end up with many wrong output files. Instead, use THREE STEPS:
   $1. find the correct file set, by some trial and error:
         #sfk run "echo <run>quotfile" mydir
      This will simply show all filenames from "mydir". no command is executed
      on those files, so nothing bad is happening. almost certainly, you notice
      that too many files are included. Maybe you have to add "-nosub" to exclude
      subfolders, or add more details about your file selection, like:
         #sfk run "echo <run>quotfile" mydir .jpg .jpeg
      which reduces the file set to just .jpg and .jpeg files within "mydir".
   $2. Replace "echo" by the actual command, still running in simulation mode.
         #sfk run "copy <run>quotfile \"d:\pic\small_<run>base.jpg\"" mydir .jpg .jpeg
      This simulates a copy of all images from mydir to d:\pic, prefixing their name
      by "small_", and ensuring that all target file extensions are only ".jpg".
   $3. When you're satisfied with the simulation output, add "-yes".
-stoprc
-printcmd
-ifiles
cannot use -ifiles and -idirs together.
-idirs
-int
echo $quotpath
echo $quotfile
conflicting parameter: %s
run is already receiving chain input, so %s is too much.
detected chain input data, but no token found in run command:
       %s
you may add %cfile or some other token to the run command.
to drop the chain contents, replace +run by "+then run".
to print them, insert "+toterm" or "+tofile filename" before +run.
-idirs only allowed with %cpath, not with file commands.
%.*s "%cfile"
empty run command. type "sfk run" for help.
no valid token in run command: "%s". type "sfk run" for help.
Eleele
you may also add -force to run the command without any tokens.
%s will receive no data as long as in simulation.
%d input names contain blanks, but no quotes (or %cqfile) found.
%d input names seem to use %c path separator instead of %c
runloop 1 100 copy_xfilesrc_xfiledst$03i.dat
printloop
<help>$sfk runloop ifrom ito "your command <run>[digits]i" [-yes] [-nohead] [-quiet]
$sfk runloop ifrom -steps=n [-inc=i] "your command <run>[digits]i"
$sfk printloop ifrom ito "your text <run>[digits]i"
   run a self-defined command many times, or simply print text to
   the console, with a counter starting at ifrom, running until ito,
   or running n times if -steps=n is specified.
   with runloop, execution of commands is just simulated by default,
   so nothing happens. as soon as your command is looking well, add
   option "-yes" to really execute.
   $options
      -inc=i    increment step counter by i instead of 1.
      -spat     support slashpatterns like \t \q \xnn.
      -delay=n  wait n msec after every executed command.
      -nohead   does not display the [simulating:] info text.
                printloop is the same as runloop -nohead.
      -quiet    does not echo the commands before execution.
      -quietrc  do not print rc status message per command.
   $command string format
      the command string may contain <run>i which is replaced by the
      loop counter, or slashpatterns if option -spat is given.
      due to syntax limitations of the command shell, it may help
      - to use \q instead of \"   (avoids quote miscounting at shell)
      - to use \x26 instead of &  (if ampersand is behaving unexpected)
      <run>i also supports format parameters before 'i' like:
         <run>5i    print 5 digits, right justified, filled with blanks.
         <run>05i   print 5 digits, right justified, filled with zeros.
         <run>-5i   print 5 digits, left  justified, filled with blanks.
      to print the <run> char itself in output use <run><run>
   $aliases
      #sfk printloop<def>  do not execute anything but just print
                     the resulting text to terminal.
   $see also
      sfk run - run self-defined command on filenames.
   $examples
      #sfk runloop 1 100 "copy mytest.dat testfile_<run>03i.dat" -yes
         creates 100 copies of mytest.dat named testfile_001.dat,
         testfile_002.dat, testfile_003.dat etc.
      #sfk printloop 1 100 -spat "<a href=\qhttp://...&page=<run>i\q><run>i</a>"
         creates html code containing 100 web links. note that \q was used
         instead of \", as '&' may create problems when combined with \"
         (a syntax mess produced by the command shell, not by sfk itself.)
         and to enable slash patterns like \q, -spat had to be added.
-steps=
too many parameters before %s
a start value must be specified before %s
-inc=
-inc value must be > 0
-quietrc
-delay=
-delay value must be > 0
unexpected option: %s
unexpected parameter: "%s" (3)
missing parameters. type "sfk runloop" for help.
runloop cannot collect filenames, only text data.
try to insert +texttofilenames or +ttf before %s
output chaining is supported only for simulation output.
wrong syntax, expected %ci somewhere.
%%%.*sd
<help>$sfk inst mtkinc mtkmac -dir ... -file ...
$sfk inst -revoke[|-redo] [-keep-dates] -dir ... -file ...
  instrument c++ sourcecode with calls to sfk micro tracing kernel.
  $parameters
    mtkinc         path and name of mtktrace.hpp file
    mtkmac         mtk block entry macro name, _mtkb_
  $options
    -revoke        undo all changes (copy backups back).
                   do not specify mtkinc, mtkmac on -revoke.
    -keep-dates    on revoke, also reactivate original file dates
    -redo          redo all changes
    -witheol       also instrument { at end of line, like in:
                   void Foo::bar(int nmode) {
       #sfk inst mtk/mtktrace.hpp _mtkb_ -dir testfiles !save_ -file .cpp
          instrument the code (saving all in save_inst dirs)
       #sfk inst -revoke -keep-dates -dir testfiles !save_ -file .cpp
          restore original code (copying back from save-inst dirs),
          also restoring the original time stamps.
       #sfk sel -dir base ext lib -file .cpp +inst mtk/mtktrace.hpp _mtkb_
          select the files of interest, and when done, run +inst on them.
    NOTE: is is recommended that you do NOT say "-dir ." in your batch files
          to ensure that instrumenting is always done on the correct path.
    read more about the sfk micro tracing kernel in the mtk/ dir.
-revoke
-redo
-keep-dates
-witheol
error  : inst: missing parms. supply include and macro.
strings
$sfk strings [-umlauts] [-wrapbin=n] filename
   extract strings from a binary file. resulting text lines are split
   at column 80 by default, which can be changed by -wrapbin or -wrap.
   $examples
      #sfk strings test.exe +filter -+VersionInfo
where
<help>$sfk pathfind mycmd
$sfk where mycmd
   search the PATH for the location of a command mycmd.
supply a command name to search within PATH.
%s not found anywhere within PATH.
deblank xdir .cpp .hpp
list xdir +deblank -dir xdir
<help>$sfk deblank dirname [.ext1] [.ext2] [...]
   remove blanks from filenames and directory names.
   simulates by default. add -yes to apply changes.
   $examples
      #sfk deblank docs
         lists all directories and files within docs having
         blanks in their names, previewing changes.
      #sfk select docs +deblank
         deblanks only the names of files, not of directories.
      #sfk select -withdirs docs +deblank
         deblanks filenames and directories.
-packalnum
reflist -dir xdir1 xdir2
<help>$sfk reflist [-path] [-wide] -dir sdir -file .text -dir tdir -file .sext
$sfk reflist -dir sourcedir -dir targetdir1 [targetdir2 targetdir3] [...]
   list possible dependencies between files through (fuzzy) content analysis.
   find out which target files are referenced by any of the source files.
<help>$sfk deplist [-flat] -dir srcdir [-file ...] -dir targdir [-file ...]
$sfk deplist [-flat] singleSourceFile -dir targdir [tdir2 tdir3] [-file ...]
   list possible dependencies between files through (fuzzy) string analysis.
   find out on which target files the specified source files depend.
   a list of target files is created from directory targdir. then all source
   files are loaded from srcdir, and scanned if the names of the targets appear
   within their content. if so, the targets are listed, with the number of
   referring source files, and a list (of the first 10) of these files.
   NOTE that sfk reflist DOES NOT GUARANTEE that files are (not) referenced.
   This way of reference detection is just a FUZZY INDICATOR, so keep thinking
   and make backups before you massively cleanup files without references!
   within their content. if so, the sources are listed with their dependencies.
   by default, deplist also checks which targdir files depend on other targdir
   files (recursive dependencies), resulting in more complete listings.
   specify -flat to disable recursive checks.
   if you specify just a singleSourceFile name, the source name is NOT included
   in the output (unless -incsrc specified), and the filename list can be used
   by subsequent (chained) commands.
   NOTE: you may specify any number of target directories. if your list of
   target directories is incomplete, files from there will NOT be found.
   by default, only relative target filenames are searched, without path,
   but including the file name extension.
                   e.g. the target file: #the/path/foosys.dll
                      runs a search for: #foosys.dll
                    in the source files.
   $options
      -path        search target filenames including path information.
                   e.g. the target file: #the/path/foosys.dll
                      runs a search for: #the/path/foosys.dll
      -noext       strip .extensions from filenames, compare only basename.
                   e.g. the target file: #the/path/foosys.dll
                      runs a search for: #foosys
                   which may lead to ambiguities, listing too many hits.
                   -noext can also be combined with -path.
      -wide[=n]    list references in an extended format, with a list of
                   (up to to n) source files per target file, telling in
                   detail which text patterns were found.
      -case        force case sensitive string comparison (not default).
      -quiet       do not print the number of source and target files.
      -relnames    if using -path, strip targdir name from target paths
                   for comparison.
      -flat        do not check if target files depend on other target files.
                   set this to improve speed, if you know that such
                   dependencies cannot exist, e.g. if the targets are .wav files.
      -memlimit=n  load and analyze only files with a size up to n mbytes.
                   the default load limit is 300 mbytes.
   $see also
      #sfk deplist<def>  list file dependencies.
   $see also
      #sfk reflist<def>  list file references.
   $examples
      #sfk reflist -dir mysrcdir mytargdir
         check every file in mytargdir if it is referenced
         by any file within mysrcdir.
      #sfk reflist -dir movie -file .ppt -dir pic -file .png
         find out which .png files within pic are referenced
         by .ppt files within movie.
      #sfk reflist -wide=100 -dir bin -file .exe -dir bin -file .dll
         find out which .dlls are directly referenced by .exe files
         within directory bin, listing up to 100 references per target.
      #sfk reflist -dir . -file .flp -dir . -file .wav
         within a FruityLoops project directory lists which .wav files
         are referenced by which .flp project files of that directory.
      #sfk reflist -dir film -file .ppj -dir audio frames clips
         tell which audio, image and movie clip files (e.g. .wav .bmp .avi)
         are used by which Adobe Premiere project files (.ppj) within the
         film directory. if image sequences are used, only the first image
         of such sequences will be found, e.g. foobar00001.bmp
      #sfk deplist -dir bin -file .exe -dir lib1 lib2 lib3 -file .dll
         create a list of all .exe files in bin, and the dlls they depend on,
         searching for dlls in lib1, lib2 and lib3 directories.
      #sfk deplist bin\diff.exe -dir bin -file .dll +run "copy <run>file tmp"
         find out which .dlls are used by diff.exe, and copy them to tmp.
      #sfk deplist -relnames -case -path -noext -dir classes -dir classes
         find dependencies between java .class files. -path uses path infos,
         -noext strips ".class", -case keeps the capital letters within names.
         -relnames strips "classes/" from target names for comparison.
      #sfk deplist -flat -dir . -file .flp -dir . -file .wav
         within a FruityLoops project directory lists which .flp project
         files are using which .wav files of that directory. note that
         .wav files cannot "use" other .wav files, therefore -flat was set
         to avoid recursive target checks, speeding up the search.
-wide=
-path
-noext
-base
-incsrc
-fast2
unexpected: %s
only one source file name supported, %s is unexpected.
no such file: %s
need at least two root dirs, for sources and targets.
filename chaining is not supported this way.
try specifying a single source filename.
] src: %s
] dst: %s [included as src]
%05u source files (%u internal sources)
%05u source files
] dst: %s
%05u target files
%05u %s       
      :ref:	
%05u %s
<warn>lists of source files have been truncated at the %dth entry.<def>
<time>use option -wide[=n] to list more source files per target.<def>
cleaning up memory
wait
<help>$sfk echo [-spat] string [string2] [string3] [...]
   prints the supplied string to terminal, which may contain color patterns:
       [Red][[Red]][def],[Green][[Green]][def],[Blue][[Blue]][def],[Yellow][[Yellow]][def],[Cyan][[Cyan]][def],[Magenta][[Magenta]][def]   (bright)
       [red][[red]][def],[green][[green]][def],[blue][[blue]][def],[yellow][[yellow]][def],[cyan][[cyan]][def],[magenta][[magenta]][def]   (dark)
         print the following text in the selected color.
       $[[def]]<def>
         switch back to default color.
       $[[[[<def> print the '[[' character, no not interpret the following word.
       $]]]]<def> print the ']]' character, do not interpret it.
   $further pattern support:
      -spat     activates slash patterns: \t=TAB \q=" \r=CR \n=LF
                \xnn = any code with hex value nn.
      -literal  or -lit disables everything, even color patterns. set this
                always if you need to process filenames in batch files,
                using echo to feed a command chain:
                   #sfk echo -lit %%1 +filter -rep _/_\_ ...
   $options
      -noline   stay in the same line, print no linefeed.
                if your string ends with \r, -noline is assumed.
      -noblank  if multiple strings are given, do not insert blanks
                between them.
   $see also:<def> sfk help colors
   $examples
      #sfk echo "[[Red]]error:[[def]] missing filename."
         prints "[Red]error:[def] missing filename." onto terminal.
      #sfk echo [[Cyan]]NOTE:[[def]] type the word [[[[red]]]] with brakets!
         prints "[Cyan]NOTE:[def] type the word [[red]] with brakets!" onto terminal.
      #sfk echo "[[Green]]mytext contains:[[def]]" +then filter mytext.txt
         $+then<def> forces echo $not<def> to pass its text to filter, but to
         print it immediately. filter then prints the content of mytext.
      #sfk echo -spat "foo\nand\nbar" +tofile mydir\test1.txt
         create a small text file with three text lines
-noline
unixtime
<help>$sfk time [format]
   prints the current date and time.
   $format:
      Y = year
      M = month
      D = day
      h = hour
      m = minute
      s = second
      any other char is passed through.
      default format is YMDhms.
   $options
      -spat  support slash patterns \t etc.
   $see also
      #sfk unixtime<def>   prints the unix timestamp
   $examples
      #sfk time -spat "Y-M-D\th:m:s" +filt -tabform "<run>col2 <run>col1"
         prints 2011-06-16 06:17:31 to terminal,
         with a tab character between date and time,
         post processing the output by sfk filter.
unexpected parameter: "%s" (15)
YMDhms
make-random-file
<help>$sfk make-random-file outfilename size [-text] [-seed=n]
   creates a file full of random binary data for testing.
   size parameters like 5m, 100k, 9000b are supported.
   type "sfk dupfind" for details on size parameters.
   $options
      -text     create text data instead of binary.
      -seed=n   specify randomizer seed. default is
                to use a time based seed.
   $example
      #sfk make-random-file tmp1.dat 1m -seed=1234
         produce a file tmp1.dat with 1 mbyte of size.
-seed
-vname
missing output filename
missing output size
invalid output size
fopenw
unable to write after %s bytes.
written %s (%s bytes).
testfwrite
<help>$sfk testfwrite outfile blocksize
<help>$sfk color colorname
   switches the text color of terminal (command line).
   supported color names are:
   white,grey,red,green,blue,yellow,cyan,magenta,black
      white  
      grey   
      red    
      green  
      blue   
      yellow 
      cyan   
      magenta
      black  
grey
black
unsupported color: %s
colortest
<help>$sfk colortest
   test all current logical colors.
=== List of current logical SFK colors. ===
=== If text is not colored type "sfk help color" for more. ===
Now follows the list of logical colors:
default, head, example, file, link, hit, replace,
error, warning, pre, info, traceinc, traceex
default  color, for the linux shell
head     color, for help text headers
example  color, for help text examples
file     color, for file names
link     color, for symbolic link files
hit      color, for search result hits
replace  color, to highlight replaced text
error    color, for error messages
warning  color, for warning messages
pre      color, for previous line hits
info     color, for many info messages
traceinc color, for -tracesel included files
traceex  color, for -tracesel excluded files
default  color, again
veri
sfk ver does not support input chaining.
you may use "+then ver filename" instead.
ver.
<help>$sfk version filename
$sfk ver -own
   print version of a binary file, or of sfk itself.
   the provided file is searched for a string with format:
      #$$%s:name=sfk,type=base,os=windows,vernum=1.5.1,fix=0,
      #title=Swiss File Knife,date=Aug  2 2008,info=major rework$$\0
   $%s string fields:
    [2] *name    short name, usually similar to the executable name
    [3]  type    the type of edition, e.g. base or extended
    [4] *os      operating system, e.g. windows, linux-lib6, linux-lib5
    [5] *vernum  version number, any number of values separated by dots
    [6]  fix     fix level, e.g. a revision or service pack number
    [7] *title   long, descriptive name, as printed in a help text
    [8] *date    release or compile date
    [9]  info    additional infos or remarks, free text string
   fields marked with "*" are mandatory for a valid version string.
   the other fields can be left out, or be empty like ",fix=,".
   if found, contents are printed TAB-separated, #after the filename<def>,
   therefore the #[]<def> numbers given above are #output column numbers<def>,
   not the location in the input string (which is random anyway).
   $options
      -num[ber]  just print the full version number, combining
                 vernum and fix to a dotted string.
                 cannot be used with -own.
      -verbose   tells a warning if file(s) contain no version.
   $see also
      #sfk require<def> - check if a required version is used.
   $examples
      #sfk ver dview.exe
         print the version of a Depeche View executable.
      #sfk ver -own
         print sfk's version.
      #sfk ver -nosub . .exe +filt -ssep "\t" -sform "$$-20.20col1\t$$col5"
         search all .exe files of the current dir for versions,
         reformatting the output, with a 20 chars filename limit.
-own
-num
require
<help>$sfk require inputVersion requiredVersion
$sfk require -own requiredVersion
   check a version text against a required version,
   or check SFK's version itself.
   produces shell return code 0 if input version
   is greater or equal to required version.
   $options
      -name=x   if input version is too old, SFK prints
                an error message containing x.
      -own      check SFK's own version.
      -quiet    do not print info message
                in case of failure.
   $windows .bat file example
      @echo off
      sfk require -own 1.6.1.2
      IF %%ERRORLEVEL%%==0 GOTO sfkok
      echo "wrong SFK version, stopping."
      exit /B
      :sfkok
   $linux bash example
      sfk require -own 1.6.1.2
      iReturnCode=$$?
      if [ ! $$iReturnCode -eq 0 ]; then
         echo "wrong SFK version, stopping."
         exit
      fi
   $further examples
      #sfk ver -number dview.exe +require -name=dview 1.4.8
         check if dview.exe is 1.4.8.0 or higher.
-name
supply required version, e.g. 1.6.1
supply a filename and required version, e.g. myfile 1.6.1
1.7.4
int. #2118201
using: %s
missing -own parameter.
script requires Swiss File Knife (sfk) version: %s
current binary %s has version %s
script requires %s version %s (current=%s)
webserv
<help>$sfk httpserv [-h[elp]]]] [-port=nport] [-rw]
   The SFK Instant HTTP Server for easy file transfer.
   $default behaviour:
   * the CURRENT DIRECTORY is made accessible, without subdirs.
   * any kind of directory traversal (.., / etc.) is blocked.
   * just ONE CLIENT (browser etc.) can connect at a time.
   $only for trusted environments!
     sfk httpserv is intended only for personal file transfer
     between two machines that the user has control of, within
     a trusted LAN environment. it should not be used to offer
     files in the internet. if security is important then do not
     use sfk httpserv but a full scale web server like Apache.
   $options
     -port=n     use other port than default, e.g. -port=81.
     -port2=n    alternative port, used if first port fails.
                 use -port2=0 to disable alternative port.
     -rw         allow write access. displays a single file
                 upload form when accessing "/".
     -nolist     do not provide a content listing, but change
                 any access to "/" into "index.html".
     -deep       allow reading of files in sub directories.
                 only for use with -nolist, as it does not
                 provide sub directory listings.
   $see also
     #sfk ftpserv -h<def>    the SFK Instant FTP server.
     #sfk wget<def>          a web file download command.
-port
-port2
-deep
-nolist
-timeout
sftserv
<help>$sfk ftpserv [-h[elp]]]] [-port=nport] [-rw] [workdir]
   The SFK Instant FTP Server for easy file transfer.
   $default behaviour since SFK 1.6.7.2:
   * the CURRENT DIRECTORY is made accessible, WITH subdirs.
   * any kind of directory traversal (.., / etc.) is blocked.
   * just ONE CLIENT (browser etc.) can connect at a time.
     if another client connects, the first is auto closed.
   * after 60 seconds of inactivity, the connection is closed.
   * filenames with accents are sent as is (no UTF8 support).
   * with -rw, files of any size can be written (no size limit).
   * with -rw, #existing files are overwritten without asking.
   $only for trusted environments!
     sfk ftpserv is intended only for personal file transfer
     between two machines that the user has control of, within
     a trusted LAN environment. it should not be used to offer
     files in the internet. if security is important then do not
     use sfk ftpserv but a full scale FTP server like FileZilla.
   $options
     -port=n     use other port than default, e.g. -port=10000.
     -port2=n    alternative port, used if first port fails.
                 use -port2=0 to disable alternative port.
     -pw=x       require primitive authentication, i.e. client
                 must provide password x to login. you may also
                 set an environment variable like:
                    export SFK_FTP_PW=mypassword
     -user=x     require this username. if not specified then
                 any username can be used. can also be given
                 by environment variable SFK_FTP_USER.
     -timeout=n  set timeout to n seconds. default is 60.
     -rw         allow read+write access. default is readonly.
     -maxsize=n  set size limit per file write to this, e.g.
                 10m = 10 mbytes. default is no size limit.
     -minspace=n set required free disk space for file writing,
                 e.g. -minspace=200m requires 200 megabytes.
     -noclone    do not try to replicate time stamps on a file
                 transmission from an sfk ftp client.
     -verbose    list the transmitted ftp commands.
                 helpful to get more infos in case of errors.
     -quiet[=2]  print less or no status informations.
     -nosub      block sub directory access, e.g. the client
                 may NOT say "put the/sub/dir/document.txt".
     -run        allow client to execute system commands.
                 requires -pw option being set as well.
                 requires an sfk ftp client to run commands.
     -runpw=x    require authentication only for run commands.
                 can also be set via the environment:
                    export SFK_FTP_RUNPW=mypassword
     -ownip=x    if client sends PASV command, by default the
     -ownip x    server replies with the first network interface
                 IP found. if this is the wrong one, you may
                 supply a different IP here (as n.n.n.n).
     -noclose    do not auto close first client connection
                 if another client tries to connect.
   $specific single work dir:
      instead of making the current directory accessible
      you may set a folder name like #sfk ftpserv mydir<def>
      to allow access to these contents only.
   $multi directory mappings:
      instead of making the current directory accessible,
      you may specify folders (with virtual names) like:
         #-usedir C:\audiofiles D:\images=pic
   $aliases
      sfk sftserv ...  = the same as sfk ftpserv, but using port 2121.
   $file attributes
      since SFK 1.6.7, if an SFK server speaks with SFK client,
      linux file attributes are sent and written at the receiver,
      except for file owner 'rw' flags which are set by default
      to allow rewrite in future transfers. when sending from linux
      to windows attributes like 'x' get lost.
   $problems and solutions:
   if you try to login to the server using a regular ftp client, but
   you cannot connect and/or transfer files, then usually there is a
   firewall or network configuration incompatible to normal FTP.
   - if your ftp client provides a command "passive", then type that,
     press enter, and then try the usual commands like dir, get or put.
   - whenever possible, use the SFK FTP client to connect to an SFK FTP
     server. client and server will then use a different protocol (SFT)
     with which you often can transfer files even if normal FTP fails.
   - Windows Vista, Windows 7: the firewall may stop sfk to sfk file
     transfer on the default port 21, with error ECONNRESET, probably
     because sfk uses a different protocol. You then have to use a
     different port, e.g. -port=5000 or use Windows' "ftp" command.
   - Windows 7 Starter: you may have to open the firewall settings
     and enable incoming connections for application "sfk" manually.
   - Windows: whenever running sfk.exe in an ununsual user context,
     e.g. from a mounted virtual drive, or a non-admin shell, this
     may cause the system to block incoming connections.
   - some FTP clients must be configured not to use multiple transfer
     connections in parallel (FileZilla: edit/settings/transfers)
   - virtual machines: when using NAT network adapter mode you may
     not connect from the host into the guest but only vice versa.
     you may configure port forwards in the VM's adapter settings,
     then connect to 127.0.0.1:portnumber but not to the IP shown
     in the guest. also read the VM's help on adapter modes.
   $known compatible ftp clients:
     WinSCP (in FTP mode), WS_FTP95, FileZilla, command line ftp
   $known incompatible ftp clients:
     Windows Explorer FTP (requires unsupported multi connections)
   $see also
     - type "#sfk ftp<def>" for the SFK FTP client. when it connects to an
       SFK FTP server, you get easier connectivity and more features.
     - type "#sfk httpserv -h<def>" for the SFK Instant HTTP Server.
   $examples
   - to run sfk as a 'real' ftp server for non sfk clients:
     (uses port 21. sfk ftp clients may also connect,
      but see possible problems listed above.)
     #sfk ftpserv -user=foo -pw=bar mydir
       require the given user/pw and allow read only access to mydir
       and all subdirectories of mydir.
     #sfk ftpserv -rw -usedir website/images=pic /Musik/audio=audio
       allow read/write access to website/images with virtual folder
       name "pic" and to /Musik/audio as just "audio".
   - if you just want quick and simplest file transfer between two
     machines both having sfk, use this:
     #sfk sftserv -rw
       run an sfk simple file transfer server, using port 2121,
       allowing read/write access to current dir and all sub dirs.
       then use "sfk sft" at the client side. should no connection
       be possible run the server and/or client with admin rights
       and check the firewall settings.
-ownip
-minspace
-user
-user requires a parameter.
-pw requires a parameter.
-runpw
-runpw requires a parameter.
-maxsize
-maxsize must be at least "1m" for one megabyte
-anysize
-wany
-rwany
-noclone
-noclose
-usedir
-run requires -pw or -runpw being set.
ftp 127.0.0.1:5000
ftp 127.0.0.1:5000 get xfile
<help>$sfk ftp host[:port] [options] [command [parms]]
   The SFK Simple FTP Client.
   $commands
      put x     send a single file with name x
      get x     receive a single file with name x
      mput x    send multiple files of the current directory
                having x in their filename
      mput .ext send multiple files ending with .ext
      mget x    receive multiple files from the ftp server
                having x in their filename
      mget .ext receive multiple files ending with .ext
      dir       list the remote directory
      cd x      change into remote directory x
      lcd x     change into local  directory x
      !mycmd    execute local command mycmd
      run cmd   run remote command (only with sfk ftp server)
      bye       exit
   $options
      -force    continue transfer after errors.
      -verbose  list the transmitted ftp commands.
                helpful to get more infos in case of errors.
      -quiet    disable progress indicator and other output.
      -nohead   do not show message "using SFK_FTP_USER ..."
      -noprog   no progress indicator during transfers.
      -update   or -up transmits only changed files. this option
                is experimental and may or may not work, depending
                on the server software, server settings (UTC vs.
                local time) and time zone.
      -new      the same as -update.
      -user=x   or -user x sends username x instead of anonymous.
                you may also set an environment variable like:
                   export SFK_FTP_USER=myuser
      -pw=x     or -pw x sends an authentication password x.
                you may also set an environment variable like:
                   export SFK_FTP_PW=mypassword
     -noclone   do not try to replicate time stamps on a file
                transmission from an sfk ftp server.
     -pres      always preserve full file attributes, including
                readonly modes. default is to keep file writeable
                by file owner and to apply umask under linux.
     -verify    extra verify by re-reading files after transfer
                and comparing against a transmitted md5 checksum.
   $aliases
      sfk sft ...   = the same as sfk ftp, but using port 2121.
      cput          = same as "mput -update" (multi put changed).
      cget          = same as "mget -update" (multi get changed).
                      cget, cput have same experimental status
                      as described under the -update option.
   $automatic IP expansion
      if you are in the same subnet as the target host,
      you may supply only the IP number's last part, e.g.:
         sfk ftp 23 ... == sfk ftp 192.168.1.23 ...
      this feature may or may not work, depending on your
      operating system and number of network interfaces.
      add option -showip to see what the expanded IP is.
   $file attributes
      since SFK 1.6.7, if an SFK server speaks with SFK client,
      some linux file attributes are sent and written at the
      receiver. by default, rw for owner is always set, and the
      target system umask is applied. use option -pres(erve)
      to transfer attributes as is. when sending from linux
      to windows attributes like 'x' get lost.
   $examples
      #sfk ftp farpc put test.zip
         send test.zip to farpc
      #sfk ftp -user=foo -pw=bar farpc put test.zip
         the same but with authentication
      #sfk ftp 192.168.1.99:30199 get test.zip
         receive test.zip from 192.168.1.99 port 30199
      #sfk ftp farpc mput .cpp
         send all .cpp files of the local dir to farpc.
         subfolder contents are NOT included.
      #sfk ftp farpc mget "%c"
         receive all files from farpc's directory,
         overwriting everything in the local directory.
      #sfk ftp hostname
         enter interactive mode, in which you can type
         the above commands directly. for example,
            !ls runs the command "ls" locally.
      #sfk sel -today mydir .css .php +ftp farpc mput
         upload all .css and .php files changed today
         within the mydir folder to FTP server farpc.
         before doing so, make sure that farpc has the
         same folder structure (mydir at top level).
   $IF connected with an sfk sft server:
      best practice is to run an sft (simple file transfer)
      server on the other PC or VM like:
      #sfk sftserv -rw
      this will use port 2121, avoiding firewall and other
      restrictions that usually block use of ftp port 21.
      then the following can be used by an sfk client:
      #sfk sft farpc get myfile.txt
         download myfile.txt instantly. if a local file
         exists with the same name then it is overwritten.
      #sfk sft farpc mget myfile
         download all files having "myfile" in their name.
         sfk will show a "simulating" preview first.
         add -yes to really download the files.
      #sfk sft farpc mput myfile
         send all files having "myfile" in their name.
         if files with same name exist at server then
         they are overwritten.
      #sfk sft farpc get the\sub\dir\doc.txt
         by default, sfk sftserv allows deep direct access
         to files within folders. all required output dirs
         are created automatically. this deep access cannot
         be used with mget, mput and dir.
      #sfk sel mydir .txt +sft farpc cput
         send all .txt files within mydir that changed since
         the last transmission to farpc.
      #sfk filter filelist.txt +sft farpc mget mydir
         create a list with filenames, download the files listed
         therein from server farpc into a folder "mydir".
      #sfk sft 192.168.1.100 cput .txt
         connect to server .100 and send all .txt files
         which are newer or were added in the local folder.
      #sfk sft 192.168.1.100 cget .txt
         connect to server .100 and download all .txt files
         which are newer or were added in the remote folder.
      #sfk sft farpc -pw mypw run "sh myscript.sh >tmp1.txt 2>&1"
         execute a command on the remote server, redirecting all
         output into a file tmp1.txt. requires an sfk sft server
         with option -run, AND -pw authentication on both sides.
   $problems and solutions:
   - if running the ftp server just like "sfk ftpserv" then
     on Windows Vista, Windows 7 the firewall may stop sfk to sfk
     file transfer on port 21 with ECONNRESET or ECONNABORTED.
     therefore use a different port, like -port=2121 which is
     default with sftserv. read more under: sfk ftpserv -help
   $see also
      #sfk ftpserv -help
NOTE: existing files are overwritten <err>without asking back<def>.
      Make sure that ftp server and client are running
      in the correct directories, especially before mput/mget.
-new
-pres
missing target host.
anonymous
[using SFK_FTP_USER/PW for authentication]
checkdisk
<help>$sfk checkdisk volumepath rangesizemb|all
   test the disk or stick specified by volumepath if it is reliable. sfk will write
   100 test files, filling up rangesize mbytes, re-read them, and check for errors.
   after that, test files without errors are removed, but those with errors are kept,
   to block damaged parts of the media from being reused.
   NOTE: detection of errors does NOT always mean that the MEDIA itself is corrupted.
         the reason may as well lie within the USB electronic of your PC, or within
         the disk drive controller. for USB sticks, always test them at least with
         two different PCs.
      #sfk checkdisk E:\ all
         checks all space available on drive E:\, e.g. USB-stick.
      #sfk checkdisk G:\ 1950
         checks 1950 mb on drive G:\
supply no. of mbytes to check, or "all".
hexdump -showle -wide -nohead xdir .dat1 .dat2
hexdump -lean -pure -dir xdir -file .dat
hexdump -hexsrc xfile1
hexdump -decsrc xfile1 xfile2
hexdump -flat xfile1
tcpdump 5000 -forward xhost:xport -timeout 20000
udpdump
postdump
mindump
knxdump
hexle
<help>$sfk hexdump [-showle] [-wide] [...] dir .ext1 .ext2 .ext3
   create human-readable hexdump of binary file(s).
<help>$sfk udpdump [options] [group] port
   create human-readable hexdump of UDP socket input,
   for debugging of UDP network applications.
<help>$sfk tcpdump [-showle] [...] port [-forward host:port] [...]
   create human-readable hexdump of tcp socket input, and optionally
   dump a tcp conversation, for debugging of web applications.
   $options
      -full   print knx messages with full details.
      -showle  highlights line ending characters CR and LF.
               you may also add "le" to the command name.
      -wide    dumps 32 input bytes per line.
      -lean    dumps 16 input bytes per line.
      -post    reduced format e.g. for forum posts
      -min     minimal format with alnum only text
      -echo    echo received packets back to sender.
      -stop    or stop=n stops after n received packages.
               with command chaining, default is -stop=1.
      -sep[arator] prints detailed separator between packages
               with message number, source IP and time.
      -forward specifies a host and port to which to forward
               incoming requests, to dump a tcp conversation.
      -timeout number of milliseconds to wait after last transfer
               until connections are closed. default is 60000,
               or 10000 if http is detected.
      -nofile  or -nofilenames does not list the filename(s).
      -rawname prints filename without :file prefix
      -pure    lists flat hex characters:
               #53464B2D544553540D0A
      -hexsrc  lists hex comma separated values:
               #0x53,0x46,0x4B,0x2D,0x54,0x45,0x53,0x54,0x0D,0x0A,
      -decsrc  lists decimal comma separated values:
               #83,70,75,45,84,69,83,84,13,10,
      -off[set] n1    dump from offset n1 to file end.
                      n1 can be negative, for example
                      -off=-100 dumps last 100 bytes of file.
      -last n1        same as -offset -n1
      -offlen n1 n2   dump from offset n1 only n2 bytes.
      -notrail     no trailing comma "," at end of hex/dec src
      -norectrail  no trailing comma at end of every src record
      -recsize n   only with -hex/decsrc, -pure or -flat:
               change no. of input bytes dumped per record.
               with default output format, use -wide instead.
      -maxdump=n   dump only first n bytes of incoming data.
      -flat        no hexdump, print characters as they come.
      -nohead      does not show the "received n bytes" message.
      -tofile x    write output to file x.
   $message filtering
      show only messages ...
      -from s       from IP's containing text s
      -size n       with this size
      -minsize n    larger  or equal to n
      -maxsize n    smaller or equal to n
      -data foo     containing text "foo"
      -data 0xa0a1  containing binary data 0xa0a1
   $experimental multicast receive
     if a multicast group IP address is given, like
        #sfk udpdump 224.0.0.123 5000
     then udpdump tries to print incoming multicast messages.
     this $may or may not work<def> depending on the OS, network
     interface, router and firewall settings, user rights and
     other programs running in parallel.
   $special protocol support
     #sfk udpdump -bon<def>   - print bonjour messages
     #sfk udpdump -knx<def>   - print knx messages (sfk help knx)
   $see also
     #sfk udpdump<def> - dump incoming UDP packets.
     #sfk hexdump<def> - for further format options.
   $examples
     #sfk tcpdump 9000 -showle -forward www.google.com:80 -timeout 2000
        then connect with your browser to localhost:9000 and see
        the http requests and replies which are passing through.
        small timeouts are recommended to trace http communication,
        as the web browser may wait until the connection is closed.
     #sfk tcpdump 5000 -flat -timeout 2000 -forward myproxy:8000
        show plaintext communication to anywhere via a proxy server.
        to connect this way, you MUST connect to sfk as a proxy:
        in Firefox, open tools/options/advanced/network/settings, set
        manual proxy configuration, http proxy "localhost" port 5000.
        then type some external servername, e.g. "http://google.com"
        in your browser. In this example, is expected that a proxy
        machine "myproxy" exists within your local network.
        After the test, disable the proxy setting in your browser.
   $see also
     #sfk udpsend<def>  - send UDP packets.
     #sfk hexdump<def>  - for further format options.
     #sfk help knx<def> - for knx examples.
   $examples
     #sfk udpdump 5000
        waits on port 5000 for incoming udp packages.
  $aliases
    #sfk hexdumple<def> - same as "sfk hexdump -showle" for text
    #sfk postdump<def>  - same as "sfk hexdump -post" for forums
  $see also
    #sfk hextobin<def>  - convert hex dump back to original data.
  $examples
    #sfk hexdump -offlen 4221566976 96 part1.avi
        dumps 96 bytes from offset 4221566976 within part1.avi
    #sfk hexdump -offlen 0xFBA00000 0x60 part1.avi
        the same as above, but using hexadecimal numbers
-show-line-endings
-showle
-lean
-narrow
-hexsrc
-decsrc
-notrail
-norectrail
-post
-min
-nosep
-nolf
-bon
224.0.0.251
-knx
-knxfull
-full
-recsize must be 1 ... %d
-forward
missing port, specify -forward host:port
<warn>note: timeout set to %d milliseconds (%u.%03u seconds).<def>
-offlen
-offlen offset
supply values like -offlen 10000 100
-offlen length
-off
-offset
-last
-echo
-rawname
-maxdump
-stop
-data
-show
only one -%s is allowed
wrong hex format: %s
%s too long
224.0.23.12
-recsize requires -hex/decsrc, -flat or -pure format.
use -wide to print 32 bytes per line in default format.
specify port number to listen on.
fromnet
<help>$sfk fromnet [port] [options]<def>
   receive network text sent by sfk tolog or tonetlog.
   if a port number is given, it is used to receive text
   instead of the default UDP port 21323.
   $options
      -nocache  do not cache text lines without linefeed
                but print them to terminal immediately.
                default is to wait for a linefeed, to join
                large lines split across multiple messages.
   $see also
      sfk netlog   - how to send SFK network text
      A recommended #GUI tool<def> to view and filter network text
      is #Depeche View<def>. Type #sfk getdv<def> to download, then run
      the tool by #wine ./dview -net &<def>
   $examples
      #sfk fromnet
        wait for incoming text and print it to terminal.
      #sfk fromnet +filter -high red error +loop
        highlight errors in red in the incoming text.
-group
cannot receive on port %d
wrong input, rc=%d
%.*s> 
sendudp
sendcast
tcpsend
sendtcp
knxsend
<help>$sfk udpsend host port [options] data [data2] [...]
   send an UDP message and optionally receive replies.
   $options
      -listen        wait for a single reply, and dump it.
      -listen=n      wait for so many replies and dump them.
      -listenall     receive endless.
      -timeout=n     wait up to n msec for replies.
      -wide, -lean   etc. change hex dump output format.
                     for details, type "sfk hexdump"
      -flat          print messages as plain text.
   $input data format:
      0x123456       a hex string which is converted to binary
      foo            any other plain text is sent as is, but
                     zero termination is NOT done automatically.
      all given data fragments are joined into one large block.
      how long the block can be is system dependent, but it must
      always stay below 2000 bytes.
   $experimental multicast send
      if option -mcast and a multicast group is given, like
         #sfk udpsend -mcast 224.0.0.123 5000 testtext
      then udpsend tries to send a multicast message.
      this $may or may not work<def> depending on the OS, network
      interface, router and firewall settings, user rights and
      other programs running in parallel.
   $see also
     #sfk help knx<def>    for knx examples.
   $examples
      #sfk udpsend localhost 12345 -listen hello 0x00
         send "hello" followed by a zero byte to localhost
         on port 12345, then receive a single reply.
-replyport
-listen
-listen=
-listenall
-multi
-mcast
-ntp
data too long
missing data to send. type "sfk help knx" for examples.
tolog
tonetlog
<help>$sfk tolog [-help]
$sfk tonetlog [server[:port]]]]|[port]
   Send text output of a command to terminal, and/or append
   it to a log file, and/or send it to a network text viewer.
   The log target(s) can be specified in the following ways:
   1. by defining an environment variable:
      #<exp> SFK_LOGTO=net[:hostname[:port][,raw]]
      #<exp> SFK_LOGTO=file:mylog.txt
      #<exp> SFK_LOGTO=term
      where targets can be combined like:
      #<exp> SFK_LOGTO=term,file:log.txt,net,duplex
   2. by using #tonetlog<def> to force sending by network.
      in that case, a hostname and port can be specified
      as parameters. the default is to send to localhost.
   If no log target is specified all text goes to terminal.
   A recommended #GUI tool<def> to view and filter network text
   is #Depeche View<def>. Type #sfk getdv<def> to download, then run
   the tool by #wine ./dview -net &<def>
   $parameters<def>   (with tonetlog only)
      server    IP or name of target machine to send text to.
      port      target port, default is 21323 (SFK UDP Text).
                you may also type a port without "server:".
   $options
      -h[elp]   print this help text (same as "sfk netlog").
      -duplex   request a reply for each message sent.
                much slower, but it is made sure that the
                receiver actually receives all text, which
                is not sure without -duplex.
      -timeout=n with -duplex: time to wait for a reply.
                default is 1000 msec.
      -delay=n  if not using -duplex then wait so many msec
                after each message sent (default is 10).
                delay is required with longer text as
                receiver may fail to cache all messages.
      -raw      send raw UDP text without sfktxt header.
                cannot be combined with -duplex.
      -toiso[=c] or just -iso converts utf8 to iso-8859-1
                with default character c for non-8bit codes.
      -nolf     do not append LF after single line text.
      -usecr    append CR instead of LF after single line text.
      -clear    clear target log. cannot be used with -raw.
      -verbose  tell log target if taken from environment.
      -recsize=n UDP max message size, default is 1000 bytes.
   $SFK_LOGTO accepted fields<def>
      term,file,net,raw,duplex,timeout,delay,toiso,nolf
   $Send And Forget versus Duplex Transfer
      By default, SFK netlog sends text #without checking
      #if it arrives at receiver<def>. This is the way that
      plain UDP works, and it makes sense for scripts
      that shall #NOT slow down or even stop<def> just because
      the receiver is too slow, or not present at all.
      However, #it is NOT guaranteed that all text arrives
      #in complete, or in the same order as sent<def>.
      If text is lost you may increment the -delay, or use
      the #-duplex<def> option. With duplex, however,
      #non listening or slow receivers<def> will cause #delays<def>
      and #error messages<def> and may #stop command execution<def>.
   $Working process example: remote compile scripts
      Type "sfk netlog -full" for example scripts how to run
      batch files on remote machines and view their output.
   Cross platform software development often means to edit
   under Windows, and to compile on a remote Linux build server.
   Terminal output of a command line compiler should be sent
   back to the Windows machine for display. This can be done like:
   --- Example Windows batch file for upload: ---
   set FTPOPT=-nohead -quiet -noprog 192.168.1.200
   set NETLOG=sfk filter "-! files of*sent" +tonetlog
   sfk echo "build on remote server" +tonetlog
   sfk sel myproject .cpp .hpp +sft %%FTPOPT%% cput -yes | %%NETLOG%%
   sfk sft -pw=foo %%FTPOPT%% run "./rcomp.sh" | %%NETLOG%%
   --- Example Linux rcomp.sh for compile: ---
   export SFK_LOGTO=net:192.168.1.100
   sfk echo -spat "[[green]compiling on build server" +tolog
   bash compile.sh 2>&1 | sfk filter -high Red error +tolog
   This will upload changed files from a Windows machine .100
   to a Linux machine .200, with the upload status sent directly
   to the netlog on the same (Windows) machine. It is assumed that
   sfk sftserv -run -runpw=foo is running on the Linux server.
   Then, a Linux batch "rcomp.sh" is executed under Linux,
   which again calls the actual build script "compile.sh".
   All status and error text is sent to the netlog viewer, usually
   Depeche View running on the Windows machine. With DView Pro this
   tool is also the text editor, and the Windows upload batch can
   be run directly by a hotkey or extended mouse button from within
   DView via config file commands.
   $see also
      sfk fromnet -help   - print incoming network text
      sfk udpsend         - send UDP text and binary messages
      sfk udpdump         - print incoming raw UDP messages
      sfk append          - append text output to a file
      sfk echo            - for the list of possible colors
      sfk view            - more about the text viewer program
      sfk samp cppnetlog  - sample C++  code for sending text
      sfk samp javanetlog - sample Java code for sending text
   $examples
      #sfk echo "[[Red]]foo[[def]] and [[Blue]]bar[[def]]" +tonetlog
        sends colored text to a viewer on the same machine.
        Red with big 'R' sends bright color, 'r'ed sends dark.
        Type #sfk getdv<def> then #./dview -net &<def> to download
        and run the Depeche View network text viewer under wine.
      #ls -la | sfk tonetlog 192.168.1.100
        send output of a folder listing to machine .100
      #<exp> SFK_LOGTO=term,net:192.168.1.100
      #gcc mysrc.c 2>&1 | ./sfk tolog
        sends output of a command "gcc" as UDP text both
        to terminal and to a text viewer running on .100
      #<exp> SFK_LOGTO=term,net,duplex,timeout:3000
      #gcc mysrc.c 2>&1 | ./sfk tolog
        similar to above, but sends output to a viewer on the
        local machine, asking for receipts within 3 seconds.
      #<exp> SFK_LOGTO=file:log1.txt,net:192.168.1.30:5000,raw
      #sfk list mydir +tolog
        append filename list of folder mydir to log1.txt and
        send it as raw network text to machine .30 port 5000.
      #wine dview.exe -linux -net:3000,ip &<def>
        runs dview on port 3000 with sender ip display.
      #sfk tail -f mylog.txt +tonetlog .229:3000 +loop
        whenever mylog.txt changes, send changed text lines
        to a machine ending with .229 in the same subnet
        on port 3000.
SFK_LOGTO
,term
,file:
,net
localhost
duplex
toiso
nolf
recsize:
recsize=
invalid SFK_LOGTO recsize, should be 50 to 1500.
timeout:
timeout=
delay:
delay=
wrong SFK_LOGTO option for net: %s
invalid -recsize, should be 50 to 1500.
-delay
-usecr
-clear
clear
-duplex
use "netlog" to supply a hostname.
missing log filename
using file output to %s
netlog: -raw and -duplex cannot be combined.
wrong port number (use 0 to 65535)
using net output to %s:%d with delay=%d
cannot open for append: %s
nettext
cannot init UDP (rc=%d)
cannot send text (rc=%d)
ownip
<help>$sfk ip [-help], sfk ownips [-help]
   list the current machines ip address(es).
<help>$sfk split partsize inputfile [outputfilebase] [-nov[erify]]]]
   reads and splits inputfile into output files of specified size.
   if output files exist already, split asks if it may overwrite;
   specify -yes to overwrite outputs without asking.
   partsize syntax:
       100000b  ,  100k        = 100000 bytes
       2000000k , 2000m , 2g   = 2 giga-bytes
   if outputfilebase is omitted, outputfilenames will be:
       inputfile.part1
       inputfile.part2
       inputfile.part3
       ...
   if outputfilebase is given, .part1 is appended to this.
   $options
      -yes         always overwrite existing output files.
      -nov[erify]  no verify after split.
      -altsize     use different method (fseek) to read the
                   file size.
      -getsize=n[:d] before splitting, read file size n times
                   with a delay of d milliseconds (default=100).
      -verbose     be verbose about file size results etc.
      -buffer=xm   set I/O buffer to x MB (default=100 MB).
      -update      do not rewrite existing parts of full size.
                   useful when splitting repeatedly a growing
                   input file, e.g. during a download.
                   -update implies -yes.
      -dig[its]=n  set minimum number of digits used for the
                   .part extension. since sfk 1.6.5, sfk join
                   will autodetect the number of digits.
                   if output will be joined with older versions
                   of sfk then -digits must stay default (1).
      -text        split at line boundaries if possible.
Tacocat
                   cannot be combined with -update.
   $performance notes
      the operating system may cache output files, writing
      to disk in background after sfk has finished. subsequent
      split commands may run slower, even if -noverify is used.
   $examples
      #sfk split 2g c:\bigfish.avi d:\transfer\easy.avi
         splits bigfish.avi into easy.avi.part1, .part2 etc.
      to rejoin the files, use the sfk join command:
      #sfk join d:\transfer\easy.avi.part1 e:\full.avi
         joins easy.avi.part1, .part2 etc. into full.avi
-buffer
-getsize
-digits
-dig
-altsize
-update
-nov
supply a full output filename, not just a directory name.
unexpected parameter: "%s" (4)
missing split size
supply a size info like 1048100b 500k 2000m or 2g and a filename.
-text cannot be combined with -update
splitting into files of %s bytes each.
cannot get file size: %s (using seek)
cannot get file size: %s
filesize.%d (delay=%d,alt=%d): %s
no or empty input file: %s
unable to open input file: %s
skip 
input file shrunk unexpectedly, cannot update output.
in part %d of %s
%s exists, overwrite? (yes/no/all) 
unable to write: %s
file: %s
buffer overflow 1 (%d/%d)
use :  takeover %d
buffer overflow 2 (%d/%d)
cach:  takeover %d: "%.*s"
error while writing: %s (r=%d w=%d)
done: %s
%s split into %d files, %s total bytes.
[write ]
md5 = %s   %s
verification of output failed! splitting is incomplete.
<help>$sfk join inputfile.part1 [outputfilebase] [-test]
   join many input files into one output file. input files
   must have extensions like .part1, .part001 etc.
   if outputfilebase is omitted, outputfilename is just
   like inputfile, but without the ".part1" extension.
   $options
      -test   does not really join the files, but reads all
              input files, telling the overall md5 checksum.
              join -test is recommended after every "sfk split"
              command, to verify if the splitted files are ok
              and can be rejoined.
      -force  if the output file exists already, overwrite it
              without asking back.
   $see also
      #sfk split<def>   split large files into smaller ones
      #sfk media<def>   join files of any name by using sfk
                  select -sort ... +media -joinraw
                  without checksum verification.
      #sfk snapto<def>  join text files into one document
   $examples
      #sfk join d:\transfer\easy.avi.part1 e:\full.avi
         joins easy.avi.part1, .part2 etc. into full.avi
      #sfk join -test d:\transfer\easy.avi.part1
         simulates joining (does not write any output file),
         and tells if the input files are ok, by checksum.
unexpected parameter: "%s" (5)
copypart
<help>$sfk partcopy infile offset length outfile [offset2] [-yes]
$sfk partcopy infile -allfrom startoffset outfile ...
$sfk partcopy infile -fromto startoffset endoffset outfile ...
   reads a block of bytes from infile at specified offset,
   writing them into another file. if offset2 is specified,
   outfile is not created, but the bytes are used to overwrite
   other bytes within the output file.
   by default, the command $simulates<def>, checking file lengths
   but not copying any data. add -yes to really copy contents.
   $negative offsets<def> can be used, to specify positions
   relative to the $file end<def> instead of file start.
   if output offset2 + length is larger than output file size,
   the output file is extended. use -noext to avoid this.
   length syntax:
       100000   ,  100k        = 100000 bytes
       2000000k , 2000m , 2g   = 2 giga-bytes
   $options
      -quiet    do not print number of copied bytes.
      -verbose  tell how offsets and lengths are calculated.
                type directly after "partcopy" for all infos.
      -fromto   use this if you don't want to specify offset
                and length for the input, but a start and end
                offset (with length being end minus start).
      -allfrom  copy all from start offset, until end of file.
      -noext    do not allow an extension of the output file,
                stop with error if writing beyond output end.
      -append   if given after output filename, data is added
                to the end of the output file.
   $see also
      $sfk media<def>     keep or cut multiple parts of a file
      $sfk hexdump<def>   show binary file contents as hexdump
      $sfk hexfind<def>   search data in binary files
      $sfk hextobin<def>  convert hexdump to binary
   $examples
      #sfk partcopy first.dat 10000 50 second.dat 500000
         copies 50 bytes from first.dat at offset 10000 into
         second.dat (which should exist) at offset 500000
      #sfk partcopy first.dat -fromto 0x2710 0x2950 second.dat
         input start and end offset in hexadecimal numbers,
         output file is created (no output offset given).
      #sfk partcopy in.txt -allfrom 1000 out.txt -append
         take from in.txt all data from offset 1000 until end
         and append that to out.txt.
      #sfk partcopy in.dat -fromto -1000 -900 out.dat -500
         take from in.dat all bytes from end minus 1000
         until end minus 900, i.e. a 100 bytes block, and
         write this into output at end minus 500 bytes.
         (type -verbose after partcopy for details.)
-fromto
-allfrom
length
append to end of output file.
unexpected parameter: "%s" (10)
missing input filename
missing input offset
no such input file: %s
mapping source offset: %s = %s %s
mapping copy length  : %s = %s - %s
mapping source end   : %s = %s %s
end offset is lower than start offset
invalid copy length: %s
no such output file: %s
output offset %s is larger than output file (%s)
input file %s has a size of %s bytes, cannot copy requested part.
would copy beyond end of output file (%s).
output file has a size of %s bytes and will be extended.
unable to seek within source file
unable to seek within target file
copying %s bytes, 
from input offset %s 
to %s, 
to target offset %s
unable to fully read part from %s, copy failed
error while writing: %s   
$[add -yes to really copy data.]
%s bytes copied.
<help>$sfk media infile.mpg -keep n1-n2 -cut n3-n4 -tofile out.mpg
$sfk media infile.m3u -keepbook -tofile out.mpg
$sfk list mydir .m3u +media -keepbook -to outdir<sla><run>base.mpg
   cuts mpeg2 video or other binary file(s), by keeping or
   dropping parts given as absolute byte positions in the file.
   sfk media $does not interpret, decode or encode any video data<def>,
   and knows nothing about the file format. it simply $copies
   $blocks of bytes<def>, which $may or may not work<def>, depending on the
   file format (mpeg2 is best), media player (VLC is best) and
   installed codecs of the operating system. This command is
   $not suitable<def> for mpeg4 or any format using file headers.
   Splitting or reducing an mpeg2 file usually keeps the result
   playable in media players. Joining multiple mpeg2 files into
   one file strictly requires post processing by ffmpeg,
   to recalculate PCR time stamps required for playback.
   $parameters for cutting and post processing
     -keep n1-n2   keep this part of the file, from byte offset n1
                   until before n2 (excluding offset n2), and cut
                   everything before and after. keep must be given
                   before any "cut" parameters.
                   n1 means an absolute byte position like 12345.
                   one "keep" can be followed by multiple n-n.
     -cut n1-n2    cut this part. multiple cut parameters can be
                   given, and they can refer to an area within
                   a "keep" range.
     infile.m3u    use a VLC player bookmark file instead of
                   specifying file and positions manually.
                   takes only the last entry in that file.
                   file must contain an even number of start/end
                   positions of sections to keep.
     -keepbook     only with .m3u files: keep all parts
                   marked by a bookmark at start and end of part
     -joinraw      join all input files or parts into one output.
                   with mpeg video, the output file will NOT work
                   correctly in players due to wrong timestamps
                   and therefore requires post processing like:
                   ffmpeg -i in.mpg -target pal-dvd -c copy out.mpg
                   (without -target, the output will have no sound)
     -fix parm     create a temporary file (with -tmp in filename)
                   then run ffmpeg to fix the output file by re-
                   rendering timestamps. "parm" is passed to ffmpeg
                   as is, except for two special values which are
                   extended like:
                      pal-dvd  = -target pal-dvd  (for pal output)
                      ntsc-dvd = -target ntsc-dvd (for ntsc output)
                   requires ffmpeg 1.2 in the PATH. temporary files
                   are cleaned automatically, use -keeptmp to keep.
     -joinfull p   run joinraw and -fix p in one go. required to
                   produce mpeg2 video suitable for playback.
     -tmpdir d     specify a folder to use for temporary files,
                   and create unique filenames within.
     -keepall      keep whole content of input file(s). used only
                   with -joinraw.
   $note:
      #- all output files are overwritten without asking back,
      #  including temporary files. check the simulation output.
      #- check free disk space by "sfk space" before processing.
      #  options -fix or -joinfull will use double disk space.
   $general options
      -tofile f     write output to a single file with name f
      -to outmask   write multiple input files to output names
                    given by a mask, like -to outdir<sla><run>file
                    "sfk help opt" for details.
      -movesrcto x  after processing, move every video input file
                    to an output folder x. move is done by rename,
                    so x must be on same file system as input.
                    if an output file of same name exists already
                    then add option -force to overwrite.
      -yes          really create or overwrite output file
      -quiet        do not print part and progress infos
      -verbose[=2]  tell more details about what is done
   $recommended process for video cutting
      1. download the VLC media player installer,
         run the tool and open an mpeg2 .mpg file.
      2. select Playback / Custom bookmarks / manage (CTRL+B).
         for every section to $keep<def>, create a bookmark
         at the $start<def> and $end<def> of that section.
      3. make sure there is an $even<def> number of bookmarks.
      4. select Media / Save Playlist (CTRL+Y), select file type
         M3U (not m3u8) and save, e.g., to cut01.m3u
         (if you used the VLC installer, it will remember M3U
          as the preferred export type.)
      5. #sfk media cut01.m3u -keepbook -tofile out.mpg
      6. if you process further files in the same VLC session,
         the M3U files may contain references to many files,
         but only the last (newest) entry is used.
   $see also
      $sfk partcopy<def>  - copy a single part of a file
      $sfk space [d]<def> - tell free disk space available
                      in current of given directory d
   $examples
      #sfk media in.mpg -keep 100000-200000 -cut 150000-160000
       #-tofile out.mpg
         keep area from offset 100000 to 200000 (with a length
         of 100000 bytes) except for 10000 bytes inbetween.
      #sfk media in.mpg -keep 120578-301436 518297-783591
       #-tofile out.mpg
         keep the two sections and drop the rest.
      #sfk media in.m3u -keepbook -tofile out.mpg
         keep areas listed in the bookmark M3U file.
      #sfk select mydir .m3u +media -keepbook -to out<sla><run>base.mpg
         execute all .m3u files from mydir, write output
         files to a folder out, with the same relative name
         as the input .M3U, but with an .mpg output extension.
      #sfk select n:\dvd1\part1.vob n:\dvd1\part2.vob
       #+media -joinraw -tofile out.mpg
         join two .vob files into one out.mpg without any
         modifications. out.mpg will need post processing
         before it can be used in a media player.
      #sfk sel -sort d:\ .vob +media -joinfull pal-dvd
       #-tofile out.mpg -tmpdir c:\tmp
         join all .vob files of a PAL dvd, sorted by name,
         into one out.mpg and call ffmpeg to fix timestamps.
         uses a temporary file in c:\tmp.
      #sfk sel -sort d:\ .vob +media -joinfull
       #"-target pal-dvd -map 0:0 -map 0:2"
       #-tofile out.mpg -tmpdir e:\tmp -keeptmp
         similar to above, but explicitely passing several
         parameters to ffmpeg, selecting dvd output and to
         mix channels 0:0 (e.g. video) and 0:2 (e.g. an
         audio track with alternative language). temporary
         file is stored on another drive and kept, in case
         post processing fails and must be done manually.
-joinraw
-joinfull
-fix
-movesrcto
directory not found: %s
-keepbook
-scan
too many keep or cut parameters
-keepall
-keepall is not allowed after other -keep or -cut
.m3u
unexpected parameter: "%s"
ffmpeg
ffmpeg not found within PATH, please install it first.
use -tofile for single file processing
%d time stamps cleared.
%d files are invalid or missing.
.mpg
to fix timestamps, post process output like:
ffmpeg -i %s -codec copy %s-fixed.%s
%u files would be processed, with %d mb output.
not enough disk space for file: %s
processed %u files, with %d mb output.
fuzz
<help>$sfk fuzz infile outfileBaseName [loops command]
   change file contents at random, by intention, to test programs
   for errors in its input file processing. a maximum of 10 percent
   of the data is modified.
   outfileBaseName is the output filename WITHOUT extension.
   the output filename gets the same extension as the input,
   plus an optional prefix if loops are used.
   $optional parameters:
      loops  run the fuzzing loops times, each time executing
             a user defined command. the command string MUST
             contain the phrase "$$outfile" which is replaced
             by the current fuzzed output file.
             the amount of modified data is near-zero in the first loop,
             and then incremented per further loop, up to max. 10 percent.
   $options
      -verbose  tell in detail which byte (offsets) are modified.
   $examples
      #sfk fuzz in.dat tmp\test 10 "myprog.exe $$outfile"
          run 10 fuzzing tests, all output to console.
      #sfk fuzz in.dat tmp\test 10 "myprog.exe $$outfile >$$outfile-report.txt 2>&1"
          run 10 fuzzing tests, output to report files in tmp.
unexpected parameter: "%s" (12)
missing user command
$outfile
missing phrase $outfile in user command
%s-%05u%s
xor offset %05xh with %02xh
FUZZ.DONE density=%03d fuzzed=%05d %03d = "%s"
%s bytes written, %d modified into %s
webreq
<help>$sfk webrequest [options] http://host[:port]/path
$sfk webrequest host:port path [header1 header2 ...]
   send a simple http text request and receive a text reply.
   any text parameter after host:port is sent as a separate
   text line (http header line), with CRLF being appended.
   sfk webreq does not support http proxies and chunked
   transfer encoding. use sfk wget if you need this.
   $options
      -verbose  show exactly what is sent to the server,
                with each line prefixed by "<".
      -quiet    do not print reply header lines.
   $see also
      #sfk wget<def>  for text and binary file downloads.
      #curl<def>      powerful web request and download tool.
   $examples
      #sfk webreq http://127.0.0.1/
         send a simple GET for the root page.
      #sfk webreq 127.0.0.1:80 / "Host: foobar.com:80"
         the same, but also add a Host header line.
         the "/" is converted into a GET ... HTTP1.1 line.
      #sfk webreq 127.0.0.1:80 "GET / HTTP1.1"
         similar, but with the first request line
         explicitely defined by the user.
-nopath
incomplete url: %s
missing host:port
no request string or chain input data given.
Host: %s
Host: %s:%d
wrong url: %s
GET %s HTTP/1.1
host:
wget
getdv
<help>$sfk wget [options] url [outfile|outdir] [options]
   download content from a given http:// URL.
   an output filename or directory can be specified.
   existing output files are overwritten without asking back.
   $options
      -proxy      hostname:port of a proxy server. from within a company
                  network, it is often required to connect through proxies.
                  alternatively, set the environment variable SFK_PROXY :
                    #export SFK_PROXY=myproxyhost:8000
                  to find out what proxy your browser is using, see
                  - Firefox: tools/options/advanced/network/settings
                  - IE: tools/internet options/connections/lan settings
      -path2name  include web path in generated output name,
                  to create unique names on multiple downloads.
                  this option is default on chained processing.
      -fullpath   recreate the whole web path within output dir.
      -nodom      do not include domain name in output name.
      -nopath     do not include any path and domain information
                  within the output names. will not work if URL
                  does not contain any relative filename.
      -quiet      or -noprog shows no download progress indicator.
      -addext     always add a filename extension like .txt, .html
                  or .dat even if the URL has no such extension.
   $limitations:
      although sfk wget can download a list of URLs, it is not
      a real webpage downloader/archiver, as this would require
      the conversion of html pages to adapt contained links.
   $chaining support
      output filename chaining is supported.
   $see also
      #sfk webreq<def>   send a simple web request with instant
                   result output to terminal
      #wget<def>         linux command for file download
      #curl<def>         powerful web request and download tool
   $examples
      #sfk wget -proxy myproxy:8000 http://foobar.com/x.zip foo.zip
         download x.zip, writing the content into a file foo.zip,
         connecting through a proxy server myproxy on port 8000.
      #sfk filt urls.txt +wget mydir
         if urls.txt contains a list of http:// URLs, load it
         and download all contents into mydir. the output names
         will include path information found in the source URL.
      #sfk filt urls.txt +wget -fullpath mydir +list -big
         the same as above, but create the whole dir structure,
         and then list biggest files from the downloaded.
      #sfk wget -quiet=2 http://server/info.xml tmp.txt +ffilter -nofile
         download info.xml from server, write it as file tmp.txt
         and instantly print the tmp.txt content to terminal
         without any status messages or filename infos.
WGet
http://stahlworks.com/dview.exe
dview-linux.exe
-web
-path2name
-fullpath
-path2path
-nodom
-usecache
-addext
$download:<def> Depeche View Lite
$from URL:<def> %s
missing URL
Please download manually from %s
chmod +x "%s"
cannot set x attribute (%s)
cp "%s" dview
cannot copy %s to "dview"
done : ./dview (copy of %s)
note : please copy "dview" into a folder listed in your PATH.
       PATH = %s
more than 1 input URLs, but no existing output folder given.
int. #9529726
wrong chain input, need filenames.
filesys
fsinfo
diskspace
freespace
<help>$sfk [-help] diskspace [dirname]
   show disk space informations.
   a folder name can be specified which relates
   to a specific volume or hard disk.
   $options
      -byte[s]  all size infos in bytes
      -tab[s]   pure values, tab separated
      -bin[ary] calculate with binary megabytes
                of 1048576 bytes each.
   $aliases
      $space<def>     - same as diskspace
      $freespace<def> - tell only free space
   $examples
      #sfk space /thedir
         tell total and free MB of the file system
         used in /thedir. This can be a different
         volume or medium than the current directory.
unable to read file system infos.
total%s=%s	free%s=%s
"%s"	"%s"	%s	%s
filesys="%s" volume="%s" total%s=%s free%s=%s
<?php
   // example script for storing an uploaded file.
   // for some safety, this accepts only files
   // named test*.dat without any given path.
   // files are stored in same folder as this script.
function dostop($s) {
   header("HTTP/1.0 500 Internal Error");
   die("error: ".$s);
   if (!isset($_FILES)) dostop("1");
   if (!isset($_FILES["file"])) dostop("2");
   if (!isset($_FILES["file"]["error"])) dostop("3");
   $aUpload = $_FILES["file"];
   if ($aUpload["error"] > 0)
      die("upload error: ".$aUpload["error"]);
   $sTmpFilename = $aUpload["tmp_name"];
   $sTargetName  = $aUpload["name"];
   $sSize        = $aUpload["size"];
   // Anyone knowing the script's web address may try to
   // upload files, therefore block paths in filenames:
   if (strpos($sTargetName, "/") !== false) dostop("4");
   if (strpos($sTargetName, "..") !== false) dostop("5");
   if (!strcmp($sTargetName, ".") !== false) dostop("6");
   // furthermore only accept predefined filenames "test*.dat"
   if (strncmp($sTargetName, "test", 4)) dostop("7");
   if (strpos($sTargetName, ".dat") === false) dostop("8");
   print("type: ".$aUpload["type"]."<br>\n");
   print("size: ".$aUpload["size"]."<br>\n");
   // store file in same folder as this script
   $sOwnLocation = $_SERVER["PATH_TRANSLATED"];
   $iPath = strrpos($sOwnLocation, "/");
   if ($iPath === false) dostop("9");
   $sAbsTarget = substr($sOwnLocation,0,$iPath+1).$sTargetName;
   move_uploaded_file($sTmpFilename, $sAbsTarget);
   print("success: stored: ".$sTargetName." ($sSize bytes).\n");
wput
<help>$sfk wput [options] http://host[:port]/path filename
   POST a file to a webserver.
   $options
      -script     print PHP example script that handles a file
                  upload on a web server. Be aware that anoyone
                  may post to this script if the address is known,
                  uploading any content! Therefore the example script
                  contains some fundamental checks, accepting only
                  filenames matching a pattern, and without a path.
                  You may also want to check configured upload limits
                  (maximum file size) at your web server.
      -verbose    print server return code as well as reply lines
                  starting with "error: " or "success: ".
      -verbose=2  print whole server reply.
      -quiet      show no progress indicator.
   $return code
      0   if web server responded with 200 OK
      >0  else the web server code, e.g. 404
   $error display
      the server must reply with code 200 OK, otherwise
      an error is shown. if the server reply also contains
      a line starting with "error: " then the error text
      is included in the printed error message.
   $see also
      #sfk wget<def>  for text and binary file downloads.
   $examples
      #sfk wput http://myhost/dopost.php test1.dat
         send the file test1.dat to a php script
         which then can use move_uploaded_file etc.
      #sfk wput -script +tofile postrcv519.php
         write upload receiver script for a web server,
         with a non-generic name to avoid automatic
         detection by scanner scripts.
-script
%.*s
missing filename to send.
---------------------------315712991614773
--%s
Content-Disposition: form-data; name="file"; filename="%s"
Content-Type: application/octet-stream
--%s--
POST /%s HTTP/1.1
Host: %s
User-Agent: %s
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: close
Content-Type: multipart/form-data; boundary=%s
Content-Length: %d
failed to fully send
error: 
success: 
failed to fully send: %s
send failed (RC %d%s%s): %s
testattr
sfkattr %08X:
   %c%c%c %c%c%c %c%c%c
   uid=%d gid=%d stk=%d
fileinfo
cannot read: %s
mode=%08Xh inode=%u device=%u rdev=%u
   S_IFDIR  %d
   S_IFCHR  %d
   S_IFREG  %d
   S_IREAD  %d
   S_IWRITE %d
   S_IEXEC  %d
   S_IFIFO  %d
   S_IFLNK  %d
   S_IFBLK  %d
   S_IFSOCK %d
   owner    %s
<help>$sfk filetime [opts] filename
   print times available for a file or directory.
   $main options
      -mtime    print modification time (default)
      -atime    print access time
      -all      print all available times
      -utc      UTC/GMT instead of local time
      -flat     print times like 20130413 065127
      -flat2    print times like 20130413065127
      -tab      separate output by TAB characters
      -full     full technical view with all times,
                utc, unix and windows timestamps
      -noname   do not print filename in output
   $see also
      #sfk touch<def>  change times of a file
      #sfk list<def>   list files with time and size
   $examples
      #sfk filetime myfile.txt
         print modification time for myfile.txt
      #sfk filetime -all myfile.txt
         print all times for myfile.txt
      #sfk filetime -full myfile.txt
         print all times as local, utc and
         internal system timestamp values.
      #sfk filetime -all -tab -flat2 mydir .txt
         list modification and access time for
         all .txt files in folder mydir as tab
         separated data, with each date and time
         combined as a flat timestamp.
-mtime
-atime
-ctime
-flat2
-plain
loadlib
loaddll
readtest
%d lines in %s msec
md5test
test digest: %02X %02X %02X %02X
noop
sync
xcopy
xsync
<help>$sfk copy srcRoot dstRoot [-dir subdir1 subdir2] [-file .ext1 .ext2]
$sfk sync srcRoot dstRoot [-dir subdir1 subdir2] [-file .ext1 .ext2]
   Extended tree copy (experimental).
   Directory tree copy, update copy and synchronization.
   If destination does not yet exist, whole content of source is copied,
   #INCLUDING HIDDEN AND SYSTEM FILES.<def> If destination already exists,
   only updates are copied.
   #Symbolic links are NOT kept<def>, but their content is duplicated. If this
   is a problem, use a copy command of your operating system instead.
   $copy<def>   copies files from source to destination if the target file
          doesn't exist yet, or if the source is NEWER than the target.
          copy will NOT copy OLDER files over NEWER files. furthermore,
          files that exist in destination but not in source are not removed,
          so copy will ADD and REPLACE, but not DELETE.
   $sync<def>   nearly same as copy, however files that exist in destination
          but not in the source are called STALE files, and are DELETED
          if their age is >= %d days. USE WITH CARE. If you specify wrong
          folders or file masks, this may delete files unintentionally.
          Take a close look at the output of the simulation mode, which
          is active by default.
   -mirror       with sync, copy even older files from source over destination.
   -wipe         delete stale files now (ignoring file ages).
   -nocopy       with sync, do not copy files, run only delete cleanup.
                 can be used if you want copy files first with a different
                 copy program, and then run an sfk sync-delete.
   -diff         list files in destination which have been modified after
                 last copy. Whenever you get a short info "n differing files
                 in dest", add -dif to get their names listed.
   -since        or -sincedir/dif/add/chg copies only files selected by age
                 or difference to another directory. "sfk list" for details.
   -nohidden     exclude hidden and system files from copy.
   -nofollow     do not follow symbolic link directory contents.
   -stat         in simulation: do not list filenames, only size statistics.
   -keepstale=n  change the 30 days limit for stale files until deletion.
   -noinfo       do not comment on skipped files.
   -rel[names]   only with input chaining: strips source root directory names
                 from filenames. if not selected, absolute paths starting
                 like C:\ or /tmp will be stripped automatically.
                 some chain commands may provide filenames without separate
                 directories, in this case -relnames will produce an error.
   -ltarg        always list target filenames (instead of source filenames).
   -deep         verify content of files with same time and size. this takes
                 much time, but is useful if you suspect that some hardware,
                 esp. usb sticks, sometimes damages files during write.
                 in this case, add an extra sfk sync -deep call (without -yes),
                 just to have the files scanned after copy (with usb sticks,
                 remove and re-insert them first to clear all file caches).
   $special options for use with unreliable media (usb sticks):
   -sign[meta]   write signature databases for later verify, in a subdir
                 "zz-shadow-01" within the target root directory.
   -save[meta]   write signature databases AND redundant copies of copied
                 files in destination, within the "zz-shadow-01" dir.
   -load[meta]   reads meta informations from source directory, verifies if
                 source files have been modified, and if so, takes redundant
                 shadow copies instead.
   -shadow=5m    limit creation of shadow files to small files < 5 mbytes.
   files with whole content being copied are listed in default color.
   files that will be deleted during sync are listed in <warn>warning color<def>.
   files with differing time but equal content are listed in <time>time color<def>.
   $completeness and efficiency:
   -  under Windows, SFK uses the CopyFileEx API function, which should
      be able to copy most file attributes and contents as good and fast
      as the XCopy command provided with Windows.
   -  under Linux, no native copy function is available, therefore SFK may
      not be able to copy all attributes, access rights and timestamps
      of the original files. Furthermore, copying can be slower than "cp".
   -  Directory attributes, access rights and time stamps may not be
      completely reproduced both on Windows and Linux.
   -  Changes from/to Daylight Saving Time, differing time zones or copies
      between FAT and NTFS may always copy files which were copied already.
      this is a general problem with all copy commands.
   $using file system views:
      if you want to specify many directory trees and dir/file masks,
      you may create a fileset, containing a list of directories.
      type "sfk help fileset" for details.
   #NO WARRANTY FOR DATA INTEGRITY.<def> SFK copy is very convenient to use,
   but if you need to copy massive amounts of highly important data, it is
   recommended to use the original copy command of your operating system.
   Always keep backups of important stuff. After large copies, do some spot
   checking if important files were really copied without modifications.
   Always double-check the reliability of external media like USB sticks,
   e.g. by creating md5 lists (see "sfk md5gento").
   $examples
      #sfk copy c:\work d:\arc\work -dir . <not>\tmp\ <not>\save\ -file <not>.bak
         copy directory tree c:\work to d:\arc\work, excluding all dirs
         called tmp or save, including all files except .bak files.
      #sfk copy d:\proj v:\team\proj -dir foosys\include foosys\source tools
         within directory tree proj, copy subdirectory trees foosys\include,
         foosys\source and tools, including all files therein.
      #sfk filter testfiles -+foo +copy \tmp
         copy all files from testfiles containing "foo" to \tmp.
      #sfk copy work archive -fileset myflist.txt
         copy the files listed in myflist.txt from work to archive.
         note that "-yes" must be specified directly after "copy".
         see also "sfk help fileset".
      #sfk list mydir .txt .doc code.cpp +copy d:\save
         copies all .txt, .doc and code.cpp files from within mydir,
         including all subdirs, to d:\save. ALSO copies mycode.cpp,
         subcode.cpp.1 etc. as "code.cpp" ist just a pattern.
      #sfk list -sincedir mydir1 -dir mydir2 -subdir <not><sla>save<sla>
       #-file <not>.bak +copy mydir3
         copies all files that were added or changed between mydir1
         and mydir2 to mydir3, excluding files in sub folders "save",
         and excluding .bak files (type whole command in one line).
         type "sfk list" for more on -sincedir, -sinceadd or -sincedif.
      #sfk sync -save x:\ e:\ -dir src -wipe
         copy directory "src" from X: onto usb stick (E:), with checksums
         and shadow files, instantly deleting stale files that are found
         within E:\src but not within X:\src .
      #sfk verify e:\ -all
         verifies files on the stick (leave out -all to check only the ones
         copied most recently). you must remove and re-insert the stick before
         running the verify, otherwise data is taken from cache, leading always
         to successful verifies even if files are corrupted.
      #sfk sync -load e:\ z:\ -dir src
         copies files from stick to hard disk (Z:), verifying all source files
         before copy. files that fail verification are replaced by shadows.
      #sfk copy -save x:\ e:\ -dir src -since today
         copies today's changed or added files from X:\src to E:\src.
-mem
-mir
-noca
-del
-wipe
-nodel
-noco
-dif
-cache
-style
-link
-nobuf
-decrypt
-save
-sign
-load
-shadow
-shadow=
-check
-checksigns
-nodirtime
no such file or directory: %s
missing source directory or file.
 or file
missing target directory%s.
zz-sign
specify -load OR -check, but not both
metadb directory not found: %s
NOTE: signature database found. say -save to write shadows.
-shadow requires -signto or -check
-nocopy not supported with single file operation.
%s => %s
$[no differences.]
would copy
copied
$%s %u files, %u dirs.
$%s %u files, %u dirs (%u/%u attribs
$, %d verified
$, <err>%d failed
 <time>%s mb.<def>
 <time>%s kbytes.<def>
 <time>%s bytes.<def>
would delete
deleted
%s%s %d files, %d dirs.
%s$(%d differing files in dest)
%sskipped %d hidden files, %d dirs.
 %d signatures
, %d shadows
signs 
 %d signatures failed
, %d shadow fallbacks
%s%d %snot found
%s%d %schecked.
%d stale but recently edited files are kept until deletion limit (%d days).
verify
syncver
<help>$sfk sfk verify [-cleanup] [-all] rootdir
   verify contents of directory by a given file meta database,
   as it is created by sfk copy -sign ...
   $options
      -cleanup     cleanup records that fail to verify, and/or
                   update records with timestamp mismatches.
      -all         by default, only records that have been updated
                   recently are checked. say -all to check all.
   $see also
      sfk copy
   $examples
      #sfk verify e: -all
         verify contents on E:, which could be an USB stick.
-cle
unexpected parameter: "%s" (7)
missing root directory name
%s contains no recently updated files. say -all to check all %d entries.
recently updated 
%s %d %sfiles verified.
%s%d %schecked
, %d skipped
metadb cleaned up, %d records written.
rensub
<help>$sfk rename dirname "/fromtext/totext/" [to outdir]
$sfk rename -dir mydir -file .txt -pat "/fromtext/totext/"
   flexible multi file rename using rename expressions.
   $handle with care.
   - multi file rename may cause problems in folders which are
     controlled by version control systems like cvs or svn,
     or within workspaces of programs that keep file references,
     like video editing software or IDE's.
   - keep backups of original files in case that output
     filenames are unexpected or cause conflicts.
   $to make things more safe, by default
   - sfk rename runs on the given folder only, without sub folders.
     use option -withsub to include sub folders.
   - sfk rename runs in simulation mode, previewing changes without
     modifying anything. add option -yes to apply changes.
   $syntax of /fromtext/totext/
   rename expressions are a subset of simple expressions, supporting
   an extra symbol '##' within totext. slash patterns are not enabled
   by default but require an option -spat. instead of "/" around
   /from/to/ any unique char can be used, like in _fromtext_totext_
   $within /fromtext/ you may use:
      $*<def>            for any number of chars (0 or more)
      $?<def>            for exactly one character
      $[n chars]<def>    for exactly n characters
   $within /totext/ you may use:
      $[part1]<def>      fill in part  1 extracted from name
      $[parts 1,3]<def>  fill in parts 1 and 3
      $[parts 1-3]<def>  fill in parts 1 to  3
      $##1<def>           fill in part  1, same as [part1]
      $##10<def>          fill in part 10
      $##<def>            without digits: fill in next part
      $##5####<def>         fill in parts 5,6,7
   $with option -spat only:
      $\[<def>           search or fill in the '[' character
      $\] \## \* \?<def>   same for characters ] ## * ?
      $\\ <def>          search or fill in the backslash '\'
   $extra parameters
      to outdir    after rename, move the file to folder outdir
                   which must be on the same partition.
   $options
      -pat x       to specify /from/to/ pattern after
                   long -dir ... -file ... parameters
      -spat        enable slash patterns like \xnn
      -exact       fromtext must match whole filename,
                   not just a part of it.
      -verbose     show part numbers within /from/ text
   $aliases
      #sfk rensub<def>   same as "sfk rename -withsub"
   $examples: short syntax step by step
      #sfk rename mydir
         list all files of mydir (nothing is changed)
      #sfk ren mydir "/-1540-*.mts/"
         list files in mydir with "-1540-" in their
         filename, followed by any characters, until .mts.
         sfk will show an info text telling about the part
         numbers the search mask (fromtext) is made of.
      #sfk ren mydir "/-1540-*.mts/[part1]News[part3]/"
         same as above, but extended to change the wild-
         card part "*" of a match to "News".
      #sfk ren mydir "/-1540-*.mts/##News##3/"
         same as above, but shorter to type. "##" without
         a number takes part1, ##3 takes part 3.
      #sfk ren mydir "/-1540-*.mts/##News##3/" to news
         after rename move the file to folder "news".
         finally add -yes to apply filename changes.
   $examples: flexible syntax step by step
      #sfk rename -dir mydir -file chan
         list files of mydir having "chan" in their name
      #sfk ren -dir mydir -file chan -pat "/-1540-*.mts/"
         list chan files in mydir with "-1540-" in their
         filename, followed by any characters, until .mts
      #sfk ren -dir mydir -file chan -pat "/-1540-*.mts/##News##3/"
         within filenames of mydir containing parts
         -1540-, then anything, then .mts, like in:
            Channel3-01312015-1540-BizInfo_Any.mts
         change the second part "*" into "News":
            Channel3-01312015-1540-News.mts
   $further examples
      #sfk rename . /.mts/.mpg/
         change all .mts to .mpg in current folder
      #sfk ren -dir mydir -file .txt -pat "/foo/bar/"
         replace foo by bar in all .txt filenames within mydir
      #sfk ren -dir mydir -file "*-????2015-"
       #-pat "/-[2 chars][2 chars][4 chars]-[4 chars]-*.
       #/-[parts 4,2,3]-[parts 6-9]/"
         in folder mydir change date string in files like: [20]
            Channel3-01312015-1540-BizInfo_Any.mts
         to a format with year first:
            Channel3-20150131-1540-BizInfo_Any.mts
      #sfk ren -dir mydir -file "*-????2015-"
       #-pat "/-[2 chars][2 chars][4 chars]-[4 chars]-*.
       #/-##4##2##-##6######/"
         same as above, only shorter. ##6###### means to take
         part 6 and then the three following parts 7,8,9. [21]
try to add -enddir after initial -dir ... -file ...
-exact
only one /from/to/ expression is supported.
invalid pattern: %s
missing end separator '%c' on pattern: %s
if this is a /from/ or /from/to/ pattern then it must end with '%c'
if this is a file or dir parameter then use -dir ... -file ... instead
$[simulating selected files:]
$[simulating rename:]
$MASK:<def> 
$PART:<def> 
%d redundant output filenames found.
%d existing  output filenames found.
%d missing output directories.
%d bad output directories are files.
-pat 
$[add %s"/from/" or "/from/to/" to continue.]
$[extend to full "/from/to/" pattern to continue.]
getcwd
<help>$sfk getcwd
   print the current working directory.
   $examples
      #sfk getcwd +filter -form "workdir is $$col1"
         print workdir with some additional text.
<help>$sfk cd targetdir +nextcmd ...
   change the directory for the next chain command.
   does NOT change the directory of the command shell.
   $options
      -echo     echo the command on execution
   $examples
      #sfk cd testfiles +list -time -size .
         enter directory "testfiles", then list all files.
missing dir name for cd
missing chain commands after "cd"
cd can change the dir for subsequent chain commands only.
to change the dir of your command shell, use "cd" but not "sfk cd"
cannot cd into: %s
<time>cd %s<def>
mkdir
<help>$sfk mkdir path
   create a directory, or directory tree.
   $options
      -echo     echo the command on execution
   $examples
      #sfk mkdir tmp\foo\bar
         create directory bar within foo within tmp.
missing dir name for mkdir
<time>mkdir %s<def>
linelen
strlen
<help>$sfk linelen [options]
$sfk strlen phrase
   tell the length of text lines supplied via stdin
   or through command chaining, or tell the length
   of a single string.
   the result is printed to terminal, and supplied
   as a return code to the command shell.
   "sfk strlen" does not accept any options,
   allowing to supply a string starting with "-".
   $options
      -i         read lines from standard input,
                 tell the longest line length.
      -min       tell the minimum, not the maximum length.
      -minmax    tell both min and max length.
      -verbose   tell minmax, line numbers and line text.
                 you may also type -all or -ver
      -quiet     do not print anything to terminal,
                 just provide the shell return code.
   $limitations
      if the input contains stream text, i.e. text where
      linefeeds are used only for paragraphs (not lines),
      the result will be a paragraph length, and it can be
      completely wrong if there are paragraphs longer than
      4000 characters approx.
   $examples
      #sfk strlen "foo bar"
         results in a string length of 7.
      #sfk filter foo.txt +linelen -all
         list the shortest and longest line of foo.txt
-max
-minmax
only one phrase can be supplied.
missing phrase, chain text or -i option.
min	%d	%d	"%s"
max	%d	%d	"%s"
%d	%d
getlines
failed
>%s<
mdfuzzy
%02x 
mkcd
<help>$sfk mkcd cdname
   creates an alias batch file, remembering the current directory.
   this batch can be used later to re-enter the remembered directory.
   #example:
   1. you are currently working in
         C:\Documents And Long Complicated Paths\Users\You\Work
   2. now type:
         #sfk mkcd cd1
            which saves above path in a command "cd1".
   3. you go into a different directory, e.g.
         C:\Another Project\Nested Dirs\Work2
   4. now type:
         #sfk mkcd cd2
   => now, anytime you type:
         #cd1
            you jump instantly into
               C:\Documents And Long Complicated Paths\Users\You\Work
      and anytime you type:
         #cd2
            you jump instantly into
               C:\Another Project\Nested Dirs\Work2
   if the creation of the alias fails, please type "sfk alias" to read
   about the required directories and access rights.
cannot find location of sfk within PATH.
unable to find path of sfk
%s exists, overwrite? (yes/no) 
cannot write batch file: %s
cd "%s"
batch created: %s
type ". %s" to reenter %s
<help>$sfk alias [-list|-del|-ren] [shortname] [=] [command]
   create, list, delete or rename command aliases. aliases are
   short command names selected by yourself to save typing effort.
   $sfk alias shortname = command ...
      create an alias. this actually creates a small batch file
      in the directory where sfk itself is located.
      requirements:
      #-  the sfk executable has been copied into some directory x.
      #-  this directory x must be in your PATH.
      #-  you must have write permission for directory x.
      #-  directory x is NOT the current working directory ".".
      if any of these requirements is not met, the command will fail.
      for example, if sfk is located just in your current
      working directory ".", copy sfk into a different
      directory of the PATH, and then start aliasing.
   $see also
      sfk mkcd : create an alias remembering the current directory.
   $examples
      #sfk alias list = "sfk list"
         creates the alias named "list". from now on, you can
         type "list" instead of "sfk list".
      #sfk alias wherc = "sfk list -arc . .jar filter -+\$$1.class"
         creates alias "wherc", searching for class files in jars.
         after the alias exists, command "wherc Foo" executes the
         commands from above, listing all class names with "Foo".
      #sfk alias copytoday "sfk run \"copy <run>file c:\tmp\" . -today"
         copy all files changed today to c:\tmp. if double quotes "
         should be part of your command, they must be escaped as \"
      #sfk alias ec "vi /home/myuser/tools/\$$1"
         provided that /home/myuser/tools is in your path, creates
         a command "ec" to instantly edit further commands.
      #PARAMETER LIMITATION:<def> note that the created batch files
      may accept only a maximum of 9 parameters. they must be typed
      with back slash \$$1 to \$$9 and will appear as $$1 to $$9
      in the created batch script.
      Further parameters may be ignored, or cannot be addressed.
      #USE SURROUNDING QUOTES<def> whenever your command string contains
      special characters like %% \ ! otherwise these chars may be
      removed (or misinterpreted) by the command shell.
   $sfk alias -list
      list all existing aliases. this actually scans the directory
      where sfk is located for batch files containing aliases.
   $sfk alias shortname
      list definition of an existing alias.
   $sfk alias -del aliasname
      delete an alias (deletes the associated batchfile).
   $sfk alias -ren oldname newname
      rename an alias (renames the associated batchfile).
-list
sfk-dummy
alias-list
$current aliases from the sfk home %s :
alias -delete
%s - no such file
%s - no data
%s - no valid alias batch, will not delete.
%s - cannot delete file
alias deleted: %s
-ren
alias -rename
%s already exists, rename failed.
%s - no valid alias batch, will not rename.
%s - cannot rename to %s
alias renamed: %s
alias [show]
No sfk alias "%s" is defined
, but path contains:
alias [create]
missing parameters after "="
$%d 
$batch created: %s
$type "%s" to use.
replace -text /src/dst/ -file xfile1 xfile2
rep -binary /A0A1A2/B5B6B7/ -dir xdir -file .dat -yes
rep -dump -wide -context=20 -bylist xreplist.txt -dir . -file xfile1 xfile2
list xdir .txt +rep /foo/bar/
xreplace
xhex
<help>$sfk hexfind [opts] -pat /pattern/ -dir anydir -file .ext1 [.ext2]
   search text or binary data in text and binary files.
   if multiple patterns are given then they are searched
   independently (pattern1 OR pattern2).
<help>$sfk replace singleFile [-text] /src/dst/ [pattern2] [...] [-yes]
$sfk replace -[s]pat -bin[ary] /A0A1A2/B5B6B7/ -dir anydir -file .ext1 [-yes]
$sfk rep [-dump [-wide]]]] -bylist words.txt file1 [file2 ...] [-yes]
   replace text or binary data in text and binary files.
   may replace many different patterns in parallel.
<help>$sfk xhexfind dirName "/searchtext/totext/"
   search in text and binary files using wildcards * and ?
   as well as SFK Simple Expressions in brackets [],
   creating a hexadecimal dump output.
   $license notice
      this command is freeware and not part of sfk ose.
<help>$sfk xfind dirName "/searchtext/totext/"
   search in text and binary files using wildcards * and ?
   as well as SFK Simple Expressions in brackets [].
   $license notice
      this command is freeware and not part of sfk ose.
<help>$sfk xtext dirName "/searchtext/totext/"
   search in text files only using wildcards * and ?
   as well as SFK Simple Expressions in brackets [].
   $license notice
      this command is freeware and not part of sfk ose.
<help>$sfk extract dirName "/searchtext/totext/"
   extract data from text and binary files using wildcards * and ?
   as well as SFK Simple Expressions in brackets [].
   produces a (binary) data stream that can be
   - written to terminal as hex dump (default)
   - written to file by option -tofile
   - sent to xed by +xed command chaining
   $license notice
      this command is freeware and not part of sfk ose.
<help>$sfk xreplace dirName "/searchtext/totext/"
   replace in text and binary files using wildcards * and ?
   as well as SFK Simple Expressions in brackets [].
   $demo notice
      this command is commercial and part of SFK XE. this binary
      contains a demo of xreplace that gives a full output preview
      but which cannot write changes to files.
   Multiple search patterns are executed in the given sequence. Mind this
   if they overlap, e.g. /foo/bar/ /foosys/thesys/ makes no sense (foo is
   replaced by the first expression, so the 2nd one will fail to match).
   $by default, replace functions run in SIMULATION mode,
      previewing hits without changing anything. add -yes to apply changes.
      Changing binaries may lead to unpredictable results, therefore keep
      backups of your files in any case.
   $license notice
      this is the open source version of sfk replace.
      replacing source / target patterns #of different length<def> is slower
      and may require much memory compared to replacements #of same length<def>.
      SFK XE contains a different implementation with high performance.
   $subdirectories are included by default
      the sfk default for most commands is to process the given directories,
      #as well as all subdirs within them<def>. specify -nosub to disable this.
   $options
      -nosub        do not include files in subdirectories.
      -nobin[ary]   skip binary files.
      -case         case-sensitive text comparison. default is insensitive.
      -case         case-sensitive text comparison. default is case-insensitive
                    comparison for all -text strings, but NOT for -bin blocks.
                    case-sensitive comparison is faster then case-insensitive.
      -nocase       force case-insensitive comparison ALSO on -bin patterns.
      -pat          starts a list of search or replace patterns of the form
                    xsrcxdstx where x is the separator char, src the source
                    to search for, and dst the destination to replace it with.
                    e.g. /foo/bar/ or _foo_bar_ both replace foo by bar.
                    -pat is not required if a singleFile name is given.
      -text         the same as -pat, starting a text pattern list.
      -spat         the same, but also activates slash patterns like \t .
                    type "sfk help pat" for the list of possible patterns.
      -spats[trict] same as -spat, but stops with error on undefined
                    slash patterns like \m in C:\myproj. every slash
                    must then be escaped, e.g. using C:\\myproj.
      -bin[ary]     starts a list of binary replace patterns, specified
                    as hexcode like /0A0D/2020/
      -bylist x.txt read search/replace patterns from a file (see below).
      -bylist x.txt read search patterns from a file x.txt, supporting
                    multiple lines per pattern. (add -full for more.)
      -bylinelist x read /from/to/ or just /from/ patterns from a file x
                    with one pattern per line. (add -full for more.)
      -enddir       to use -dir ... -file ... as first parameters, type:
                    sfk %s -dir ... -file ... -enddir -pat ...
      -recsize      with same length replacements: set input record size
                    for processing (default=100k)
process
      -firsthit     %s only first found pattern match per file.
      -prog[ress]   show progress infos.
      -justrc       print no search results, just set return code on hits.
      -showrc       show return code at end of command.
      -quiet        do not show progress infos.
      -stat         show statistics like hits per pattern and no. of files.
      -perf         show performance statistics.
      -memlimit=nm  with different-length replacements, files must be loaded
                    into memory for processing. the default limit for memory
                    use is 300 MB. set -memlimit=500m to select 500 MB.
      -full         print full help text telling about -bylist pattern files,
                    batch file return codes, special character case sensi-
                    tivity and nested or repeated replace behaviour.
   $output options
      -conlines=n1  show n lines of context around search hits. by default
                    only text lines containing one or more hits are shown.
                    all lines together cannot hold more than:
      -conchars=n2  max. number of characters of all context lines together.
                    default is 240 or n1*160. cannot be larger than 32000.
      -conresline   show full result line but no further context (default)
      -sep[arator]  show "---" separator between hits within a file.
      -septext s    use separator text s (supports slash patterns \n etc.)
      -nosep        do not show "---" separator between hits within a file.
      -indent=n     set n chars of indentation for result display.
      -pure         extract only searched data, same as -context=0.
                    you may also set an environment variable:
                    <exp> SFK_CONFIG=xfind:pure,xtext:pure
                    use -pure -tofile x to extract binary content as is.
      -fill=c       replace binary null and other unprintable characters
                    with character c. default is a dot "."
      -hex          print output as hex dump instead of plain text.
      -wide         show 16 bytes per line in output.
      -lean         show  8 bytes per line in output.
      -nodump       do not create a hexdump, list only matching files.
      -dump         create hexdump of search hits or replaced text.
       -wide        with -dump: show 16 bytes per line.
       -lean        with -dump: show  8 bytes per line.
      -dumpfrom     always dump search hits but not replaced text.
      -dumpall      dump search text and replaced text.
      -nodump       do not create a hexdump, list only matching files.
      -showle       highlight CR/LF line endings in hex dump output
      -context=n    with hexdump: show additional n bytes of context.
      -reldist      with hexdump: tell relative distances to previous hits.
      -nofile       do not insert :file header lines in output.
      -crlf, -lf    for file headers and default totext: force crlf or lf
                    line endings instead of system default
      -filehead s   file header to insert on every matching file.
                    only [file.name] surrounded by text can be used.
                    default is -filehead ":file [file.name]\n"
                    unless a single input filename is given.
                    does not change hex dump output headers.
      -sep s        define separator s between hits in a file
      -rawterm      on output to terminal do not strip codes below 32.
                    null bytes are always stripped.
      -to dir<sla><run>file write output files to given path. for details about
                    output file masks, type "sfk help opt" or "sfk run".
      -tofile x     write output data to a single output filename x
                    (which is not interpreted as a mask but taken as is).
      +tofile x     as last parameter (command chaining): write text as
                    displayed on terminal to a file x.
   $return codes for batch files
      0 = no matches, 1 = matches found, >1 = major error occurred.
      see also "sfk help opt" on how to influence error processing.
   $the -bylist pattern command file
      may contain /from/to/ commands as well as remark lines starting
      with ":##" and blank lines. commands can be split into several
      lines forming blocks. when doing so, spaces around lines are
      stripped, and all lines after the first line must start with
      the separator character, or a space (not tab). multi line
      commands must end with a dot '.' after the final separator.
      search patterns for xfind or xtext must end with /[all]\n/
      if output text is not reformatted.
      To keep whitespace at line start use "\ " for a blank.
      example: extract ID3v1 data from an .mp3 file
        :## id3v1 tag, search for zero byte then 'TAG'
        /\0\x54\x41\x47[30 bytes][30 bytes][30 bytes]
        /[file.name]:
         \ [strip(part3,\0)],[strip(part2,\0)],[strip(part4,\0)]\n/.
   $the -bylinelist simplified pattern command file
      may contain /from/to/ or just /from/ commands, with exactly
      one command per line. the /to/ part is optional, allowing
      to search many phrases without typing /[all]\n/ everytime.
   $the -bylist pattern command file for sfk replace and hexfind
      may contain ":text" or ":binary" commands followed by any number
      of replacement patterns, and remark lines starting with ":##".
      if the first line is no command, a ":text" section is assumed.
      specify -spat before -bylist to enable slash patterns like \x0d\x0a.
      commands can be split into several lines. when doing so, whitespace
      around lines is stripped, and all lines after the first line
      must start with the separator or a blank character. multi line
      commands must end with a dot '.' after the final separator,
      search commands with empty /to/ text should end like //.
      example file with single line and multi line formatting:
      :text
      :## now comes a single line command. this is a remark.
      /foobar/barfoo/
      _the test_the text_
      :## now comes a free formatted command.
      /foobar 123 the quick brown fox/
       foobar 987 the quick brown fox/.
      :binary
      /0d0a/200a/
   $case sensitive search with \xnn, accents and umlauts
    - since SFK 1.69, hex codes like \x41 are not treated as characters
      even if they represent a character code, and are therefore not
      searched case insensitive. this can be changed by option -xchars.
    - accents and umlauts in -text patterns are searched case insensitive
      according to code page ISO 8859-1, e.g. code 0xC0 (small a accent)
      is equal to 0xE0. this can be disabled by option -noacc[ents].
      options can also be set by environment like:
         <exp> SFK_CONFIG=xchars,noaccents
   $about nested replacement patterns
      #sfk replace myfile.dat /foo/bar/ /bar/goo/
      with SFK base, "foo" will be replaced by "bar" and then
      immediately "bar" is replaced again by "goo".
      with SFK XE, a replaced part of text is not replaced again
      in the same command, so "foo" stays replaced by "bar".
   $unexpected repeat replace behaviour
      depending on the input data and search/replace expressions,
      it can happen that running the same replace multiple times
      on the same file produces further hits that didn't exist
      in the first run. add option -full to read more on this.
      in the first run, for example:
      -  input file contains #foothenbar
      -  patterns are #-text /then// -text /foobar//
      then this will happen with SFK XE:
      -  on the first replace run, no "foobar" is found, but
         "then" is removed from text, producing a new "foobar".
         however, this new "foobar" is NOT replaced, because
         text processing already reached the position after
         "foo", i.e. the word "bar".
      -  on the second replace run, a "foobar" is found that
         did not exist in the first run, and replaced.
      please note that there is no option to reiterate on the
      same file in one call of sfk replace, so re-replaces
      over newly combined text cannot be done automatically.
      SFK Base behaves slightly different, due to a different
      replace implementation, but it also does not reiterate.
      With a pattern sequence -text /foobar// -text /then//
      in the above example the same will happen with SFK Base.
   $chaining support
      sfk extract output can sent only to +xed or +xex.
      other commands require an xed conversion step like
      #sfk extract ... +xed +view
   $performance notice
      the system may cache output file(s), writing to disk in
      background after sfk has finished. subsequent batch file
      commands may execute slower.
   $aliases
      #sfk xhexfind<def> is the same as xfind -hex
      to extract unmodified binary data you may use either
      #sfk xfind -pure ... -tofile<def> or #sfk extract ... -tofile<def>
   $common usage errors
      #sfk hexfind in.txt "/foo\r\n/"
         will not find "foo" at line ends, but searches literal
         strings like "slash and r". add option -spat to enable
         slash patterns, converting \r\n to real CRLF codes,
         or use #xhexfind<def> where slash patterns are default.
      #sfk hexfind mydir "/foo*bar/"
         will not find "foo" and "bar" with any characters
         inbetween, but searches a literal star "*".
         use #xhexfind<def> to enable search with wildcards.
      #sfk rep in.txt "/foo[1000 bytes]bar/---/"
         will not replace 1000 bytes between "foo" and "bar",
         but replaces a literal string "foo" then "[1000 bytes]"
         then "bar". use #xreplace<def> to enable SFK expressions.
      #sfk hexfind any.exe -spat /\x00$$version/
         will not search for a string "$$version" prefixed by
         a null byte. the linux console will destroy the \ and
         $$ arguments, giving junk to sfk. type instead:
         #sfk hexfind any.exe -spat "/\x00\$$version/"
   $examples
      #sfk hexfind -text "/foo/" "/bar/" -dir mydir -file .txt .hpp
         find words "foo" or "bar" case insensitive
         in all .txt or .hpp files in a folder mydir.
      #sfk hexfind -binary /666f6f/ -dir mydir -file .exe +view
         find binary data with hex values 0x66, 0x6f, 0x6f
         in all .exe files of mydir and show result in dview.
   $examples
      #sfk replace myfile.dat "/Lemon/Curry/"
         replace Lemon by Curry within myfile.dat. search is
         case-insensitive, therefore "lemon" will be replaced as well.
         the quotes "" are optional here.
      #sfk replace -pat /FooCase// -dir . -file .txt
         search for FooCase in all .txt files below current directory.
         note that if you leave out the single fileOrDir parameter,
         you have to say -[s]pat, -bin or -text first to tell clearly
         that you will specify the target fileset later on.
      #sfk rep -spat "/The foo/The\tbar/" -dir mydocs
         replaces "The foo" by "The" and "bar" separated by TAB char,
         within all files within mydocs.
      #sfk rep -binary /1A/20/ -dir docs -file .txt .info .note
         replaces all bytes with code 0x1A by code 0x20, in all .txt,
         .info and .note files, in directory docs and all subdirectories.
      #sfk replace tmp\image.dat -bylist patches.txt
         searches for source patterns in file tmp\image.dat,
         replaces by patterns specified in patches.txt
      $SFK Base and XE: swap text in two steps
      #sfk -yes rep io.txt /foo34/foo99/ /foo12/foo34/ +rep /foo99/foo12/
         replaces foo12 by foo34 and vice versa. with SFK Base, a word
         which is replaced may be replaced again by a following pattern,
         therefore the intermediate step: turn foo34 into something
         not used anywhere in io.txt, then replace foo12, then replace
         the intermediate pattern back in a second replace command
         on the same file.
      $SFK XE only: swap text in one step
      #sfk rep io.txt /foo12/foo34/ /foo34/foo12/ -yes
         replaces foo12 by foo34 and vice versa. with XE, a word which
         is replaced is not looked at again in the same command, so
         "foo34" from the first pattern is not changed by the 2nd.
      #sfk hexfind mydir -pat /FooCase/ +list -late
         do not replace, just find binary files containing "FooCase",
         then list them sorted by time. also accepts -bylist files.
      #sfk replace -binary /666f6f/626172/ -dir mydir -file .dat
         replace binary data with hex values 0x66, 0x6f, 0x6f
         by data with values 0x62, 0x61, 0x72 in all .dat files.
      #sfk xfind in.dat "/foo[0.100 bytes of (a-z0-9_@ )]bar/"
         searches a single input file in.dat for all phrases
         starting foo and ending bar, with 0 to 100 characters
         inbetween being alphanumeric, @ or _ or space.
      #sfk xfind -text "/foo*bar/[part2]\n" -dir mydir -file .txt
         find foo*bar in all .txt files of folder mydir
         but print only the text between foo and bar.
      #sfk xfind -text "/\x66\x6f\x6f[0.100 bytes]\x62\x61\x72/"
       #-dir mydir -file .exe +view
         find binary data starting with bytes 0x66, 0x6f, 0x6f,
         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween
         in all .exe files of mydir and show result in dview. [14]
      #sfk xfind -arc in.zip "/class*/"
         XE: find phrases starting with "class" in .zip contents
         XD: demo will search first 1000 bytes per .zip sub file
      #sfk xtext -pure -text "/foo*bar/[part2]\n/"
       #-dir mydir -file .txt +view
         search foo*bar in all .txt files of folder mydir,
         extract the text between foo and bar without any
         context (-pure), and display this in dview. [15]
      #sfk xtext -arc in.zip "/class*/"
         XE: find phrases starting with "class" in .zip contents
         XD: demo will search first 1000 bytes per .zip sub file
      #sfk xhexfind -text "/\x66\x6f\x6f[0.100 bytes]\x62\x61\x72/"
       #-dir mydir -file .exe +view
         find binary data starting with bytes 0x66, 0x6f, 0x6f,
         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween
         in all .exe files of mydir and show result in dview. [16]
      #sfk xreplace in.txt "/foo*bar/other/"
         replace phrases starting with "foo" and ending with "bar"
         by word "other" in single file in.txt
      #sfk xreplace -text "/foo*bar/===[part2]===/" -dir mydir -file .txt
         replace foo*bar in all .txt files of folder mydir
         with a new pattern containing the text between foo and bar
         surrounded by "===".
      #sfk xrep -text "/\x66\x6f\x6f[0.100 bytes]\x62\x61\x72/---/"
       #-dir mydir -file .dat
         replace binary data starting with bytes 0x66, 0x6f, 0x6f,
         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween
         by "---" within all .dat files of folder mydir. [24]
      #sfk extract in.txt "/foo[0.100 chars of (a-z0-9_@ )]bar/"
         extracts from a single input file in.txt all phrases
         starting foo and ending bar, in the same line, with
         0 to 100 characters inbetween being alphanumeric or
         one of @ _ or a blank character.
      #sfk extract mydir "/\x66\x6f\x6f[0.100 bytes]\x62\x61\x72/" -tofile out.dat
         find binary data starting with bytes 0x66, 0x6f, 0x6f,
         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween
         within all files of folder mydir, writing found data
         to a single file out.dat
      #sfk extract -text "/class [bytes]{[bytes]}/[all]\n\n/"
       #-tofile out.txt -dir mydir -file .hpp
         collect class definitions from mydir directly to out.txt [10]
      #sfk extract -dir mydir -file .cpp -text "/printf([bytes]);/[all]\n/"
       #+xed "/);[eol]/[all]/" "/[eol][1.* white]/ /"
         extract all (multi line) printf statements from source code,
         convert multi line to single line, stripping whitespace. [11]
         the "/);[eol]/[all]/" keeps all line endings after ");"
      #sfk extract -text "/%c%cversion:vernum=*,*name=*,*os=*,/
       #[file.name]: [part6] v[part2] for [part10]\n/"
       #-tofile versions.txt -dir mydir -file .exe -nofilenames
         search all .exe files in mydir for a text block like
          #%c%cversion:vernum=1.6.9,name=fooprog,os=windows
         then extract and reformat version informations,
         writing results without :file headers to versions.txt [12]
      #sfk extract in.zip "/PK\x05\x06[0.100 bytes]/"
         search characters 'P','K' then bytes 0x05 0x06
         and then up to 100 bytes in raw compressed data
         of a .zip file without extracting any contents.
      #sfk extract -arc in.zip "/class*/"
         XE: find phrases starting with "class" in .zip contents
         XD: demo will search first 1000 bytes per .zip sub file
xfind:pure
xtext:pure
[processDirParms.1 from idx=%d]
[processDirParms.1 done, inext=%d]
missing -enddir after initial -dir ... -file ... options
-bylist
-bylinelist
-fill
-filehead
percent "%%" is not allowed in file header
[file.name]
-rawterm
-revert
:text
-dump
-dumpfrom
-dumpall
unknown option: %s
-reldist
record size
invalid record size
using record size: %s bytes
-recordsize
-context
-conresline
-conlines
---%s
-conchars
-conchars cannot be larger than %d
-indent
-nole
best
invalid option: %s
use one of -showpart -showbest -showall
-fixedbylist
-blank
[all]%s%s
-astext
-nodump
-nodump excludes -hex. use xhexfind instead.
-septext
-separator
-prog
+xed
(x)replace ... +xed is not supported.
you may use extract ... +xed instead.
+view
if this is a pattern, say -pat %s
skipping binary: %s
used SFK_CONFIG=%s
[all]%s
cannot combine patterns on command line with -bylist file. (1)
unable to load -bylist file "%s"
no patterns found for processing.
say -text /src/dst/ or -binary _src_dst_ or -bylist file.txt
specify -dir or -file after patterns only.
$Pat.  Range  MaxOut Memory FromText
out of memory (xpat)
:text
:binary
missing '=' on define
cannot define
incomplete replacement pattern
missing last delimiter in pattern
$[/.../totext/ is incomplete, showing part infos:]
$[one or more /.../totext/ are incomplete.]
wrong pattern, check delimiters
wrong syntax in pattern
pattern array overflow
%05d %06d %06d %06d #%s
                     parts %s
                     <time>prios %s
invalid source or target pattern
wrong length of hex expression
syntax error in hex expression
option -yes is not possible with incomplete /from/to/ patterns.
$[add -dump or complete all /from/to/ patterns to continue.]
allow replace
continue
$[complete all /fromtext/totext/ patterns to %s.]
no patterns for replacement, nothing to do.
[processDirParms.2 from idx=%d]
please specify a fileset using -dir ... -file ...
if %s is a filename, specify it BEFORE -spat or -pat.
xreplace with option -yes requires SFK XE.
cannot chain output this way. say "hexfind" instead.
option -yes cannot be used with hexfind.
-justrc can be used only with find commands.
next command
%s accepts only text, sending hex dump.
-to[file] cannot be used with (x)hexfind.
use "+tofile filename" as last parameter to store hex dump output.
use "sfk extract" to store binary data with option -tofile.
-to[file] cannot be used with xfind -hex output.
replace with -to[file] requires SFK XE.
-recordsize extended to %s due to pattern %d input range
-fast can be used only with replace (not xreplace)
using -fast mode %d. pattern minlen=%d maxlen=%d
out of memory, cannot create outbuffer (%d)
$[xreplace demo preview of changes:]
$[searching for incomplete patterns:]
using xmaxlen=%u, case=%u
[total hits/matching patterns/non-matching patterns]
replace.parse
$Best pattern matches across all input data:
Pat.%02u matched $%02d<def> parts of: #%s
Pat.%02u per part byte match: 
%u/%u 
replace.exec
%d files checked, %d files matched.
written
changed
 would be
%d files checked, %d%s %s.
variable
differing
source and target patterns have %s lengths. replacement may be slow.
$[please purchase XE to allow writing of changes.]
$[add -yes to write changes.]
<help>$sfk ... +xed /from/to/ [/from2/to2/]
   $a stream text editor using SFK Expressions.
    - takes text stream input from a previous command,
      or a binary stream from sfk extract.
    - joins all lines into one large block that can be
      changed in complete.
    - splits output again into lines for further use,
      or passes output as binary to another +xed
   $license notice
      this command is commercial and part of SFK XE.
<help>$sfk ... +xex /from/ [/from2/]
   $a stream text filter using SFK Expressions.
    - takes text stream input from a previous command
      or a single file.
    - joins all lines into one large block that can be
      searched in complete.
    - splits output again into lines for further use,
      or (with XE) passes output as binary to +xed
   $license notice
      this command is freeware and not part of sfk ose.
   xed/xex is designed to post process small to medium sized
   data streams produced by previous commands. it is not suitable
   to edit large files, as the whole content must fit into memory
   multiple times. use "sfk xreplace" to process large files.
   $options
      -bylist x    read /from/to/ patterns from a file x,
                   supporting multiple lines per pattern.
                   type sfk xrep for details.
      -bylinelist x  read /from/to/ or just /from/ patterns
                   from a file with one pattern per line.
                   best for searching many phrases with
                   simple or no output reformatting.
      -i           process text stream from standard input
      -nomark      do not highlight changes in output
      -nocol       no colors at all to allow more memory
      -tofile f    write output to file f. do not use +tofile
                   chaining as it splits data into text lines.
      -rawterm     on output to terminal do not strip codes
                   below 32. Null bytes are always stripped.
      -dump[raw]   create hex dump [raw = w/o eol highlight]
      -crlf, -lf   for file headers and default totext: force
                   crlf or lf line endings instead of default
   $chaining I/O support
      $extract ... +xed<def>   supports binary data transfer.
      $xed ... +xed<def>       supports binary data transfer.
      In all other cases like xed ... +filter data is passed
      as text lines without zero bytes and up to 4000 chars
      per line. Binary transfer needs four times free memory
      available then the actual number of bytes passed.
   $archive file reading
      xed may directly read archive file entries like
      src.zip\\sub1.bz2\\sub2.tar.gz. for details and
      limitations type "sfk help xe".
   $unexpected repeat replace behaviour
      depending on the input data and search/replace expressions,
      it can happen that running the same replace multiple times
      on the same stream produces further hits that didn't exist
      in the first run. read the sfk xtext extended help text
      by "sfk xtext -full" for details.
      #sfk xed in.txt "/foo*bar/goo/" -tofile out.txt
         read from file in.txt, replace "foo" and "bar" with
         up to 4000 characters inbetween by the word "goo".
         write output to a file out.txt.
      #sfk xex in.txt "_foo*bar_[part2]\n_"
         extract any text found within the same line between
         foo and bar, using "_" as separator character instead
         of "/". you may leave out the third "_" to get
         an info text listing part numbers.
      #sfk xex in.txt "_\qfoo\q[.100 bytes]\qbar\q_[all]\n_"
         extract any text starting with "foo" enclosed by double
         quotes, then having up to 100 bytes (including CR or LF,
         i.e. across multiple text lines), then ending with bar
         enclosed by double quotes, and print all parts.
      #sfk xex in.cpp "/printf([bytes]);/[all]\n/"
       #+xed "/);[eol]/[all]/" "/[eol][.100 bytes of \x20]/ /"
         collect all (multi line) printf statements from a text
         and reformat them as one statement per line. notice
         that "/);[eol]/[all]/" is a cover pattern, meaning
         it does not change anything, but keeps line endings
         after ");" from being changed by other patterns. [1]
      #sfk xex in.xml "_<row>[xwhite]<artist>*</[bytes]<album>*</
       #[bytes]<track>*</_[part4]\t[part8]\t[part12]\n_"
         if in.xml contains simple xml data like:
            #<row><artist>foo</artist><album>bar</album>
            #<track>foobar</track></row>
         then reformat this to tab separated csv data. [2]
      #sfk xex in.csv "_[lstart]*\t*\t*_<row>\n <artist>[part2]
       #</artist>\n <album>[part4]</album>\n <track>[part6]</track>\n
       #</row>\n_"
         if in.csv contains tab separated data like:
            #artistname{TAB}albumname{TAB}trackname
         then reformat this to xml data. [3]
      #dir | sfk xex -i -bylist dirtags.txt
         reformat windows 'dir' command output like:
           05.12.2013  19:17  <DIR>      myproj
           28.01.2010  22:08         197 readme.txt
         using a bylist file dirtags.txt like:
           /??.??.????[white]??:??[white]<dir>[white]*
           /DIR : [part13]\n/.
           /??.??.????[white]??:??[white][digit][* not ( )][white]*
           /file: [part14]\n/.
         producing output:
           DIR : myproj
           file: readme.txt
      #sfk xex in.hpp "/bool[xwhite]bCl*;/" "/int[xwhite]iCl*;/"
         extract variable declarations like "bool bClDone;"
         or "int iClCounter;" from source code, including
         statements across multiple lines.
      #sfk xex in.html "_\<head>**</head>_"
         extract head section from an html. notice that "_" is
         used as the separator, as "/" is part of the text.
      #sfk xex in.txt "/[lstart][4 chars][15 chars][15 chars]*/
       #[part2]\t[part3]\t[part4]\n/"
       #+xed "/[white][char of (\t\r\n)]/[part2]/" +tabtocsv
         extract from fixed column data like below: [4]
            7936JAMES FOO      ATLANTA        20140129
         the first three columns as comma separated data like
            7936,JAMES FOO,ATLANTA
      #sfk xex in.zip\\sub1.tar.bz2\\sub2.tar.gz\\Trace.hpp "/class*/"
         XE: extract phrases starting with "class" from a
             .tar.gz within a .tar.bz2 within a .zip file.
         XD: demo reads first 1000 bytes from sub2.tar.gz
This help is only for information, the actual command requires SFK XE.
Please type "sfk help xe" for more.
sfk xed requires SFK XE. type "sfk help xe" for more.
this binary contains only the xed help text for information.
you may use sfk xex to extract text with SFK expressions.
-mark
-cover
-nomark
-dumpraw
missing '=' on -define %s
cannot use -define %s
pattern too short: %s
missing end of from part: %s
$[/.../to/ part(s) incomplete, showing info:]
cannot combine patterns on command line with -bylist file. (2)
wrong find pattern, missing delimiter
$[complete all /from/to/ patterns to continue.]
$[remove -showparts to continue]
missing input from stdin
cannot load: %s
%d msec to collect %d input bytes
xed uses %d input bytes: %s
input too large, exceeds 10 MB demo limit.
please buy sfk xe to use xed with up to 300 MB by default
(extendable by option -memlimit) or to use xreplace to process
large files that do not fit into memoy.
input too large, exceeds current memory limit (%d MB).
xed/xex is not designed for large data. you may raise the memory limit
to n mbytes by option -memlimit=n but xed may then become slow
or may even crash. if you need to process large files at high
speed then sfk xreplace is recommended.
%d = check offset=%d ipat=%d maxlen=%d
output rendering failed
xed: pattern=%d hit at index=%d size=%+d from="%s"... out="%s"...
replace repeat %d after %d matches
%d msec to search/replace with %d hits
some output line(s) were too long and therefore wrapped.
%d msec to handle %d output bytes
testrep
Running %d test cases ...
[%d]
Done with RC=%d.
csvtab
<help>$sfk csvtotab infile.csv [options]
   convert csv data to plain tab separated.
   $default input/output format
   - input fields are separated by a comma ","
   - input fields can be surrounded by double quotes "
     and may contain escaped double quotes as ""
   - output fields are separated by TAB characters
   - surrounding quotes are stripped, and escaped
     quotes are reduced to normal quotes
   - if input contains any TABs they are changed to
     a single blank character
   - input fields cannot contain line breaks
   $options
     -tofile x     write output to file x
     -insep="x"    set input separator to character x
                   e.g. ; or \t
     -outsep="x"   change output separator
     -quote="x"    change quote character, e.g. \x27
                   uses single quote.
     -tabrep="x"   change tab replacement character
   $see also
     #sfk ascii<def>     list of ASCII codes for characters
     #sfk tabtocsv<def>  further conversion examples
   $examples
     #sfk csvtotab in.csv -tofile out.txt
        convert to tab separated out.txt
     #sfk filter in.csv -+foo +csvtotab
        convert only lines with word "foo"
     #sfk csvtotab in.csv +filter "-<not>[warning]"
        drop all lines with [warning] from output
-insep
invalid or too long input separator: %s
use only a single char like ; or a valid slash pattern like \t
-outsep
invalid or too long output separator: %s
-quote
invalid quote: %s
-tabrep
invalid tab replacement: %s
tabcsv
<help>$sfk tabtocsv infile.txt [options]
   convert plain tab separated data to csv.
   $default input/output format
   - input fields are separated by a tab and should
     not be surrounded by quotes, as these are not
     interpreted. input fields themselves cannot
     contain TAB characters.
   - output fields are separated by comma ","
   - output fields are surrounded by quotes "
     if input contains a comma or quote
   - if input contains quotes it is escaped as ""
   $options
     -tofile x     write output to file x
     -quotetext    surround all text by quotes
     -quoteall     surround all output by quotes
     -outsep="x"   change output separator to
                   character x, e.g. ; or \t
     -quote="x"    change quote character
   $examples
     #sfk tabtocsv in.txt -tofile out.csv
        convert tab separated to csv in default format
     #sfk csvtotab -quote="\x27" -insep=";" in.csv -tofile tmp.tsv
        reads a CSV with input fields separated by semicolon and
        surrounded by single quotes ' with ASCII code hex 27
     #sfk tabtocsv -outsep=";" -quote="\x27" tmp.tsv -tofile out.csv
        converts tab separated to an output CSV, with output fields
        separated by semicolon and surrounded by single quotes
-quotetext
-quoteall
<help>$sfk touch [-date n] [opts] file
$sfk touch -from srcfile [opts] file
   change date and time of file(s) or directories.
   if just a file- or directory name is given then
   the access and modification time is set to the
   current time. with SFK for windows, creation time
   is not changed by default.
   $options
      -force   create empty file if it doesn't exist
      -date n  set file date/time to this value
               given like  YYYYMMDDhhmmss,
               for example 20130412063015.
      -from f  copy file date/time from another file
      -atime   change only access time
      -mtime   change only modification time
   $command chaining support
      multiple files can be touched through chaining:
      #sfk select mydir .ext +touch ...
   $see also
      #sfk filetime<def>   print times of a file
   $examples
      #sfk touch foo.txt
         sets access and modification time of foo.txt
         to the current time.
      #sfk touch -date 20130412063015 foo.txt
         sets access and modification time of foo.txt
         to 12-Apr-2013 at 06:30:15.
      #sfk touch -from src.txt myfile.txt
         reads access and modification time of src.txt
         and copies it to myfile.txt
      #sfk select mydir .cpp .hpp +touch
         touch all .cpp and .hpp files from mydir.
-date
-date cannot be combined with -from
-nsec
need a 9 digits value for -nsec
-amtime
missing target filename
missing parameters for touch
cannot create: %s
nmatch
%d = match(mask %s,str %s) %d
testing getCurrentTime():
tv_sec %d usec %d
nval dec %s
nval hex %s
testing info:
addinfo
subject
verb
interactiveConsole=%d
fileage
%s sec, %d days
<help>$sfk sleep msec
   delay execution for a number of milliseconds.
   $usage example:
      runapache.bat:
      #start sfk sleep 3000 +tail -f logs\access.log -pat "GET * 404 "
      #apache.exe
         creates an error log viewer, and runs apache in parallel.
         sfk will wait 3 seconds before tail goes active.
wrong number format: %s
unexpected parameter: "%s" (8)
pause
<help>$sfk pause [text]<def>
   wait for user input before continuing command execution.
   $see also
      sfk sleep    delay execution for a given time.
   $examples
      #sfk echo hello +pause
         prints hello and then waits.
-maxwait
Press ENTER to continue, or CTRL+C to stop.
tail -lines=10 -follow -quiet -polltime=500 xfile
thead
<help>$sfk head [-lines=n] [-f[ollow]] [filename]
$sfk ... +[t]head [-lines=n]
   1. print first lines of a file, optionally following changes.
      to use file content processing, provide a single filename.
   2. print first text lines procuded by a previous command.
      to process chain text thead is recommended.
   $options
      -lines=n     print first n lines (default is 10).
      -follow      or -f waits for file changes, rereading from start.
                   to post-process head output, e.g. with +filter, always
                   add +loop at the end of the command sequence.
                   head checks both file size and time for changes.
      -altsize     use a different method to determine the file size
                   (stat instead of seek). may help if the default method
                   fails to read the file, or to improve performance.
   $examples
      #sfk head readme.txt
         print first 10 lines of readme.txt
      #type myfile.txt | sfk filter +thead -lines=50
         filter first 50 lines from stdin, via sfk filter.
      #sfk head -follow status.txt +filt -high Red error +loop
         show changes in status.txt, highlight "error" in red.
-lines
-polltime
-f[ollow] not supported with chain text input
check if previous commands produce filenames or text
using fseek file size detect
unexpected parameter: "%s" (9)
int. #168281112
too many input filenames for %s (%d)
%s can only process a single input filename.
use +t%s instead of %s if you want to process text.
try +ftt to convert filenames to text. see also "sfk help chain".
+loop
chain commands after tail -follow may not work as expected without +loop.
[file removed, waiting for recreation]
-----
[%c %s bytes filesize]
unable to read position: %s
ttail
<help>$sfk tail [-lines=n] [-f[ollow]] [filename]
$sfk ... +[t]tail [-lines=n]
   1. print last lines of a file, optionally following changes.
      to use file content processing, provide a single filename.
   2. print last text lines procuded by a previous command.
      to process chain text ttail is recommended.
   $options
      -lines=n     print last n lines (default is 10).
      -follow      or -f waits for file changes, printing them endlessly.
                   if file is recreated or shrunk, rereads the last lines.
                   to post-process tail output, e.g. with +filter, always
                   add +loop at the end of the command sequence.
      -quiet       do not tell verbosely about read restarts.
      -polltime=n  with -follow, specifies the delay in milliseconds before
                   the file is checked again for changes. default is 500.
      -altsize     use a different method to determine the file size
                   (stat instead of seek). may help if the default method
                   fails to read the file, or to improve performance.
   $examples
      #sfk tail -follow logs\access.log
         immediately lists last lines, then all added lines over time.
      #sfk tail -f c:\temp\log.txt +filter -+error: -+warning: +loop
         endless filter of error and warning messages from log.txt.
   $example sfk script with conditional execution
     #file logfilter.txt:
       sfk label checklog
          +tail -follow logfile.txt
          +tee toterm +storetext
          +filter -+error: +if "rc>0" call myalert
          +gettext +filter -+alldone: +if "rc>0" stop
          +loop +end
       sfk label myalert
          +then run -yes "myalert.bat" +end
     #sfk script logfilter.txt
        will run myalert.bat whenever errors appear in logfile.txt.
        the script stops as soon as "alldone" appears in the log.
        to allow double filtering of the chain text it must be
        stored before the first filter, then restored.
tail supports only %d -lines at maximum.
line %d pos %s "%s"
overflow, too many lines from file end specified.
take pos %s from offset %d
shrunk or 
[file %srecreated, rereading last %d lines]
unable to set position: %s
view
<help>$sfk list ... +[f]view [-noshl|-nocol] ["-..."]
   Show SFK command text output #interactively in Depeche View,<def>
   #a high speed text browser and filter tool<def> for Windows which
   also runs on Linux/Mac if WINE is installed.
   The tool allows #browsing of text with soft scrolling<def>
   and #instant search<def> as you type or click on words.
   Type #sfk getdv<def> to download Depeche View Lite now,
   or visit #www.depecheview.com<def> for manual download.
   The tool is fully portable and needs no installation.
   Many SFK commands allow to add #+view<def> to have their output
   shown instantly in DView. This requires #dview, dview.exe
   or #dview.bat<def> being located in the PATH. If you have downloaded
   an executable like dview155.exe, rename it before use.
   DView can be run under #Linux and Mac<def>, but this is experimental
   and unsupported. The latest #WINE<def> version must be installed.
   Google for "linux wine", or search it in your package manager.
   $use as a chain command, or to display stdin:
      +[f]view can be used only #after another command<def>
      producing a list of filenames or plain text data:
         #+view<def>  expects text as input.
         #+fview<def> expects a list of filenames.
      or use "sfk view -i" to display text from stdin.
   $options
      -nocol[or]   disable colored output and display.
                   set this if you're using dview < 1.1.4
                   or any other viewer.
      -wrap[=n]    wrap lines at column n. currently, this feature
                   disables colors (implies -nocol), but depending
                   on the content processed, dview may still show
                   colors based on syntax highlighting.
      -noshl       disable syntax highlighting at dview.
      "-x1 -x2"    all other options are passed through unchanged
                   to the viewer application. if multiple parameters
                   have to be passed, surround them by double quotes.
      -verbose     tell verbosely which target binary is invoked.
      -noback      by default, dview is run as a background process,
                   by appending ampersand & to the overall command.
                   say -noback to let sfk wait until dview is stopped.
      -nowine      sfk for linux creates a command "wine dview ..." to
                   make sure Depeche View is run in the wine environment.
                   specify -nowine to disable this.
      -nolinux     sfk for linux adds option -linux when calling dview
                   or dview.exe. specify -nolinux to disable this.
      -plain       combines -nowine, -nolinux.
   $dview options and parameters
      all non sfk options and parameters are passed through, like:
      -tab n                set tab size n (dview 1.6.3 or higher)
      -area 20:20:600:400   open at position 20,20 with size 600x400
      -find "a text"        search a text instantly
      -sfind "a \qtext\q"   search text given with slash patterns
      for all dview options try: dview -help -find "all*options"
   $temporary files
      this command #creates a temporary file<def> which is currently
      not deleted. type "sfk help options" for options on that.
   $using a different viewer
      when viewing a list of files, this command runs
         "dview -flist tmpfilename"
      with tmpfilename containing a list of filenames.
      when viewing text line output, this command runs
         "dview tmpfilename"
      with tmpfilename containing ascii text data.
      specify -verbose to see what is invoked in detail.
   $examples
      #sfk list docs .txt +fview
         view content of all .txt files in directory docs.
      #sfk echo x +view -verbose
         tell verbosely which dview(.exe?) executable is actually used.
      #sfk list docs .txt +ffilter -+foo -hitfiles +fview "-max -over"
         view all .txt $files<def> from docs containing "foo", pass options
         -max -over to the viewer, showing a maximized window in overscan
         mode (without any title bar).
      #sfk list docs .txt +ffilter -+foo +view "-space 0:0:40"
         view only text $lines<def> from docs containing "foo", in a window
         covering the whole desktop, except for 40 pixels at the bottom.
      #tar tvf foo.tar | sfk view -i
         display a tar file's content listing.
      #sfk larc -size -time -withdirs foo.tar +view
         the same, with sfk reading the .tar directly.
wine 
 -linux
-back
-comp
-noba
-noli
-nowi
 -wrap=%d
dview
dview.exe
dview.bat
dview, dview.exe or dview.bat not found directly, but trying
anyway, in case another extensions is present within PATH.
cannot write temporary file: %s
int. #141271853
%s%s%s%s -flist %s%s
[nopre] running: %s
failed to run, rc=%d: %s
%s: received no input files for viewing.
<interleaved-attributes-text version="1.0" prefix="">
:file 
:snapfile sfk,1.1,prefix=:file: ,
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
:snapfile sfk,1.1,lprefix=:file:
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
:file: %s
:file:
%s%s%s%s %s%s
%s: received no input text for viewing.
dview.exe was not found within folders of PATH:
To download Depeche View Lite now, type:
   #sfk getdv
Then retry your command. If downloading fails you may
also visit www.depecheview.com and download it manually.
filefind -time -size foo bar
<help>$sfk filefind [or ff] pattern [pattern2 <not>pattern3 ...] [opts]
   easy file name finder for the current directory tree.
   if you remember any words of a filename, or its path,
   type "sfk ff " and the words to find matching filenames.
   to type even less, try "sfk :" followed by the first word,
   without blank: "sfk :word1 word2 ..."
   $note:
   - searches the current directory "." and all subdirectories.
   - the full filename paths, including relative filenames,
     are compared (not just the relative filenames).
   - the patterns are AND combined (not OR as with list),
     meaning that ALL given patterns must appear in a path
     to have it listed. the pattern sequence is ignored.
   - options may appear anywhere.
   - exclude patterns starting with <not> are also supported.
   $options
      -time  list also file times.
      -size  list also file sizes.
      -arc   include .zip .jar .tar etc. archive contents.
   $chaining support
      output chaining is supported.
   $examples
      #sfk filefind foo bar <not>save
         lists all files in the current directory tree having both
         foo and bar in their path+filename, regardless of sequence.
         files having "save" in their path (or name) are excluded.
      #sfk ff foo<wild>bar thing +fview
         similar to the above, lists all files having bar AFTER foo
         in their path+filename. thing must also be present.
         resulting files are loaded and shown in Depeche View.
      #sfk :.pdf
         list all .pdf files down somewhere in the directory tree.
      #sfk :debug<wild>.o +del
         delete all debug executables in the current directory tree.
*%s*
<help>$sfk data [options] col "<run>namecom,<run>stradr,<run>city" [numrec]
   create numrec records of random text
   to produce synthetic test or example data.
   $formal syntax
     sfk data format template [numrec]
   $supported template formats
     #col[umns]<def>  a list of data columns, with each column
                content type prefixed by <run>.
     #text<def>       create a text, keeping commas as is
   $template format details
     #col<def>  format:
     - column types must be prefixed by <run>
     - columns are separated by comma on input
       which is replaced by TAB character on output
     #text<def> format:
     - symbols must be prefixed by <run>
     - comma "," is kept within text as is
   $predefined column types
     #nameper<def>    name of a person
     #namecom<def>    name of a company
     #stradr<def>     street address
     #city<def>       city name
     #statecode<def>  two character string
     #zip<def>        five digit string
     #person<def>     person address record
     #company<def>    company address record
     #date<def>       $$year$$month$$day
     #time<def>       $$hour$$minsec$$minsec
     #timemin<def>    $$hour$$minsec
     #dig<def>        single digit
   $options
     -makedb db.txt  export database to out.txt for editing
     -from   db.txt  load phrase database from db.txt
     -seed   n       set random seed to a fixed value
   $examples
     #sfk data col "<run>namecom, <run>stradr, <run>city <run>statecode <run>zip" 20
       create 20 records with random company data
     #sfk data col "<run>company" 20 +tabtocsv -quoteall
       same as above, but using the predefined company type
       and with comma separated fully quoted output
     #sfk data text "<run>news"
       create a california business news text
-makedb
saved to: %s
invalid command: %s
missing template text
#:sfk-phrase-db:
invalid or missing phrase database header
file must start with: #:sfk-phrase-db:
cannot solve 'all'
ping
<help>$sfk ping ip [maxwaitmsec]
   check if machine on given ip replies to pings.
   requires admin rights.
missing target ip
OK within %d msec
ping returned error %d
no reply within %d (%d) msec
tobase64
frombase64
<help>$sfk tobase64 infile [outfile]
$sfk frombase64 infile outfile
missing input filename.
missing output filename.
out of memory.
encoding failed, rc %d
decoding failed.
failed to fully write output file
<help>$sfk char[s] word
   print ascii codes of all chars of a word,
   or print chars for the given code(s).
   $options
      -codes    force listing of character codes,
                do not check if word is a number.
      -literal  or -lit stops interpretation of any further
                options or chain commands. required if you
                need the code of "-" or "+".
      -hexlist  print flat list of hex codes
      -hexsrc   print as hex source code
      -fromutf  decode utf8 sequence from hexadecimal
                input like 0xe28098
   $examples
      #sfk chars hello
         prints 5 lines of codes, one for each char.
      #sfk chars 0x53464b
         prints 'SFK', the letters for these hex codes.
         any number of hex values can be provided.
      #sfk chars -fromutf 0x54657374e28098e28099
         decodes ASCII characters and UTF-8 sequences,
         listing code points of each character found.
      #sfk char 65
         prints 'A', the letter for that decimal code.
         only a single decimal value can be provided.
      #sfk char -lit +
         print the code of the plus char.
-code
-fromutf
-hexlist
-xor
missing argument
value too large
%d	0x%02X	%c
unexpected character: %s
overflow
U+%04X	%c
0x%02X%s
<help>$sfk ... +hextobin outfile
   convert lines of text containing hexdump to binary.
   $chain-only command
      hextobin can be used only #after another command<def>,
      typically filter, which reads and prepares the input data.
   $options
      -fuzzy  ignore >< and ## characters
   $supported input formats since SFK 1.6.9:
      - if >...< is found then only hex data inside that is used.
      - if ## is found then only hex data before that is used.
      - else any hex characters are used, and with
        option -fuzzy any >< or ## characters are ignored.
      - whitespace at line start is ignored.
   $1. sfk hexdump full bracket delimited format:
      :file test.dat
       >6578616D 706C6520 77697468 206E6F6E< example with non 00000000
       >20616C6E 756D0D0A 63686172 61637465<  alnum..characte 00000010
       >73202D2B 28295C2F 2E0D0A<            s -+()\/...      00000020
   $2. sfk postdump minimal format, for forums and wiki:
      :file test.dat
      65 78 61 6D 70 6C 65 20 77 69 74 68 20 6E 6F 6E ## example.with.non 0000
      20 61 6C 6E 75 6D 0D 0A 63 68 61 72 61 63 74 65 ## .alnum..characte 0010
      73 20 2D 2B 28 29 5C 2F 2E 0D 0A                ## s..........      0020
   $3. any text with hex data inbetween that does not contain
      $the >< or ## characters (else -fuzzy must be used):
      --== 6578616D 706C6520 77697468 ==--
      // 0x65, 0x78, 0x61, 0x6D ::
   $input line length limitation:
      text lines in the input file should not be longer than
      4000 characters or sfk filter will split them, causing
      hextobin to produce errors like "wrong hex format".
   $examples
      #sfk filter dump.txt +hextobin out.dat
         convert file dump.txt and write to out.dat
%s needs input data from a previous command.
type "sfk hextobin" for help.
-fuzzy
hextobin: missing output filename.
hextobin: cannot write: %s
skipping filename line on input
wrong hex format: "%s"
buffer overflow: input lines too large
%d lines converted, %d skipped, %s output bytes.
md5: %s
dupfind -listorg -minsize=3m
<help>$sfk dupfind -dir anydir [-file .ext1 .ext2]
   find and list duplicate files.
   $options
      -diffdirs    list only duplicates residing in different
                   root directories. this option requires that
                   you specify at least two dirs after -dir.
      -listorg     list all original filenames,
                   leave out any duplicate filenames.
      -minsize=n   compare only files with size >= n.
                   examples for n are:
                      5m = 5000000 bytes (5 mbytes)
                    100k =  100000 bytes (5 kbytes)
                      1M = 1048576 bytes (2<<20 bytes)
                   9000b =    9000 bytes
   $command chaining
      - by default, this command passes the names
        of found duplicate files to the next command.
      - option -listorg does the opposite: it passes
        only original filenames, but no duplicates,
        to the next chain command.
   $NOTE:
      if identical files are found, the decision what is listed
      as "original" or "duplicate" is currently based on the
      order in the file system: the file found first is listed as
      "original". check carefully if this is what you think,
      before cleaning up any duplicates.
   $examples
      #sfk dupfind .
         find all duplicates within the current directory tree.
      #sfk dupfind -dir docs1 docs2 docs3
         find all dups across and within the given directories.
      #sfk dupfind -diffdir -dir docs1 docs2 docs3
         find dups between docs1/docs2, docs2/docs3, docs1/docs3,
         but does NOT list dups within the same root directory.
      #sfk dupfind docs .doc +del
         find all duplicate .doc files, within the docs
         directory tree, and delete them.
      #sfk dupfind -listorg docs .doc +run "copy <run>file docs2"
         copy all .doc files from docs to docs2,
         but leave out any duplicate files.
      #sfk dupfind -dir pic1 -dir pic2 -dir pic3
         find duplicates across three different directory trees.
         specifying multiple -dirs is also a way of influencing
         the result order; if a file is found both in pic1 and pic3,
         the file from pic1 will be listed as original, the other one
         as the duplicate.
      #sfk sel -dir pic1 pic2 pic3 -file .jpg +dup -minsize=1m
         similar to the above, this example uses command chaining:
         list all .jpg files from the pic directories, then pass
         this to the dupfind command, also filtering by size.
-diffdir
-listorg
need at least two -dir parameters with option -diffdir.
$%d duplicates with %d mb.
 $%d originals with %d mb.
scanned %d file infos in %d msec.
total duplicate scan took %d msec.
samp
batch
<help>$sfk sample java|cpp|... [outfile.java|.cpp|...]
   print a short example code in a programming language.
   $supported parameters
      java         create a java class doing text  file I/O
      javaimg      create a java class doing image file I/O
      javahex      create a hexdump of binary data in java
      javagui      create a simple java gui application
      cpp          create a c++ text file I/O example
      cppnetlog    how to send UDP network text in C++
      javanetlog   how to send UDP network text in Java
      php          create command line php code for text I/O
      phpimg       create php example for image processing
      cmd          create a windows .cmd or .bat file
      bash         create a linux bash script
      sfk          create an sfk script
      sfkcmd       sfk script embedded in a .cmd or .bat
      sfkbash      sfk script embedded in a bash script
   $options
      -force    if output file exists already, overwrite it.
   $command shortcut
      #sfk batch myscript
         does the same as "sfk samp sfkbash myscript"
   $examples
      #sfk samp sfkcmd foo.bat
         creates batch file foo.bat with embedded sfk script.
         type "foo.bat" to run the created script. note that
         foo.bat must be created in a directory of your PATH,
         or in the current directory.
      #sfk batch foo.bat -force
         the same as above, and overwrites an existing file.
      #sfk samp java foo.java
         create a java class foo. if the java JDK is available,
         type "javac foo.java" and then "java foo" to run it.
      #sfk samp phpimg doimg.php
         create image processing script that can be run by:
         #php doimg.php
         if php.exe is in your PATH (read remarks in the script).
fileio
java
bash
sfkcmd
sfkbash
javaimg
phpimg
sfkcmdphp
javahex
javagui
firefox
cppnetlog
javanetlog
unknown example: %s
no path allowed in output filename.
need an output filename like x.java or x.cpp
file already exists: %s
add -force to overwrite.
specify "write" or nothing after %s
import java.io.*;
public class %s
    static void log(String s) { System.out.println("main: "+s); }
    public static void main(String args[]) throws Throwable
    {
        if (args.length < 2)
            { log("supply in- and output filename."); return; }
        // copy or convert text file
        BufferedReader rin = new BufferedReader(
            new InputStreamReader(
                new FileInputStream(args[0]), "ISO-8859-1"
                // or US-ASCII,UTF-8,UTF-16BE,UTF-16LE,UTF-16
                ));
        PrintWriter pout = new PrintWriter(
            new OutputStreamWriter(
                new FileOutputStream(args[1]), "ISO-8859-1"
                ));
        while (true) {
            String sline = rin.readLine();
            if (sline == null) break; // EOD
            log("copying line: "+sline);
            pout.println(sline);
        }
        pout.close();
        rin.close();
    }
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
// print error message with variable parameters.
int perr(const char *pszFormat, ...) {
   va_list argList;
   va_start(argList, pszFormat);
   char szBuf[1024];
   ::vsprintf(szBuf, pszFormat, argList);
   fprintf(stderr, "error: %%s", szBuf);
   return 0;
// copy text lines from one file into another.
int main(int argc, char *argv[]) 
  if (argc < 2) return 9+perr("specify input and output filename.\n");
  char *pszInFile  = argv[1];
  char *pszOutFile = argv[2];
  FILE *fin  = fopen(pszInFile , "rb"); if (!fin ) return 9+perr("cannot read %%s\n" , pszInFile);
  FILE *fout = fopen(pszOutFile, "wb"); if (!fout) return 9+perr("cannot write %%s\n", pszOutFile);
  char szBuf[1024];
  memset(szBuf, 0, sizeof(szBuf));
  while (fgets(szBuf, sizeof(szBuf)-10, fin)) 
     char *psz = strchr(szBuf, '\r'); if (psz) *psz = '\0'; // strip cr
           psz = strchr(szBuf, '\n'); if (psz) *psz = '\0'; // strip lf
     printf("line: \"%%s\"\n", szBuf);
     strcat(szBuf, "\n");
     int nlen = strlen(szBuf);
     if (fwrite(szBuf, 1, nlen, fout) != nlen)
        return 9+perr("failed to fully write %%s\n", pszOutFile);
  fclose(fout);
  fclose(fin);
  return 0;
@rem windows command shell batch example
@echo off
IF "%%1"=="" GOTO xerr01
echo "parameter is %%1"
GOTO xdone
:xerr01
echo "please supply a parameter."
echo "example: mybat parm123"
GOTO xdone
:xdone
#!/bin/bash
Do nine men interpret Nine men I nod
function pmsg {
   # uses a local variable mystr
   local mystr="info: $1"
   echo $mystr
myparm1="$1 and $2"       # no blanks around "="
if [ "$2" = "" ]; then    # requires all blanks
   pmsg "please supply two parameters."
else
   pmsg "you supplied \"$myparm1\"."
   #  < -lt   > -gt   <= -le   >= -ge   == -eq   != -ne
   i=1
   while [ $i -le 5 ]; do # not "$i < 5"
      echo counting: $i   # quotes are optional
      let i+=1            # not "i += 1" or "$i+=1"
   done
thisfile
sfk select testfiles .txt .hpp .cpp
   // find words supplied by user.
   // note that %%1 is the same as $1.
   +find
      %%1 %%2 %%3 $4 $5 $6
   // process files containing hits
   +run -quiet "sfk echo \"Found hit in: [green]$file[def]\"" -yes
   // run the script by:
   // "sfk script %s pattern1 [pattern2 ...]"
thisfile.bat
@echo off
sfk script %s -from begin %%*
GOTO xend
sfk label begin
   // select text files from testfiles:
   +select testfiles .txt
   // filter words foo, and user-supplied:
   +ffilter
      -+foo
      %%1
      %%2
   // display results in depeche view:
   +view
   // end of sfk script:
   +end
:xend
#!/bin/bash
sfk script %s -from begin $@
function skip_block
sfk label begin
   // select text files from testfiles:
   +select testfiles .txt
#  // filter words foo, and user-supplied.
#  // note that # lines are skipped by bash,
#  // but not by sfk.
#  +ffilter
#     -+foo
#     $1
#     $2
   // display results in depeche view:
   +view
   // end of sfk script:
   +end
// Example source code for image file conversion
// and simple image processing with Java.
// Requires SUN's Java Advanced Imaging I/O Tools.
// Usage: java imtool input.png outbase
// Creates: outbase-jpg.jpg and further.
import java.io.*;
import java.awt.image.*;
import javax.imageio.*;
import com.sun.image.codec.jpeg.*;
public class %s
    static void log(String s) { System.out.println(s); }
    public static void main(String args[]) throws Throwable
    {
        if (args.length < 2)
            throw new Exception("specify input filename and output basename.");
        String src  = args[0];
        String dst1 = args[1]+"-jpg.jpg";
        String dst2 = args[1]+"-png.png";
        String dst3 = args[1]+"-green.jpg";
        String dst4 = args[1]+"-green.png";
        // load a PNG image, with or without transparency (alpha channel).
        BufferedImage buf = ImageIO.read(new File(src));
        int nwidth  = buf.getWidth();
        int nheight = buf.getHeight();
        log("width = "+nwidth+" pixels, height = "+nheight);
        // trivial file conversion: save as a JPEG or PNG image.
        // JPEG will work only if input contained no transparency.
        ImageIO.write(buf, "jpg", new File(dst1)); log(dst1);
        ImageIO.write(buf, "png", new File(dst2)); log(dst2);
        // image processing: turn all transparent pixels into green.
        // 1. get access to main pixels, and transparency.
        WritableRaster rmain = buf.getRaster();
        WritableRaster rtran = buf.getAlphaRaster();
        // 2. create a memory image to write to, WITHOUT transparency.
        BufferedImage bout  = new BufferedImage(nwidth,nheight,BufferedImage.TYPE_INT_RGB);
        WritableRaster rout = bout.getRaster();
        int apixm[] = new int[4]; // main  pixel
        int apixt[] = new int[4]; // trans pixel
        int apixr[] = new int[4]; // repl. color
        apixt[0] = 0xFF; // default is non-transparent
        apixr[1] = 0xFF; // set replacement color to green
        for (int y=0; y<nheight; y++)
         for (int x=0; x<nwidth; x++) 
         {
            rmain.getPixel(x,y,apixm);
            if (rtran != null)
                rtran.getPixel(x,y,apixt);
            if (apixt[0] == 0x00)
                // pixel is fully transparent: set to green
                rout.setPixel(x,y,apixr);
            else
                // else copy through, do not change.
                rout.setPixel(x,y,apixm);
         }
        // save memory image as JPEG, with control of quality.
        File file = new File(dst3);
        FileOutputStream out = new FileOutputStream(file);
        JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
        JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(bout);
        param.setQuality((float)90.0, false); // 90 percent quality
        encoder.setJPEGEncodeParam(param);
        encoder.encode(bout);
        out.close();
        log(dst3);
        // save memory image as PNG.
        ImageIO.write(bout, "png", new File(dst4)); log(dst4);
    }
thisfile.php
<?php
   // simple text file read and write in php.
   // requires the php command line interface:
   // 1. get the php 5.x zip package
   // 2. unzip into a dir like c:\app\php
   // 3. set PATH=%PATH%;c:\app\php;c:\app\php\ext
   // then run this script by "php %s"
   if ($argc < 3) {
      print("usage: php %s infile outfile\n");
      return;
   }
   $ssrc = $argv[1];
   $sdst = $argv[2];
   if (($fsrc = fopen($ssrc, "r")) === false) die("cannot read $ssrc\n");
   if (($fdst = fopen($sdst, "w")) === false) die("cannot write $sdst\n");
   $nlines = 0;
   while (!feof($fsrc)) {
      $sline = fgets($fsrc, 4096);
      if (fputs($fdst, $sline) === false)
         { print("failed to write (disk full?)\n"); break; }
      $nlines++;
   }
   fclose($fdst);
   fclose($fsrc);
   print("$nlines lines copied from $ssrc to $sdst.\n");
<?php
   // create a thumbnail image from a large image.
   // requires the php command line interface:
   // 1. get the php 5.x zip package
   // 2. unzip into a dir like c:\app\php
   // 3. set PATH=PATH;c:\app\php;c:\app\php\ext
   // then run this script by "php %s in.jpg out.jpg"
   if ($argc < 3) {
      print("usage: php %s input.jpg output.jpg [targetwidth quality]\n");
      return;
   }
   $ssrc = $argv[1];
   $sdst = $argv[2];
   $wdst = isset($argv[3]) ? $argv[3] : 100;
   $nqty = isset($argv[4]) ? $argv[4] :  80;
   if (strstr($ssrc, ".jpg"))
      $isrc = ImageCreateFromJPEG($ssrc);
   else
      $isrc = ImageCreateFromPNG($ssrc);
   if ($isrc === false) die("cannot load: $ssrc");
   $nsrcw = ImageSX($isrc);
   $nsrch = ImageSY($isrc);
   print("input: $ssrc with $nsrcw"."x$nsrch pixels\n");
   $hdst  = intval($wdst * $nsrch / $nsrcw);
   $idst  = ImageCreateTrueColor($wdst, $hdst);
   if ($idst === false) die("cannot create thumb");
   imagecopyresampled($idst, $isrc, 0,0,0,0, $wdst,$hdst, $nsrcw, $nsrch);
   imagejpeg($idst, $sdst, $nqty);
   print("thumb: $sdst with $wdst"."x$hdst pixels, quality=$nqty\n");
   imagedestroy($idst);
   imagedestroy($isrc);
<html>
 <head>
  <title>Welcome to FooBar</title>
   <style type="text/css">
      body     { font: 12px verdana,arial; }
      table    { font: 12px verdana,arial; }
      h1       { font: 16px verdana,arial; font-weight: bold; }
      b.red    { color: #ee6622; }
   </style>
   <script type="text/javascript">
      function hello() {
         document.write("hello from JavaScript.");
      }
   </script>
 </head>
<body leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<table width="980" cellspacing="0" cellpadding="0" align="center" border="0">
 <tr>
  <td width="120" align="center" valign="middle">
  &nbsp;<br>
  home
  </td>
  <td width="740" align="center" valign="top">
  &nbsp;<br>
  <h1>Welcome to FooBar.</h1>
  </td>
  <td width="120" align="center" valign="middle">
  &nbsp;<br>
  other
  </td>
 </tr>
 <tr>
  <td align="center" valign="top">&nbsp;</td>
  <td>
      <b class="red">bold</b> and normal text.
      <p>
      <script type="text/javascript">
         hello();
      </script>
  </td>
  <td align="center" valign="top">&nbsp;</td>
 </tr>
</table>
</body>
</html>
@rem <?php print("\r"); /*
@echo off
IF "%%1"=="" GOTO xerr01
sfk script %s -from begin %%*
GOTO xend
:xerr01
sfk echo "[green]jpeg image size lister.[def]"
sfk echo "lists width, height of all .jpg in a dir."
sfk echo "usage: %s dirname"
GOTO xend
   // this script requires the php command line interface:
   // 1. get the php 5.x zip package
   // 2. unzip into a dir like c:\app\php
   // 3. set PATH=PATH;c:\app\php;c:\app\php\ext
   // ----- begin of sfk script code -----
sfk label begin
   +sel %%1 .jpg
   +run -quiet -yes "php %s $file"
   +end
*/ // ----- end of sfk, begin of php script -----
   // print the width and height in pixel
   // of the supplied image file name:
   $asize = getimagesize($argv[1]);
   printf("w=%%04d h=%%04d %%s\n", $asize[0], $asize[1], $argv[1]);
/* // ----- end of php script, end of batch -----
:xend
@rem */ ?>
import java.io.*;
public class %s
    static void log(String s) { System.out.println(s); }
    // convert a single byte record into a hexdump record.
    // by default, set nrec to 16, and ndoff to 0.
    public static String hexRecord(byte ab[], int noffset, int nlen, int nrec, int ndoff)
    {
        // create hex and text representation
        StringBuffer sline = new StringBuffer();
        StringBuffer stext = new StringBuffer();
        for (int i=0; i<nlen; i++) {
            int nval = ab[noffset+i] & 0xFF;
            if (nval < 0x10) sline.append("0");
            sline.append(Integer.toString(nval, 0x10));
            sline.append(" ");
            if (Character.isLetter(nval))
                stext.append((char)nval);
            else
                stext.append('.');
        }
        // fill rest of line, if any
        int npadlen = nrec;
        while (stext.length() < npadlen) stext.append(' ');
        npadlen *= 3;
        while (sline.length() < npadlen) sline.append(' ');
        sline.setLength(sline.length()-1);
        // create offset as hex value
        String soffset = "";
        soffset = Integer.toString(ndoff, 0x10).toUpperCase();
        while (soffset.length() < 10) soffset = "0"+soffset;
        // combine hex, text and offset
        return ">"+sline.toString().toUpperCase()+"< "+stext+" "+soffset;
    }
    
    // hexdump a whole byte array, from a given offset.
    // nrec is the number of bytes per output record, use 16 by default.
    // ndosv is the display offset start value, use 0 by default.
    public static void hexDump(byte ab[], int noffset, int nlen, int nrec, int ndoff)
    {
        while (nlen > 0) {
            int nblock  = (nlen < nrec) ? nlen : nrec;
            String srec = hexRecord(ab, noffset, nblock, nrec, ndoff);
            System.out.println(srec);
            noffset += nblock;
            ndoff   += nblock;
            nlen    -= nblock;
        }
    }
    // hex dump a whole binary file's content
    public static void main(String args[]) throws Throwable
    {
        if (args.length < 1)
            { log("usage: java %s inputfilename"); return; }
        byte abBuf[] = new byte[1600];
        FileInputStream oin = new FileInputStream(args[0]);
        int nread  = 0;
        int ntotal = 0;
        do {
            nread = oin.read(abBuf, 0, abBuf.length);
            if (nread > 0) hexDump(abBuf, 0, nread, 16, ntotal);
            ntotal += nread;
        }   while (nread > 0);
        oin.close();
    }
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import javax.swing.*;
import java.util.*;
// can be run both as an applet and a command line application
public class %s extends JApplet implements ActionListener
    // a panel to collect all objects for display
    Container clPane = null;
    // a hashmap to collect the same objects for retrieval by an id
    HashMap<String,Component> clComp = new HashMap<String,Component>();
    // HashMap clComp = new HashMap(); // for JDK 1.4.2
    // the current add position
    int xadd = 0, yadd = 0;
    // set component placement cursor to a position
    void setPos(int x,int y) { xadd=x; yadd=y; }
    
    // add and remember a generic component for display.
    // steps the placement cursor w pixels to the right.
    void add(int x,int y,int w,int h,String id,Component o) {
        o.setBounds(x,y,w,h);   // set absolute position of object
        clPane.add(o);          // add to panel to display object
        clComp.put(id, o);      // and remember object in a hashmap
        xadd += w;              // step add position horizontally
    }
    
    // add a non-editable text label
    void addLabel(int w, int h, String id, String text)
        { add(xadd,yadd,w,h, id, new JLabel(text)); }
    // add a single line editable text field    
    void addTextField(int w, int h, String id, String text)
        { add(xadd,yadd,w,h, id, new JTextField(text)); }
    // add a multi linex editable text area
    void addTextArea(int w, int h, String id, String text) {
        JTextArea   oarea   = new JTextArea(text);
        JScrollPane oscroll = new JScrollPane(oarea);
        oscroll.setBounds(xadd,yadd,w,h);
        clPane.add(oscroll);
        clComp.put(id,oarea);
    }
    // add a push button
    void addButton(int w, int h, String id, String text) {
        JButton o = new JButton(text);
        o.addActionListener(this);
        add(xadd,yadd,w,h, id, o);
    }
    // easy access to any object by its id
    JTextField getTextField(String id) { return (JTextField)clComp.get(id); }
    JTextArea  getTextArea (String id) { return (JTextArea )clComp.get(id); }
    JLabel     getLabel    (String id) { return (JLabel    )clComp.get(id); }
    // setup visible objects at absolute positions
    private void fillPane() 
    {        
        clPane.setLayout(null); // absolute positioning layout
        
        setPos      ( 20, 20);
        addLabel    ( 70, 20, "lname", "filename");
        addTextField(620, 20, "tname", "c:\\test.txt");
        setPos      ( 90, yadd + 30);
        addButton   (620, 20, "bload", "load");
        setPos      ( 20, yadd + 30);
        addLabel    ( 70, 20, "lcont", "content");
        addTextArea (620,400, "acont", "");
    }
    // process push button command    
    public void actionPerformed(ActionEvent e) 
    {
        String sout = "";
        try {
            String scmd = e.getActionCommand();
            if (scmd.equals("load")) 
            {
                String sFilename = getTextField("tname").getText();
                BufferedReader rin = new BufferedReader(
                    new InputStreamReader(new FileInputStream(sFilename), "ISO-8859-1"));
                while (true) {
                    String sline = rin.readLine();
                    if (sline == null) break; // EOD
                    sout += sline + "\n";
                }
                rin.close();
            }
        } catch (Throwable t) {
            sout = ""+t;
        }
        getTextArea("acont").setText(sout);
    }
    // to run it from the command line:
    public static void main(String[] args)
        { new %s().main2(args); }
    public void main2(String[] args) {
        JFrame frame = new JFrame("Simple File Viewer");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        clPane = frame.getContentPane();
        fillPane();
        frame.setSize(760, 560);
        frame.setVisible(true);
    }
    // to run it as an applet:
  public void init() {
     clPane = new JPanel();
     this.setContentPane(clPane);
     fillPane();
    /*
       create a page "show.html" containing
       <html><body>
          <Applet Code="%s.class" width=800 height=600></Applet>
       </body></html>
      
       and then type "appletviewer show.html"
    */
<overlay id="myextOverlay" xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
   <script type="application/x-javascript" src="chrome://myext/content/myextOverlay.js"/>
   <popup id="contentAreaContextMenu">
      <menuitem id="myext-sayhello" label="Say Hello" oncommand="sayHello(event);" />
   </popup>
</overlay>
myext@mydomain.org\chrome\content\myext.xul
function sayHello(event) {
   alert("hello.");
myext@mydomain.org\chrome\content\myextOverlay.js
content myext chrome/content/
overlay chrome://browser/content/browser.xul chrome://myext/content/myext.xul
myext@mydomain.org\chrome.manifest
<?xml version="1.0"?>
<RDF xmlns="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:em="http://www.mozilla.org/2004/em-rdf#">
  <Description about="urn:mozilla:install-manifest">
    <em:id>myext@mydomain.org</em:id>
    <em:version>0.1.0</em:version>
    <em:type>2</em:type>
    <em:targetApplication>
      <Description>
        <em:id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</em:id> <!-- Firefox -->
        <em:minVersion>1.0</em:minVersion>
        <em:maxVersion>3.0.*</em:maxVersion>
      </Description>
    </em:targetApplication>
    <em:name>MyExt</em:name>
    <em:description>A very simple demo extension</em:description>
    <em:creator>My Self</em:creator>
    <em:homepageURL>http://mydomain.org/myext/</em:homepageURL>
  </Description>      
</RDF>
myext@mydomain.org\install.rdf
netlog.cpp
   Example for sending UDP color text in C++.
   For more details read "sfk netlog".
   Compile like:
      Windows gcc : g++ %s -lws2_32
      Windows VC  : cl  %s ws2_32.lib
      Linux/Mac   : g++ %s
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <errno.h>
#ifdef _WIN32
  #include <windows.h>
  #ifdef _MSC_VER
    #define snprintf  _snprintf 
    #define vsnprintf _vsnprintf 
    #define sockerrno WSAGetLastError()
  #else
    #include <ws2tcpip.h>
    #define sockerrno errno
  #endif
  #define socklen_t int
#else
  #include <sys/socket.h>
  #include <netdb.h>
  #ifdef __APPLE__
    #define SOL_IP IPPROTO_IP
  #endif
  #ifndef INVALID_SOCKET
    #define INVALID_SOCKET -1
  #endif
  #define sockerrno errno
#endif
char szLineBuf[500];
int iNetSock = INVALID_SOCKET;
int iRequest = 1;
struct sockaddr_in oAddr;
socklen_t iAddrLen = sizeof(oAddr);
int perr(const char *pszFormat, ...)
   va_list argList;
   va_start(argList, pszFormat);
   vsnprintf(szLineBuf, sizeof(szLineBuf)-10, pszFormat, argList);
   szLineBuf[sizeof(szLineBuf)-10] = '\0';
   printf("Error: %s\n", szLineBuf);
   return 0;
int netlog(const char *pszFormat, ...)
   char szHeadBuf[100];
   int  iHeadLen = 0;
   va_list argList;
   va_start(argList, pszFormat);
   vsnprintf(szLineBuf+100, sizeof(szLineBuf)-110, pszFormat, argList);
   szLineBuf[sizeof(szLineBuf)-10] = '\0';
   // change all [red] to compact color codes \x1Fr
   for (char *psz=szLineBuf+100; *psz; psz++)
      if (psz[0]=='[')
         for (int i=1; psz[i]; i++)
            if (i>=2 && psz[i]==']')
               { psz[0]=0x1F; memmove(psz+2, psz+i+1, strlen(psz+i+1)+1); break; }
   // add sfktxt header before text
   snprintf(szHeadBuf, sizeof(szHeadBuf)-10, ":sfktxt:v100,req%s,cs1\n\n", iRequest++);
   iHeadLen = strlen(szHeadBuf);
   char *pData = szLineBuf+100-iHeadLen;
   memcpy(pData, szHeadBuf, iHeadLen);
   sendto(iNetSock, pData, strlen(pData), 0, (struct sockaddr *)&oAddr, iAddrLen);
   return 0;
int main(int argc, char *argv[])
   const char *pszHost = "localhost";
   unsigned short iPort = 21323;
   #ifdef _MSC_VER
   WORD wVersionRequested = MAKEWORD(1,1);
   WSADATA wsaData;
   if (WSAStartup(wVersionRequested, &wsaData)!=0)
      return 9+perr("WSAStartup failed");
   #endif
   memset((char *)&oAddr, 0,sizeof(oAddr));
   oAddr.sin_family      = AF_INET;
   oAddr.sin_port        = htons(iPort);
   struct hostent *pHost = gethostbyname(pszHost);
   memcpy(&oAddr.sin_addr.s_addr, pHost->h_addr, pHost->h_length);
   if ((iNetSock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
      return 9+perr("cannot create socket");
   netlog("[Red]Foo[def] and [Blue]bar[def] went to the [Green]zoo[def].\n");
   return 0;
// to write .cpp file use:
// sfk samp cppnetlog netlog.cpp
   Example for sending UDP color text in Java.
   For more details read "sfk netlog".
import java.io.*;
import java.net.*;
public class %s
   public static DatagramSocket clSocket = null;
   public static InetAddress clAddress = null;
   public static int iClPort = -1;
   static int iClRequest = 1;
   public static void init(String sHost, int iPort) throws Throwable
   {
      clAddress = InetAddress.getByName(sHost);
      iClPort = iPort;
      clSocket = new DatagramSocket();
   }
   public static void log(String sTextIn) throws Throwable
   {
      String sText   = sTextIn+"\n";
      // change all [red] to compact color codes \x1Fr
      byte[] abData1 = sText.getBytes();
      int    iSize1  = abData1.length;
      byte[] abData2 = new byte[iSize1+100];
      // keep 100 bytes space for header
      int i2=100;
      for (int i1=0; i1<iSize1;)
      {
         if (abData1[i1]=='[') {
            i1++;
            if (i1>=iSize1)
               break;
            abData2[i2++] = (byte)0x1F;
            abData2[i2++] = abData1[i1++];
            while (i1<iSize1 && abData1[i1]!=']')
               i1++;
            if (i1<iSize1)
               i1++;
         } else {
            abData2[i2++] = abData1[i1++];
         }
      }
      int iTextSize = i2-100;
      // add sfktxt header before text
      String sHead = ":sfktxt:v100,req"+iClRequest+",cs1\n\n";
      iClRequest++;
      byte abHead[] = sHead.getBytes();
      int iHeadLen  = abHead.length;
      for (int i=0; i<iHeadLen; i++)
         abData2[100-iHeadLen+i] = abHead[i];
      int iStartOff = 100-iHeadLen;
      int iFullSize = iHeadLen+iTextSize;
      DatagramPacket packet = new DatagramPacket(abData2, iStartOff, iFullSize, clAddress, iClPort);
      clSocket.send(packet);
   }
   public static void main(String args[]) throws Throwable
   {
      %s.init("localhost", 21323);
      %s.log("[Red]Foo[def] and [Blue]bar[def] went to the [Green]zoo[def].");
   }
// to write .java file use:
// sfk samp javanetlog netlog.java
memerrtest
keytest
key_%03d
val_%03d
fail.1
%d entries in keymap
%s %s
zipdump
no directory: %s
entry: %s dir=%d size=%d time=%u
   ... open rc %d
   ... nread %d
match
no hit
errortest
<help>$sfk [options] errortest mask
   produces test error(s), showing return codes.
   this command implies -showrc.
   $mask
   may contain one or more characters to select
   a test case from:
      n   normal file processing (no error).
      e   produce a syntax error.
      w   produce a general warning.
      f   simulate (skipped) unreadable file.
      m   simulate out of memory.
      l   simulate general error with low rc.
   $options
      -rcfromerr   on skipped errors, pass rc to shell.
      -stoponerr   stop on first unreadable file.
   $example
      #sfk -rcfromerr errortest nnnfnn
         simulates five successful and one erroneous file
         processings, changing the shell rc on any errors.
file processed, 
stopped
continued
processing %s.
%d=stopTree(%d)
syntax test error
general test warning
file unreadable.
   processing %s.
non-fatal fn error.
<help>$sfk cat filename
   dump content of a text file.
missing filename.
main
cannot get content of: %s
tcping
<help>$sfk tcping host:port [options]
   check if a host accepts tcp/ip connections
   $options
      -loop     retry endlessly until connect
      -delay=n  delay seconds between tries
   $examples
      #sfk tcping myhost:80 -loop
         try to connect until service is available
-loop
cannot get host
not yet available, retrying (%d)   
connected.                              
cmptime
rc %d srcio %d
tellnode
%s (%u) %s
fscript
<help>$sfk [f]script [opts] file [-from=label] [parm1] [parm2] [...]
   execute sfk command(s) from a script file, which can be
    - an absolute filename, e.g. C:\scripts\thescript.txt
    - a relative filename. in this case, the file is searched
      in the current dir "." first, and then in the PATH.
   $parameters:
    - if "-from=label" is given, the script file is searched
      for a statement "label mylabel", and script execution runs
      from this point until +end is reached.
    - all other words after -from, or instead of from, are passed
      as parameters to the script, with one exception:
      a word starting with a "+" continues the sfk command chain.
      if you need to pass words starting with "+" to the script,
      set option -literal (disallowing further chain commands).
   $command chaining:
      with ...  +script name, text data is passed to the script.
      with ... +fscript name, filenames are passed to the script.
   $script file syntax:
      - lines having // as first text are ignored.
      - command line parameters 1 to 9 can be addressed both
        by expressions %%1 to %%9, or $$1 to $$9.
      - any whitespace is skipped unless surrounded by quotes "
      - escaped quotes \" are changed into normal quotes "
      - line ends are ignored. in general, lines are combined
        into one large command chain, just like typing them all
        into one line of unlimited length.
      - character ## at column 1 of any line is skipped, which
        allows bash-embedded scripts to have sfk statements
        outcommented if necessary.
      $parameter name collisions:
        if your script contains phrases like
           #+filter -form "$$10.10col1 ..."
        then "$$1" will be misinterpreted as an input parameter
        into the script. to get around this problem, redefine the
        parameter name prefix at the script's "sfk label" line.
        type "sfk label" for more on that.
   $options
      -verbose  tell in detail which words are used from script.
      -literal  also pass words to the script that start with "+".
   $for script examples, type:
      sfk samp sfk       - create sfk sample script
      sfk samp sfkcmd    - sample script embedded in windows batch
      sfk samp sfkbash   - sample script embedded in bash script
      sfk samp           - more about the sfk sample syntax
   $recommended use:
      if you want to create an easy-to-use script on the fly,
      1. create an embedded script in a batch file:
         #sfk samp sfkbash myscript.bat
      2. edit myscript.bat with any text editor.
      3. run the script just by typing "myscript.bat".
missing script file name.
%s not found in current dir or PATH.
failed to load script file: %s
loaded %d words from %s:
clipsrc
clipxml
clipphp
clipjava
fromclip +filter -rep _\_\\\_ -srep _\q_\\\q_ -sform \q%ccol1\\n\q
fromclip +xmlform
fromclip +filter -rep _\_\\\_ -srep _\q_\\\q_ -sform .\q%ccol1\\n\q
fromclip +filter -rep _\_\\\_ -srep _\q_\\\q_ -sform +\q%ccol1\\n\q
missing parm
0x%04X=%u >%c%c< - 0x%04X=%u >%c%c<
0x%08X=%u >%c%c%c%c< - 0x%08X=%u >%c%c%c%c<
<help>$sfk hex value1 [value2] [...]
$sfk dec value1 [value2] [...]
$sfk ... +dec [+hex] -digits=n
   convert numbers between decimal and hexadecimal.
   largest convertable number is ((2 << 64) - 1).
   $options
      -digits=n  format output numbers with n digits
   $examples
      #sfk hex 1048576 98765 234567
         convert 3 decimal numbers.
      #sfk filt csv.txt -ssep "\t" -form "$$col3" +hex
         convert 3rd column from csv.txt to hex.
int. #58282010
cannot convert to hex, not a number: %s
<help>$sfk env [-all] [word] [word2] [...] +...
   list contents of environment variables having
   all supplied words in their name or content.
   $options
      -all   dump contents of all env variables. when chaining
             output to another command, and no words are given,
             specifying -all is optional (see example below).
   $examples
      #sfk env path
         lists anything with PATH in name or content,
         e.g. CLASSPATH, HOMEPATH, or PATHEXT.
      #sfk env +filter -ls+path=
         lists content of the PATH variable.
missing environment
label
<help>$sfk label name [options] +...
$sfk ... +label name +...
   define a label at the beginning or within an sfk script.
   a label is a user-defined name that can be jumped to
   by the sfk script command.
   $options
      -prefix=s    set user-defined input parameter name prefix
      by default, parameters passed into sfk scripts are called $$1 to $$9,
      or %%1 to %%9. with -prefix, you can define your own parameter names,
      e.g. if you rewrite the sfk label line like this:
         sfk label begin -prefix=$$parm
      then the input parameters are renamed to $$parm1, $$parm2, ...
      accepting no other names. or simply say
         sfk label begin -prefix=%%
      to accept ONLY %%1 to %%9 but NOT $$1 to $$9, to get around conflicts
      with script commands using expressions like "$$10.10col1".
   $examples
      #sfk samp sfkcmd mytest.bat
         creates a windows batch file mytest.bat
         with an embedded sfk command script.
      #sfk samp sfkbash mytest
         creates a linux batch file mytest
         with an embedded sfk command script.
   $see also
      #sfk script<def>   how to run sfk scripts.
missing labelname before %s
if %s is a command, try +%s
[nopre] label: %s
ftee
<help>$sfk ... +tee [tofile] filename.txt
$sfk ... +tee toterm
   split current command chain data into two streams.
   stream one is passed to the next command in the chain.
   stream two is written to file, or printed to terminal.
   $see also
      sfk tofile      for file output options
      sfk toterm      for terminal output options
   $examples
      #sfk list testfiles .txt +tee toterm +fview
         list selected files on terminal AND open in dview.
tofile
toterm
append
appendto
<help>$sfk ... +tofile filename
$sfk ... +toterm
   save current command chain data in a file, or print it to terminal,
   and then clear the chain. (next command in the chain will start
   without any chain input data).
   $options
      -append      append to output file, instead of overwriting.
   $aliases
      +append[to]  same as +tofile -append.
   $see also
      sfk tee      same as tofile, toterm but also passes chain data
                   to the next chain command (no clearing of chain).
   $examples
      #sfk list testfiles +toterm +run "sfk echo [[Blue]]done[[def]]" -yes
         list selected files on terminal, then run a completely
         independent command which does NOT use chain input.
      #sfk echo hello1 +tofile output.txt
      #sfk echo hello2 +append output.txt
         create a new textfile output.txt with the first command,
         then append further output with subsequent commands.
+tofile: missing output filename.
storetext
<help>$sfk ... +storetext
   store current chain text for later use by gettext.
   see "sfk tail" for a script example.
   $options
     -append    do not reset previously stored text
                but append current chain text to it.
gettext
<help>$sfk ... +gettext
   get chain text stored by storetext.
   see "sfk tail" for a script example.
<help>$sfk ... +stop [rc]
   stop command chain execution.
   returns with code 0 or given rc.
   see "sfk tail" for a script example.
<help>$sfk ... +xmlform[3]
   simple, line oriented XML text reformatter, just to
   change indentation and add colors for easy reading.
   not suitable for XML data with lines longer than 3900
   characters approx. as these will be hard wrapped!
   not suitable for XML with more than one tag per line
   like <foo><bar>...</bar></foo> as this will not be
   split into lines and therefore not reformatted.
   $chain-only command
      xmlform can be used only #after another command<def>,
      like filter, which reads the input data.
   $options
     -indent=3  or typing "sfk xmlform3" selects an
                indent of 3 instead of the default 2.
   $examples
     #sfk filter in.xml +xmlform
       read the file in.xml and print it reformatted
     #sfk xex in.xml "x<web_info>**</web_info>x[part2]x"
      #+xmlform +view
       extract a web_info multi line text block,
       reformat and display it in Depeche View. [22]
       this uses 'x' as a separator character as '/'
       and '_' are already part of the search text.
     #sfk webreq http://myserver/getxml.php +xmlform
       call a web URL that sends an xml reply
       and reformat output for easy reading.
missing chain text input
<?xml
<help>$sfk ... +sort
   sort text lines, case insensitive by default.
   requires a previous command producing text output.
   $options
      -case        case sensitive text comparison
      -rev[erse]   reverse sorting order
   $examples
      #sfk filter csv.txt +sort
         print sorted contents of csv.txt
missing chain text input for +sort
need a previous command producing text output
-rev
difflines
missing chain text input for +difflines
missing text filename.
spell
nato
<help>$sfk spell [phrase]
   show spelling table, or spell a phrase, i.e.
   print one word per character of a word/phrase
   for clear transmission over telephone.
   primarily used for email addresses which must
   be accurate by every character.
   $options
      -nato  use original Nato spelling table.
             default is to use an optimized mix
             of Nato/RAF.
   $aliases
      #sfk nato<def>    same as sfk spell -nato
-nato
[nopre] === Standard Nato phonetic alphabet ===
[nopre] === Optimized Nato/RAF alphabet. Use "sfk nato" for standard alphabet. ===
<help>$sfk ... +count [-same[lines]]
   count total number of text lines, or group identical
   text lines, counting the number of occurences per line.
   $options
      -samelines  count number of occurences per line, then
                  prefix lines by TAB separated counter.
      -digits=n   with -samelines, change no. of counter digits
      -case       case sensitive text comparison
   $see also
      #sfk filter<def>  with -unique, to strip duplicate lines.
   $examples
      #sfk filter words.txt +count -same -digits=10
         tell how often each line occurs in words.txt,
         and format the occurence counter with 10 digits.
missing chain text input for +count
-same
then
missing command after "sfk"
dump-console-intro
<help>$SFK - The Swiss File Knife File Tree Processor.
 Revision 
Release 1.7.4 %s%s%s%s of Apr 15 2015.
StahlWorks Technologies, http://stahlworks.com/
Distributed for free under the BSD License, without any warranty.
$sfk main help (just type "sfk"):
<file>type "sfk commandname" for help on any of the following.<def>
some commands require to add "-help" for the help text.
file system
   sfk list       - list directory tree contents.
                    list latest, oldest or biggest files.
                    list directory differences.
                    list zip jar tar gz bz2 contents.
   sfk filefind   - find files by filename
   sfk treesize   - show directory size statistics
   sfk copy       - copy directory trees additively
   sfk sync       - mirror tree content with deletion
   sfk rename     - flexible multi file rename
   sfk partcopy   - copy part from a file into another one
   sfk mkdir      - create directory tree
   sfk delete     - delete files and folders
   sfk deltree    - delete whole directory tree
   sfk deblank    - remove blanks in filenames
   sfk space [-h] - tell total and free size of volume
   sfk filetime   - tell times of a file
   sfk touch      - change times of a file
   sfk index      - create index file(s) for fast lookup
   sfk iname      - lookup file names using index files
conversion
   sfk lf-to-crlf - convert from LF to CRLF line endings
   sfk crlf-to-lf - convert from CRLF to LF line endings
   sfk detab      - convert TAB characters to spaces
   sfk entab      - convert groups of spaces to TAB chars
   sfk scantab    - list files containing TAB characters
   sfk split      - split large files into smaller ones
   sfk join       - join small files into a large one
   sfk csvtotab   - convert .csv data to tab separated
   sfk tabtocsv   - convert tab separated to .csv format
   sfk hexdump    - create hexdump from a binary file
   sfk hextobin   - convert hex data to binary
   sfk hex        - convert decimal number(s) to hex
   sfk dec        - convert hex number(s) to decimal
   sfk chars      - print chars for a list of codes
   sfk bin-to-src - convert binary to source code
text processing
   sfk filter     - search, filter and replace text data
   sfk replace    - replace words in binary and text files
   sfk xex        - extract text from stream using expressions
   sfk xed        - XE: edit text stream using sfk expressions
   sfk xreplace   - XE: replace in files using sfk expressions
   sfk run        - run command on all files of a folder
   sfk runloop    - run a command n times in a loop
   sfk printloop  - print some text many times
   sfk head       - print first lines of a file
   sfk tail       - print last lines of a file
   sfk snapto     - join many text files into one file
   sfk addhead    - insert string at start of text lines
   sfk addtail    - append string at end of text lines
   sfk joinlines  - join text lines split by email reformatting
   sfk strings    - extract strings from a binary file
   sfk sort       - sort text lines produced by another command
   sfk count      - count text lines, filter identical lines
   sfk linelen    - tell length of string(s)
   sfk patch      - change text files through a script
   sfk inst       - instrument c++ sourcecode with tracing calls
search and compare
   sfk find       - find words in text and binary files
   sfk ftext      - find words only in text files
   sfk hexfind    - find words in binary files, showing hexdump
   sfk xfind      - find using wildcards and sfk expressions
   sfk xtext      - find using wildcards in text files only
   sfk xhexfind   - same as xfind but with hexdump output
   sfk extract    - extract data from files using expressions
   sfk md5gento   - create list of md5 checksums over files
   sfk md5check   - verify list of md5 checksums over files
   sfk md5        - calc md5 over a file, compare two files
   sfk pathfind   - search PATH for location of a command
   sfk reflist    - list fuzzy references between files
   sfk deplist    - list fuzzy dependencies between files
   sfk dupfind    - find duplicate files by content
networking
   sfk httpserv   - run an instant HTTP server.
                    type "sfk httpserv -help" for help.
   sfk ftpserv    - run an instant FTP server
                    type "sfk ftpserv -help" for help.
   sfk ftp        - instant anonymous FTP client
   sfk wget       - download HTTP file from the web
   sfk webrequest - send HTTP request to a server
   sfk tcpdump    - print TCP conversation between programs
   sfk udpdump    - print incoming UDP requests
   sfk udpsend    - send UDP requests
   sfk ip         - tell own machine's IP address(es).
                    type "sfk ip -help" for help.
   sfk netlog     - send text outputs to network,
                    and/or file, and/or terminal
   sfk fromnet    - receive and print network text
scripting
   sfk script     - run many sfk commands in a script file
   sfk echo       - print (coloured) text to terminal
   sfk color      - change text color of terminal
   sfk alias      - create command from other commands
   sfk mkcd       - create command to reenter directory
   sfk sleep      - delay execution for milliseconds
   sfk pause      - wait for user input
   sfk label      - define starting point for a script
   sfk tee        - split command output in two streams
   sfk tofile     - save command output to a file
   sfk toterm     - flush command output to terminal
   sfk loop       - repeat execution of a command chain
   sfk cd         - change directory within a script
   sfk getcwd     - print the current working directory
   sfk require    - compare version text
   sfk time [-h]  - print current date and time
development
   sfk bin-to-src - convert binary data to source code
   sfk make-random-file - create file with random data
   sfk fuzz       - change file at random, for testing
   sfk sample     - print example code for programming
   sfk inst       - instrument c++ with tracing calls
diverse
   sfk xmlform    - reformat xml for easy viewing
   sfk media      - cut video and binary files
   sfk view       - show results in a GUI tool
   sfk env        - search environment variables
   sfk version    - show version of a binary file
   sfk ascii      - list ISO 8859-1 ASCII characters
   sfk ascii -dos - list OEM codepage 850 characters
   sfk spell [-h] - phonetic spelling for telephone
   sfk cmd        - print an example command
   sfk license    - print the SFK license text
help by subject
   sfk help select   - how dirs and files are selected in sfk
   sfk help options  - general options reference
   sfk help patterns - wildcards and text patterns within sfk
   sfk help chain    - how to combine (chain) multiple commands
   sfk help shell    - how to optimize the windows command prompt
   sfk help unicode  - about unicode file reading support
   sfk help colors   - how to change result colors
   sfk help compile  - how to compile sfk on any linux system
   sfk help xe       - for infos on sfk extended edition.
   $All tree walking commands support file selection this way:
   1. short format with ONE directory tree and MANY file name patterns:
      #src1dir .cpp .hpp .xml bigbar <not>footmp
   2. short format with a list of explicite file names:
      #letter1.txt revenues9.xls report3<sla>turnover5.ppt
   3. long format with MANY dir trees and file masks PER dir tree:
      #-dir src1 src2 <not>src<sla>save -file foosys .cpp -dir bin5 -file .exe
   For detailed help on file selection, type #"sfk help select"<def>.
   %s and ? wildcards are supported within filenames. "foo" is interpreted
   as "%cfoo%c", so you can leave out %s completely to search a part of a name.
   For name start comparison, say "%cfoo" (finds foo.txt but not anyfoo.txt).
   When you supply a directory name, by default this means "take all files".
   Use %c or \* instead of *, and \? instead of ?, as * and ? are eaten by the
   command shell. You may also redefine %c through export SFK_CONFIG=wildstar:c
      #sfk list mydir<def>                lists ALL  files of mydir, no * needed.
      #sfk list mydir .cpp .hpp<def>      lists SOME files of mydir, by extension.
      #sfk list mydir <not>.cfg<def>          lists all  files of mydir  EXCEPT .cfg
   $general options:
      -tracesel  tells in detail which files and/or directories are included
                 or excluded, and why (due to which user-supplied mask).
      -nosub     do not process files within subdirectories.
      -nocol     before any command switches off color output.
      -quiet     or -nohead shows less output on some commands.
      For detailed help on all options, type #"sfk help options".
   $beware of Shell Command Characters.
      parameters containing #spaces<def> or characters #<>|!&?*<def> must be #sur-
      #rounded by quotes ""<def>. type "#sfk filter<def>" for details and examples.
   WRONG COLORS? Use one of:
      <exp> SFK_COLORS=theme:black    for DARK   backgrounds
      <exp> SFK_COLORS=theme:white    for BRIGHT backgrounds
      see also "sfk help colors"
   type #"sfk ask word1 word2 ..."<def>   to search ALL help text for words.
   type #"sfk dumphelp"<def>              to print  ALL help text.
      +------------------------------------------------------+ 
      | Get the #three dollar e-book<def> from #stahlworks.com/pdf<def>  | 
      | Get the #250 page paperback<def>  from #stahlworks.com/book<def> | 
      |------------------------------------------------------| 
      |  Search all text files of a folder in realtime with  | 
      |   Depeche View. Freeware from #www.depecheview.com<def>    | 
      +------------------------------------------------------+ 
ascii
please type just "sfk" to list the sfk main help.
%s SFK_COLORS=off|on,def:n,err:n,warn:n,head:n,examp:n,file:n,hit:n,rep:n,pre:n
%s SFK_COLORS=bright|dark,theme:black|theme:white
   color identifiers are
      def       default color (black by default)
      err       error   messages
      warn      warning messages
      head      headlines in help text
      examp     examples  in help text
      file      filename listings in find
      link      symbolic link files or directories
      hit       text pattern hits in find and filter
      rep       replaced patterns in filter
      pre       line prefix symbols in find
      time      time or low-prio status infos
      traceinc  with -tracesel, included names
      traceexc  with -tracesel, excluded names
   color code n is a combination of these values:
      0 = black
      1 = bright
      2 = red
      4 = green
      8 = blue
   some commands like "sfk echo" also accept direct color names:
   red,green,blue,yellow,cyan,magenta,default,Red,Green,Blue...
   sfk for windows tries to autoselect color brightness if a black
   or white shell background is found. otherwise the spelling matters:
   red means dark red, and Red means bright red.
   you may also set SFK_COLORS to bright or dark, or specify options
   -bright or -dark in your command, to force all plain text colors
   to the same brightness, regardless of spelling.
   examples for color schemes:
      neutral, compatible to black and white backgrounds:
         <exp> SFK_COLORS=head:5,examp:11,file:11,hit:5,rep:7
      black background optimized theme:
         <exp> SFK_COLORS=theme:black
      white background optimized theme:
         <exp> SFK_COLORS=theme:white
      switch off colored output:
         %s SFK_COLORS=off
   by default, colors are inactive on unix, as there are some potential problems
   depending on the background color of your shell, and if you want to post-process
   command output. if you feel lucky, add -col in front of a command, or say
      export SFK_COLORS=on,def:0      or    export SFK_COLORS=on,def:14
      with bright shell backgrounds         with black shell backgrounds
   to TEST current active colors, type: sfk colortest
<help>$sfk help ascii  (or just "sfk ascii")
   print a table of ASCII characters with their codes.
ASCII
-ansi
-dos
Character set: ASCII from 0 to 127, codes above depending on your terminal.
        
EOT 
BEL 
BS  
FF  
CR  
LF  
TAB 
 (type "sfk help options")
$sfk general options reference%s:
   Please note: some of these options are supported only by some commands.
   $-nosub<def>     or -norec does not include subdirectories (subfolders).
              processing of subdirs is DEFAULT with most commands,
              therefore you must specify -nosub to switch it off.
   $-withsub<def>   include subdirs. is DEFAULT with most commands.
   $-verbose<def>   print additional infos while running a command.
              helpful if a command doesn't work as expected.
              only some commands support -verbose. try also -verbose=2.
   $-nofollow<def>  or -nofo does not follow symbolic directory links.
              this option may NOT work with older Linux versions,
              esp. those needing the "lib5" binary version of sfk.
   $-showskip<def>  tell whenever directory contents are skipped to avoid
              double processing caused by symbolic links.
   $-allowdups<def> disable detection of duplicate directory contents.
                 may cause endless recursion on links like "X11"->"."
   $-quiet<def>     reduce output on some commands. e.g. the find command will
              not display the "scan" status info while searching files.
   $-quiet=2<def>   reduce output even more on some commands.
   $-debug<def>     print extra program flow infos to track errors.
   $-nohead<def>    no not list header/trailer info on some commands: the run cmd
              will not tell "simulating" even if it's in simulation mode.
   $-case<def>      activate case sensitive text comparison with some commands.
              most text processing commands are case-insensitive by default.
              filename comparison is always case insensitive.
   $-hidden<def>    include hidden and system files.
   $-nohidden<def>  exclude hidden and system files.
   $-yes<def>       fully execute the command. some commands like "run" are
              running in simulation mode by default, to avoid damage to your
              files, as long as you're unsure which files and dirs to select.
              as soon as you add -yes, however, everything is fully executed.
   $-minsize=s<def> select only files >= size, like 10b or 100k
   $-maxsize=s<def> select only files <= size, like 10m or 4g
              b=bytes k=kbytes m=megabytes g=gigabytes=10^9 bytes
              K=2^10 bytes M=2^20 bytes G=2^30 bytes
   $-textfiles<def> process only text files, no binaries. -text is the same,
              but this may interfere with some command's local -text option.
              text/binary detection only checks the file's first 4 kbytes.
   $-binfiles<def>  process only binary files. -bin is the same, but this may
              interfere with some command's local -bin option.
   $-umlauts<def>   with binary-to-text conversion, include german characters.
   $-nocol<def>     disable all colored output. important if your shell has
              a background color incompatible to the default color scheme,
              or (under linux) if the sfk output text must be processed
              further through pipelining, and needs to be stripped from
              the color escape sequences.
   $-col<def>       switch on colored output. "sfk help colors" for more.
   $-html<def>      dump sfk help text (color control) in html format.
              -html must be typed directly after "sfk".
   $-htmlpage<def>  the same, but include a header to view it in a browser.
   $-sincedir<def>  or -sincedif/add/chg: compare directory tree against
              a reference tree, process only changed or added files.
              see "sfk list" for details.
   $-tracesel<def>  give verbose infos why directories and files have been
              selected or excluded. -tracedirs lists only directories,
              -tracefiles lists only files.
   $-since<def>     process only files changed on or after the supplied
              date/timestamp. "sfk list" for details.
   $-before<def>    process only files changed before that date/timestamp.
   $-flist fn<def>  or "-fl fn" reads list of filenames from file fn.
   $-spat<def>      activates interpretation of slash patterns:
              \t=TAB \q=" \r=CR \n=LF \\=\ \xnn=any char w/hex code nn
              with some commands like replace, filter -form and -replace.
   $-literal<def>   or -lit disables interpretation of wildcards * and ?
              and slash patterns, if they were activated previously.
   $-nospat<def>    disables only slash patterns.
   $-noipex<def>    disable automatic IP expansion with some commands.
   $-arc<def>       with sfk list, lists also archive file contents.
              with some other commands, also process archive file contents.
              archives recognized by sfk must have one of these extensions:
              .zip .jar .ear .war .aar .xpi .tar .tar.gz .tar.bz2 .tgz .gz .bz2
              to include further extensions, read below about SFK_ZIP_EXT.
              this binary (SFK Base/XD) can read only the first 1000 bytes
              of every archive entry. listing of contents is not limited.
              type "sfk help xe" for all details and restrictions.
   $-wchar<def>     activate EXPERIMENTAL utf-16 (ucs-2, wide char) decoding,
              allowing sfk find or filter to search text in utf-16 files.
              should not be used when (re)writing files. get more infos
              by typing "sfk help unicode".
   $-to mask<def>   specify where to write output files with some commands.
              mask supports <run>file, <run>path, <run>base, <run>ext and more,
              like -to outdir<sla><run>base-modified.<run>ext
              say "sfk run" for a list of possible keywords.
   $-tofile x<def>  specify a single output filename, which is taken as is
              and not checked for any <run> patterns.
   $-tmpdir x<def>  set directory x as temporary file directory. default is
              to use the path specified by TEMP or TMP env variable,
              or the /tmp directory, if no such variable is defined.
   $-showtmp<def>   tell verbosely which temporary files are created.
   $-keeptmp<def>   do not delete the temporary files, if possible.
   $-nowarn<def>    and -noerr, -nonote disable warn, error and note messages.
   $-memlimit=n<def> set the caching memory limit to n mbytes (default=%d).
              used if a function needs to load whole files into memory.
              if zip etc. archive processing is very slow, it may be caused by
              a cache overflow. try to increase the -memlimit then.
              if you think sfk uses too much memory while processing files,
              try to reduce -memlimit (values below 200 are not recommended).
              you may also set SFK_CONFIG (see end of this text).
   $-cachestat<def> tell amount of memory used by archive file cache.
   $-nocache<def>   disable the disk cache (for network files).
   $-exectime<def>  tell command execution time at program end.
   $shell return code handling and error processing:
   $-showrc<def>    print sfk return code at program end. may not print anything
              in case of fatal errors, like wrong syntax (usually rc 9).
   $-exterr<def>    in case of operating system related errors like file access,
              prints extended error information, if available.
   $-waitonerr<def> wait for user input on every error.
   $-waitonend<def> wait for user input at program end.
   $-stoponerr<def> stop directory tree processing on first unreadable file.
              default is to process as many files as possible, skipping
              unreadable files and directories.
   $-rcfromerr<def> some commands like filter, find, hexfind tell by shell rc
              that something was found. by default, skipped errors like
              unreadable files do NOT change this rc. with -rcfromerr,
              skipped errors do override the resulting shell rc.
   $-echoonerr<def> echo whole command to stderr when an error occurs.
              see also the SFK_CONFIG setting "echoonstart" below.
   to experiment with the above options, try "sfk errortest".
   $command local versus global scope:
      within a command chain, many options have an effect only locally
      with the command where they are specified, e.g. in
         #sfk filt x.txt -case -high red FooCase +filt -high blue TheBar
      the "-case" is valid only for the first filter command.
      but the following options can also be used globally, if specified
      directly after "sfk":
         $-nohead -noinfo -nofile -case -literal -spat
      for example, in
         #sfk -case filt x.txt -high red FooCase +filt -high blue TheBar
      the "-case" is valid for ALL commands in the command chain.
   $environment configuration:
      $%s SFK_CONFIG=columns:n,active-file-age:n,memlimit:n,...
        columns:
          sfk (for windows) tries to autodetect the no. of console columns,
          but you may also set this value through this config parm.
        active-file-age:n
          some functions need to tell if a file is 'recently edited' or rather
          old and inactive. by default, files > 30 days of age are considered
          non-active. reconfigure the no. of days threshold here.
        memlimit:
          set memory limit to n mbytes permanently.
        echoonstart:
          echo the whole sfk command on start, to stderr.
        echoonerr:
          echo the whole sfk command on errors, to stderr.
        tmpdir:path
          set folder for temporary files, used by some commands.
          e.g. set SFK_CONFIG=tmpdir:~/mytmp,memlimit:500
   info: files with a time difference of 1 hour AND an age > %d days
         are skipped by some commands, e.g. list -sincedir.
   info: active file age limit is currently set to %d days.
   info: wildcard star '*' is currently configured as %c
      $%s SFK_ZIP_EXT=".foo .bar .myext"
        set additional, user defined zip file extensions. in this example,
        files ending with .foo, .bar or .myext are also treated like zip files.
        for the list of default extensions, look above at the -arc option.
   sfk currently uses %d console columns for output with some commands.
$Essential Mozilla Firefox (3.x and higher) tips:
  $Creating a profile in a self-defined folder:
    By default, Firefox creates a "default" profile with the Cache hidden under
    $C:\Documents and Settings\USERNAME\Local Settings\Application Data\...
    and installed extensions and config files hidden under
    $C:\Documents and Settings\USERNAME\Application Data\...
    making it very diffcult to access those files directly.
    On the command line, enter the Firefox application directory and type
    #firefox -profilemanager
    then click create/next, type a name like "foo", click "choose folder"
    and select an easy-to-reach directory. After profile creation, type
    #firefox -P foo -no-remote<def> to use it. Option -no-remote allows to run
    multiple Ffox instances with different profiles.
  $Basic settings for Firefox extension developers:
    By default, errors in self-written extensions are not shown.
    Therefore in the address bar, type #about:config<def> and then
    #javascript.options.showInConsole = true
    #extensions.logging.enabled = true
  $Creating own Firefox extensions:
    In the new profile directory, you find an empty directory "extensions".
    The best way to start developing an extension is to search for "firefox addons"
    and install an existing small, simple extensions. During the installation,
    - an ".xpi" file is downloaded by Firefox. this is basically a .zip file.
    - the file is extracted, the contents are placed within "extensions".
    So after installation, you find a new folder under "extensions",
    containing all source code files of that extension.
    The important starting points are #install.rdf<def> and #chrome.manifest<def> .
    Whenever you change anything in the code, you have to restart Firefox
    to apply those changes.
    See also: "sfk sample", "sfk sample firefox".
chain
 (type "sfk help chain")
$sfk command chaining reference%s:
   several commands can be combined in a so-called "command chain".
   this is done by appending command names prefixed by "+", for example:
   #sfk list docs .txt +ffilter -+foo
      "list" produces a filename list and passes this to "filefilter".
      ffilter reads the contents of these files, looking for the word "foo".
   $chain data types
      there are two types of data which can be passed from one command to another:
         #- filename lists.
         #- lines of plain text data.
      some commands produce filename lists, other text data, some both, some none.
   $chain data type conversion
      vice versa, some commands accept filenames, or text input, or even both.
      depending on what you want to do, it may be necessary to convert between
      this types of data. this can be done by the keywords:
         #+texttofilenames<def> or #+ttf<def>
         #+filenamestotext<def> or #+ftt<def>
      however, most sfk commands try to do such conversions automatically.
   $dumping chain data between commands
      #sfk ... +toterm<def>           dumps current chain content to terminal.
      #sfk ... +tofile outfile<def>   dumps chain content to file outfile.
      #sfk cmd1 ... +then cmd2<def>   does NOT pass any data to cmd2.
      in all cases, the chain is cleared. if another command is following,
      it will receive no input from the chain.
   $scope and lifetime of options
      most options are valid only for the command where they are specified.
      if another command follows in the chain, the option is reset.
      but some options may also be specified on a global scope.
      read more on that under "$sfk help options<def>".
   $more syntax details
      further chain control commands are listed where they make sense.
      for example, "sfk tail" shows an example on command chain looping.
 (type "sfk help select")
$sfk file selection reference%s:
   $default principles of most sfk commands:
      - subdirectory (subfolder) processing is done by default.
      - filename comparison is case insensitive.
      - hidden and system files are not processed,
        except for some commands like copy.
      - symbolic links are followed.
        type "sfk help options" on how to change that.
   $how to select directories and contained filenames:
   sfk provides many ways of specifying which files you want to process,
   from very simple but unflexible to very detailed.
   $1. short format file selection:
      $dirname [filemask1] [filemask2] [<not>fileexcludemask] [...]
      this format supports ONE directory name, followed by many file masks.
      it can be used with most commands processing directory trees.
      example:
      #sfk list mydir foo bar .txt .zip <not>-tmp
         selects all files
         - in directory mydir and all its subdirectories
         - having foo OR bar in their filename (no * required)
         - OR which are ending with .txt OR .zip (no *.txt required)
         - but not having -tmp in their filename
      supported by commands:
         list, select, stat, run, detab, scantab, hexdump and some more.
   $2. long format file selection:
      $-dir root1 [root2] [<wild>pathmask<wild>] [...] [-file mask1 [mask2] [...]]
         $[-dir root3 root4 <not>direxcludemask -file mask3 <not>xmask4] [...]
      this format supports
      - several root directory sets, starting with -dir, each of them
        containing many directories, path masks or dir exclusion masks.
        a path mask is an expression in a directory set containing a
        wildcard character "<wild>". a dir exclusion mask is started
        by <not> and may be surrounded by <sla> to select exact dir names.
      - a file mask set per root directory set, starting with -file.
        this may also contain file exclusions starting with <not>
      supported by:
         nearly every command than can process file sets.
      $to select all dirs of current dir except something:
      #-dir . <not>foo       <def>-> exclude subdirs like *foo*
      #-dir . <not>.foo      <def>-> exclude with extension .foo
      #-dir . <not><sla>foo      <def>-> exclude starting with foo
      #-dir . <not>foo<sla>      <def>-> exclude ending with foo
      #-dir . <not><sla>foo<sla>     <def>-> exclude exactly foo
      #-dir . <not><sla>foo<sla>bar<sla> <def>-> exclude subdir combi
      #-dir . <not><wild>.foo<wild>    <def>-> exclude with .foo anywhere
      $to select only sub dirs of current dir with something:
      using wide sub dir expressions:
      #-dir . -subdir foo       <def>-> include paths having *foo*
      #-dir . -subdir <sla>foo      <def>-> include paths having *<sla>foo
      #-dir . -subdir foo<sla>      <def>-> include paths having *foo
      #-dir . -subdir <sla>foo<sla>     <def>-> include paths exactly foo
      #-dir . -subdir .foo      <def>-> include with extension .foo
      #-dir . -subdir <sla>foo<sla>bar<sla> <def>-> include subdir combi
      instead of -subdir, you may also type just -sub
      using compact sub dir expressions:
      #-dir . <wild>foo<wild>      <def>-> include paths having *foo*
      #-dir . <wild><sla>foo      <def>-> include paths having <sla>foo
      #-dir . <wild>foo<sla>      <def>-> include paths having foo<sla>
      #-dir . <wild><sla>foo<sla>     <def>-> include paths exactly foo
      #-dir . <wild>.foo      <def>-> include with extension .foo
      #-dir . <wild><sla>foo<sla>bar<sla> <def>-> include subdir combi
      $exclusion by filename:
      #-file <not>foo        <def>-> exclude all files like *foo*
      #-file <not><sla>foo       <def>-> exclude starting with foo
      #-file <not>foo<sla>       <def>-> exclude ending with foo
      #-file <not><sla>foo<sla>      <def>-> exclude exactly foo
      #-file <not>.foo       <def>-> exclude extension foo
      $inclusion by filename:
      #-file foo         <def>-> include all files like *foo*
      #-file <sla>foo        <def>-> include starting with foo
      #-file foo<sla>        <def>-> include ending with foo
      #-file <sla>foo<sla>       <def>-> include exactly foo
      #-file .foo .bar   <def>-> select .foo and .bar files
      $examples
      #sfk scantab -dir mydir1 mydir2 <wild>include<wild> -file foo bar .hpp
         scans all files for TAB characters
         - in directory mydir1 and all its subdirectories
           AND
         - in directory mydir2 and all its subdirectories
           IF
           - 1. the file path contains the word "include",
             e.g. mydir1\core\include\foosys.hpp
           - 2. the filename contains foo OR bar
           - 3. or the filename ends with .hpp
      #sfk scantab -dir mydir1 <not>include -file <not>.tmp <not>.save
         scans all files for TAB characters in folder mydir1,
         excluding all sub dirs having "include" in their name,
         and excluding all .tmp and .save files.
      #sfk list -dir source include -subdir save <not>.svn -file .bak
         list .bak files from directory trees source and include,
         within in sub directories having "save" in their name,
         excluding sub directories ending with ".svn".
      #sfk list -dir source include <wild>save <not>.svn -file .bak
         the same as above, written in compact subdir format:
         subdir inclusion masks require a wildcard <wild> anywhere
         to make it clear they're no root directories.
         subdir exclusion masks can stay as they are.
   $3. single parameter file set selection:
      some commands like find, filter or tail do not accept the full
      short format, but only a single file or dir parameter, as it
      would get too complicated mixing the short format with local
      options. find more on that in the command's local help.
   $4. passing filename lists in command chains:
      instead of selecting files in the current command, you may use
      a filename list created by a previous command, for example:
      #sfk select mydir .txt +detab=3
         selects all .txt files from directory mydir, then passes
         this file list to detab, where the files are detabbed.
      command chaining is more intuitive, as you can play around
      with different file sets before executing actual changes
      on the selected files.
      #sfk filter names.txt +texttofilenames +list -late
         provided that names.txt contains a list of filenames,
         this command chain lists the most recent of these files.
         note that in this case, it is unclear if to pass
         - the filename "names.txt" or
         - the line contents from within names.txt
         as filenames to "list", therefore we need to insert
         +texttofilenames or +ttf to enforce a conversion.
      supported by:
         some commands. check each command's local help for more.
   $see also
      #sfk help options<def>  general options for most commands.
      #sfk list<def>          for more file selection examples.
 (type "sfk help patterns")
$sfk wildcards and text patterns%s:
   $available wildcards:
      * = any number of characters.
      ? = a single character.
   $available slash patterns:
      \t   = TAB
      \q   = double quote "
      \r   = carriage return
      \n   = linefeed
      \xnn = any character with hexadecimal value nn,
             e.g. \x09 is the same as \t (TAB)
      \\   = the backslash \ itself
      \\*   = the star '*' itself     [only with some commands]
      \?   = quotation mark '?'      [only with some commands]
   $support by commands:
      if any command supports slash patterns,
      - they are not active by default, except for commands
        starting with "x" that use SFK Expressions.
      - to use, say -spat directly after the command name:
        #sfk echo -spat "three\tlittle\ttabs\t."
        prints: #three   little  tabs    .
      - to activate slash patterns globally over multiple commands
        of a command chain, say -spat directly after "sfk":
        #sfk -spat echo "two\ttabs" +filter -rep "x\tx_x"
        prints: #two_tabs
      if any command supports wildcards,
      - they are active by default.
      - they can be deactivated by option -literal or -lit,
        if you need to find/replace '*' or '?' characters themselves:
        #sfk echo "*** ok ***" +filter -lit -rep "_*_=_"
        prints: #=== ok ===
      - to deactivate globally over multiple commands of a chain,
        say -literal directly after "sfk":
        #sfk -literal echo "*** ok ???" +filter -lit -rep "_?_!_"
        prints: #*** ok !!!
      - another way to find/replace '*' or '?' is to say -spat
        and then to use \\* and \? patterns:
        #sfk echo "*** ok ***" +filter -spat -rep "_\\*_=_"
        prints: #=== ok ===
      further reading:
         $sfk help options<def> - general options reference
         $sfk help chain<def>   - about command chaining
 (type "sfk help unicode")
$sfk unicode file read support%s:
   by default, sfk commands that need to read TEXT files will
   skip utf-16 (ucs-2, wide char) files, as they look like binary,
   containing zero bytes.
   you may set option "#-wchar<def>" to activate utf-16 detection and decoding
   for file READING, allowing to search for words also in unicode files.
   -wchar works with text processing commands like sfk filter and sfk find.
   (sfk hexfind will ignore the option, as it reads everything as binary)
   the decoding is primitive and simply strips every 2nd byte,
   meaning that only the lowest code points are supported.
   $NOTE:<def> option "-wchar" is #experimental<def> and shall #not<def> be used if you want
         to #write<def> any text file contents! (e.g. with sfk filter ... -write)
         during write, the utf-16 format will be replaced by a primitive
         plain ascii format (NOT a proper conversion - sfk will just
         drop every 2nd byte from the file) which is often not desirable.
   $examples
      #sfk -wchar filter mydir -+foo
         filter "foo" in all text files of mydir, including utf-16.
      #sfk -wchar find mydir foobar
         find "foobar" in all files of mydir, including utf-16.
compile
 (type "sfk help compile")
$sfk compile on any linux system%s:
   To compile SFK on any linux system like 64 bit ubuntu
   follow these steps:
   $1. make sure a C++ compiler is installed:
      sudo apt-get install g++
   $2. download the sfk source code .tar.gz
      wget http://stahlworks.com/sfk.tar.gz
   $3. compile by
      gzip -d sfk.tar.gz
      tar xvf sfk.tar
      cd sfk-1.7.4
      ./configure
      make
   $4. IF configure/make don't work for any reason
      $try a manual compile by:
      g++ -s sfk.cpp sfkext.cpp -o sfk
   To compile SFK under Windows, download the .zip package
   from sourceforge, then look into do-compile-win.bat
 (type "sfk help xe")
$about sfk xe:
   Swiss File Knife Extended Edition (SFK XE) is the commercial
   edition of SFK, available from StahlWorks Technologies.
flate
 $SFK XE Archive File Content Reading
   Swiss File Knife Extended Edition features full content
   reading of .zip, .jar, .ear, .war and .aar files.
   sfk xe can not only read top-level contents of a zip,
   but also contents of zips embedded within other zips,
   e.g. jar archives within a zip package.
   under xe, the following commands provide zip processing:
      find, hexfind, xfind, xtext, xhexfind, extract,
      list, filter, snapto
   as usual, the output of such commands (text streams or filename lists)
   can be processed by subsequent chain commands, just as with sfk base.
   $LIMITATIONS:
    - zip file contents #must fit completely into memory<def>.
      in general, zip files below 100 mb should be ok.
      contents larger then the current -memlimit (default: 300mb)
      will be skipped. if you increase the -memlimit, your machine
      must have enough memory, or sfk may run endless or even crash.
    - the zip files must use a #normal compression format (%s%s)<def>,
      e.g. as it is produced by the InfoZIP or WinZIP tool.
      (most zip files in the internet use normal compression.)
      exotic compressions and 64-bit zip files are NOT supported.
    - time or attribute informations (sfk list -time ...) of zip
      file entries may be inaccurate or missing, all you get is
      the actual contents (zip file entry data) for processing.
   $Will archive reading work for you? Try the demo.
   The binary you are using right now contains XE Demo functionality,
   supporting an option "-arc" with the commands listed above.
   When using -arc, only the first 1000 bytes of every zip file entry
   will be processed. "sfk list -arc ..." is not limited, it will
   list the whole .zip and .jar contents, including nested zips.
   $If the demo works fine, find out more under:
      http://stahlworks.com/
   $examples
      #sfk list -arc -time -size -tofile lslrx .
         list all files, all contents of zip, jar etc. archives,
         and all files of archives contained within archives,
         creating one large file list within file "lslrx".
         type "sfk list" to get more infos on that example.
      #sfk filt -arc "-ls+public class" -dir src.zip -file .java
         find public classes in all .java files of src.zip
 $SFK XE Fast Replace
   Swiss File Knife Extended Edition contains a different
   implementation of the replace command, allowing high speed
   different-length replacements in large files. It can replace
   directly from one file to another file, or use temporary files
   to store the output intermediately. This means the file size
   is not limited by the available memory, and even files with
   many gigabytes of size can be processed.
 $SFK XE Replace with Wildcards and SFK Expressions
   Swiss File Knife Extended Edition contains commands
   $xreplace, xhexfind, extract<def> and $xed<def> which support
   wildcards * and ? as well as SFK Expressions
   within brackets []. SFK Expressions are NOT regular
   expressions but use a simpler, human readable syntax.
   Type #sfk help xpat<def> for the full SFK Expression syntax.
   Type #sfk xhexfind<def> to try the free demo of xhexfind
   which is contained in this binary.
   $SFK Extended Edition is available from:
      http://stahlworks.com/
xpat
fileset
 (type "sfk help fileset")
$using filesets%s:
   if you want to process many directory trees and dir/file masks,
   you may create a fileset, which is a text file containing directories
   and file masks, as well as remark and blank lines for better readability.
   $example file zz-myfiles.txt:
      ## stat the fooproj folders.
      ## this is a remark line.
      -dir fooproj\src
             <not>\save\
             <not>\tmp\
           -file .hpp .cpp <not>.bak
      -dir "C:\Docs With Blanks"
           -subdir <sla>current<sla>
           -file <not>.tmp
   $this can be used in a command like:
      #sfk stat -fileset zz-myfiles.txt
         lists size statistics of directory trees x:\fooproj\src
         and x:\foodb to z:\ . any directory "\save" or "\tmp" within
         fooproj\src is excluded. within foodb, everything is included,
         except .tmp files. you can also add remarks starting with "##"
      #sfk snapto=mycache.txt -fileset zz-fileset.txt
         collects all text specified by zz-fileset.txt into a large
         snapfile "mycache.txt" (a snapshot of all text content).
         this can be loaded by any text editor, or even better,
         by the high speed text browser Depeche View which is
         optimized for loading snapfiles (type "sfk view" for more).
   $using flat filename lists:
      as an alternative to specifying dir- and file masks,
      option -fileset also accepts a flat filename list, like:
         foo1.txt
         foo2.txt
         mydir1\foo\bar2.txt
   the -fileset option is supported by most commands that accept
   the -dir ... -file ... syntax, e.g. list, snapto, md5gento,
   but not yet with sfk find or grep.
 (type "sfk help knx")
$knx messaging%s:
   SFK may print KNX IP messages like:
      #sfk udpdump -knx
          print messages on the default group 224.0.23.12
          in a minimum single line format
      #sfk udpdump -knxfull 224.0.23.13
          print full messages on an alternative IP group
      #sfk knxdump -text " 1/*/3 " -from=100
          print only messages having GA's starting 1 and
          ending 3 in their knx header info text, coming from
          an IP like 192.168.1.100 in the local network
   SFK may send KNX IP messages like:
      #sfk udpsend -knx "1 2 3 1 0"
          send to group address 1/2/3 a 1 bit value "0".
      #sfk knxsend "1 2 3 8 255"
          send to group address 1/2/3 an 8 bit value "255".
   $NOTE:<def> because this uses multicast I/O it may
         or may not work, depending on many factors.
         see "sfk udpdump" for details.
unknown help subject: %s.
type just "sfk" for the main help.
type "sfk ask %s" to search all help text.
start of filename comparison: use "\pattern". see also "name start"
traveling, walking subdirectories or subfolders: is default. type "sfk help select"
find in text files: "sfk find", "sfk hexfind", "sfk filter"
find text, data in binary files, binaries: "sfk find", "sfk hexfind"
find same, identical, duplicate files: "sfk dupfind"
compare directories, folders, differences: "sfk list" with -sincedir option
find different files, differences: "sfk md5check", "sfk list" with -sincedir
list, find newest, oldest, latest files of dir: "sfk list" with -late, -old
list, find most recent files of dir: "sfk list" with -late, -old
list, sort, order dir files by date, timestamp: "sfk list" with -late, -old
list, find largest, biggest, smallest dir files: "sfk list" with -big, -small
list, find files changed today, since a date: "sfk list" with -since
sort dir contents by date, time, size: "sfk list" with -late, -big
symbolic links: no option under windows. under linux (not lib5) see "sfk help opt"
regular expressions: not supported, but see "sfk help patterns"
list, show files, directory tree size, largest dirtree: see "sfk stat"
split text lines, column data by characters: "sfk filter" with -sep, -form
extract, remove text blocks between marker lines: "sfk filter" with -inc, -cut
create, verify md5sum, md5 checksum for dir, files: "sfk md5gento", "sfk md5check", "sfk md5"
convert binary to c++, cpp, java sourcecode: "sfk bin-to-src"
split large text or binary files: "sfk split"
transfer files from windows host to linux vmware: "sfk ftpserv", "sfk ftp"
find, where are classes inside, within jar files tree: "sfk list" with -arc
all class packages in jar dirs: "sfk list" with -arc
alula
list, get all files in jars in all dirs: "sfk list -arc . .jar"
find, replace words in text, binary files: "sfk replace", "sfk filter"
find, replace hex pattern in binary files: "sfk hexfind", "sfk replace"
patch binary file contents: "sfk replace"
convert text file, dos, windows, linux crlf line endings, format: "sfk addcr", "sfk remcr"
replace, add, remove, strip, convert text file crlf line endings: "sfk addcr", "sfk remcr"
find, print, read first, last lines of text files: "sfk head", "sfk tail"
print, read head or tail of files: "sfk head", "sfk tail"
find command, cmd, bat, exe file in path: "sfk pathfind"
remove, replace tabs by spaces in text file lines: "sfk detab"
insert, remove text in files: "sfk replace", "sfk filter" with -write
find, list files in a dir sorted by size, time: "sfk list" with -big, -late
copy content, extract, view text of a binary file: "sfk partcopy", "sfk strings"
run user defined command, processing many files: "sfk run"
run a command on each file, line of file: "sfk run", "sfk filter thefile.txt +run "mycmd <run>text""
replace, remove spaces in filenames, dir names: "sfk deblank"
join, add text, binary files: "sfk snapto", "sfk join"
adding delay, pause to command file: "sfk sleep", "sfk pause"
set, create, define alias for .cmd, .bat, command path in shell: "sfk alias"
delete .bak, .tmp, temporary files: "sfk sel . .bak +del"
convert binary file to text, source code: "sfk hexdump", "sfk bin-to-src"
hex to byte, convert hex dump, file into binary file: "sfk hextobin"
count files in dir tree: "sfk list ... +count"
create text file from dir listing: "sfk list ... +tofile"
create large text, binary file for tests: "sfk make-random-file"
delete files by extension: "sfk del mydir .ext"
trace, hexdump, dump TCP data, browser connection: "sfk tcpdump"
tcpdump of http request in plain text: "sfk tcpdump" with -flat
echo staying on same line, without lf: "sfk echo" with -noline
shell echo with colored words in red, green, blue: "sfk echo"
open, read text from clipboard: "sfk fromclip"
file copy to clipboard: "sfk filter ... +toclip"
find unprintable, nonprintable characters : "sfk hexfind" with -bin
find duplicate lines in a text file: "sfk count" with -samelines
find data, hex numbers in binary files: "sfk hexfind"
find, replace text with wildcards: "sfk filter"
find, get, list files matching patterns: "sfk list"
cut, remove, filter empty, blank lines from text files: "sfk filter" with -no-blank-lines
replace any, accent, umlaut characters in text files: "sfk replace"
check, find dependencies of binaries, executables files: "sfk deplist"
find, list number of files in a directory: "sfk list mydir +count"
add current, any dir to a file list: "sfk list . >>myfilelist.txt"
strip, skip text file lines by filter, markers: "sfk filter" with -!mypattern or -cut
cut, strip, exclude lines by words from text files: "sfk filter" with -!word1 -!word2
list files of dir needing no wildcard: "sfk list mydir *foo*" == "sfk list mydir foo"
write shell script with command chaining: "sfk script", "sfk samp"
to create multi line commands, use "sfk script"
if content(s) are too large to load, see -memlimit under "sfk help opt"
replace colors in text lines: "sfk filter" with -highlight
jpeg, jpg, png image processing, conversion: "sfk samp javaimg", "sfk samp phpimg" or google for imagemagick.
all zip tar gz bz2 file extensions recognized by sfk: type "sfk help opt"
process files changed from, until a date: see option -since and -before
loop
<help>$sfk ... +loop
   repeat (loop) the execution of a command chain.
   when using +loop in an sfk script file,
   always add +end after it (+loop +end).
   $see also
      sfk tail - a script example with looping
   $examples
      #sfk list -late mydir +sleep 5000 +loop
         list most recent files of mydir every 5 sec.
{EOS}
int. error in example text
example command not found: %s
sfk 
-dumpmiss
-opt
sfk ask requires one or more words.
the given words are too generic, and cannot be used for search.
please rephrase your query with more precise words.
using: 
int. #148281153
miss: sfk ask 
unknown command: %s
wrong name format, cannot read: %s
wrong zip name, cannot read: %s
url overflow, cannot split: %s
int. error #2129.1: invalid call
%s%c%c%s
int. error #2129.2: invalid call
clst
empty zip, skipping: %s
cannot read, skipping (rc=%d): %s
int. error #2129.3: invalid call
unable to cache: %s (%ld)
%u files %lu mb
load
loadzipsub failed: %.30s not relative to %.30s
loadzipsub: wrong subname format: %s
loadzipsub: wrong call, no subfile: %s
loadzipsub: ... called on parent  : %s
loadzipsub: cannot open %s within %s
incbin
RefDst
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
Alpha
Bravo
Charlie
Delta
Echo
Foxtrot
Golf
Hotel
India
Juliet
Kilo
Lima
Mike
November
Oscar
Papa
Quebec
Romeo
Sierra
Tango
Uniform
Victor
Whisky
X-ray
Yankee
Zulu
Johnny
King
London
Peter
Queen
Roger
Union
William
Zebra
"<>%\^[]`+$,@:;/!#?=&
del 
mkdir 
rmdir 
TEMP
cannot cache to disk: no TEMP variable found.
%s%c00-sfk-cache
%c00-sfk-cache
cache path too long: %s
cannot drop cache entry with %d refs: %s (%p)
int. #108281302
int. #208290634
int. #208290635
cache-put twice, ignoring: %s
cache overflow (%d), try to increase -memlimit (current=%d).
%u files %u mb
free
int. #258282159 on cache drop
cput
http://
http
ftp://
cannot cache to disk: name buffer too small.
cannot cache to disk, name too long: %s
%%%02X
int. 35291439
cannot create caching dir for: %s
saving %s
cannot write cache file: %s
failed to write cache file, probably disk full: %s
cannot write cache meta file: %s
[sfk-cache-redirect]
cget
cache file too large, cannot load: %s
using cache file %s
failed to load cache file: %s
[sfk-cache-redirect]
dcache
cget2
int. 187282050
cannot drop cache entry with %d refs: %s
unexpected NULL ptr on ConAutoClose, line %d
connection in use, cannot close: %s %p %d
wrong cache entry type: %s %p
too many locks on connection: %s (%d)
unexpected refcnt on client: %s %d
int. #267281138
int. #267281139
connection cache overflow, %d %d
int. #267281208
missing close on tcpcon %p hsock %xh line %d
read tcp
< %s
string overflow on send: %.200s
send tcp
missing shutdown() on tcpcore %p
SFK_PROXY
using proxy %s port %d
too many sockets, cannot create server socket
cannot create socket on port %u
cannot bind socket on port %u
getsockname failed, %d
cannot listen on port %u
internal: too many connections
internal: cannot remove connection %p
too many sockets, cannot accept more
tcp accept
accept failed (%d)
internal: missing tcp sysinit
too many sockets, cannot connect more
connect tcp
cannot create socket
cannot get host
cannot connect to %s:%u, rc %d
tcp select
select() failed, %d
http: unclosed connection, %p
https://
url overflow: %.100s
int. #175291 missing connection
int. #175292 missing connection
http: wrong url format: %s
http connect failed: %s:%d
out of memory, cannot read head
HEAD
content-type
text
http reconnect failed: %s:%d
location
rc %d but no Location on %s
http:
redirect failed: %s / %s
redirected to %s
int. #175293 missing connection
out of memory, cannot read headers
%.40s: %s
wrong http header on object: %s
header line is: %s
transfer-encoding
chunked
text/html
application/
application/x-tar
application/x-compressed
content-length
date
last-modified
internal, wrong http initial state
out of memory, cannot read meta data
int. #175294 missing connection
int. #175295 missing connection
http read error, no chunk header
int. 167281949
http: incomplete chunk read, %d %d
int. 167281950
ftp: unclosed control connection, %p
ftp login failed: %s:%d
ftp: wrong server hello: %s
. sft 
> server speaks sft %d. mget, mput enabled.
> unexpected sft info "%s"
USER anonymous
PASS sft102@
ftp: wrong login reply: %s
TYPE I
PASV
set passive failed: "%s"
%d.%d.%d.%d
set passive failed: cannot create socket
set passive failed: cannot get host %s
connect ftp
set passive failed: cannot establish connection to %s
< connected to %s:%u
SLST %s
set passive failed, %d
LIST %s
ftp list failed: %s
150 
ftp error: %s
ftp list error: %s
226 
ftp list failed: %d
wrong format: %s - skipping
%s %s %s
] skip, size=%s: %s
%.*s%s%s%s
SKIP 
failed to read %s
failed to send %s
cannot open ftp file, only read supported: %s
SGET %s
SOPEN %s
metalen
unsupported SFT protocol version
size
illegal length received, %s
time
flags
RETR %s
< %s   
SREAD %s
failed to send block request
SSUM
failed to request checksum
failed to receive checksum
ftp: cannot read, no download open
SCLOSE
failed to send close
bulk transfer but %d remaining for: %s
md5 mismatch - transfered file corrupted (size=%d)
failed to send reply, %d
ftp: cannot close, no download open
ftp: unexpected reply after download: %s
int. #175296 missing connection
%s http://%s%s/%s HTTP/1.1
Host: %s%s
User-Agent: %s
Accept: text/html;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.8
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Proxy-Connection: close
%s /%s HTTP/1.1
Host: %s%s
User-Agent: %s
Accept: text/html;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.8
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: close
too large, cannot load: %s
unexpected last-chunk end: "%s"
download has unexpected size: %s %d/%d
download incomplete: %s %d/%d
unable to ftp to: %s
unable to http to: %s
releaseFtp without ptr, %p
releasehttp without ptr, %p
cannot open dir: %s
 href="
 href='
 href=
<img 
 src="
 src='
javascript:
http nextEntry() called without openDir()
ftp nextEntry() called without openDir()
ftp: wrong url format: %s
ftp session expired, retrying
ftp communication failed (connection closed)
ftp not open, cannot read: %s (%d)
http not open, cannot read: %s (%d)
ftp not open, cannot close: %s
http not open, cannot close: %s
 - content too large (%u mb)
 - no such element
loading failed (%d): %s
cannot get element, name mismatch: %s / %s
isdir
cannot get headers: %s
ftp login failed: %s
EWOULDBLOCK
EINPROGRESS
EALREADY
ENOTSOCK
EDESTADDRREQ
EMSGSIZE
EPROTOTYPE
ENOPROTOOPT
EPROTONOSUPPORT
ESOCKTNOSUPPORT
EOPNOTSUPP
EPFNOSUPPORT
EAFNOSUPPORT
EADDRINUSE
EADDRNOTAVAIL
ENETDOWN
ENETUNREACH
ENETRESET
ECONNABORTED
ECONNRESET
ENOBUFS
EISCONN
ENOTCONN
ESHUTDOWN
ETOOMANYREFS
ETIMEDOUT
ECONNREFUSED
ELOOP
ENAMETOOLONG
EHOSTDOWN
EHOSTUNREACH
ENOTEMPTY
EUSERS
EDQUOT
ESTALE
EREMOTE
status=%d (%s)
status=%d
Error creating socket for %s. errno=%u %s
Cannot listen on port %d, retrying on %d.
Cannot listen on port %d, rc=%d.
Missing access rights, or port used by other program.
Join multicast failed: bad address %s
No default-route to support multicast.
Try 'route add -net 224.000 netmask 240.000 eth0'
cannot get host %s, rc=%d
send: invalid UDP socket
send: failed errno=%d %s
,sc%c
,cs1
,copy
:sfktxt:v100,req%d%s,rt0%s%s,fl
,rt0
line broken, failed to send package %d times.
,rep
wrong -duplex reply received: %.30s
duplex: old reply record (%d/%d), lines may be duplicated
duplex: wrong reply record (%d/%d), lines may be invalid
copy
:clear
invalid control sequence in color text
%s : "
{COL}
{CR}
{LF}
:sfktxt:
:sfktxt:v100,rep%d,rt%d,ok
clear
error  : detab: line buffer overflow. max line len supported is %d
error  : you are not in the %s directory.
error: out of memory in patchMain
-example
#patchfile example, containing all supported patchfile commands:
:patch "enable FooBar testing"
:info makes some stuff public, for direct access by test funcs
:root foosrc
:file include\Foobar.hpp
:from 
private:
    bool                  isAvailable               (int nResource);
    void                  openBar                   (int nMode);
public: // [patch-id]
    bool                  isAvailable               (int nResource);
    void                  openBar                   (int nMode);
:from 
    // returns the application type, 0x00 == not set.
    UInt16                getAppType                ( );
    // returns the application type, 0x00 == not set.
    UInt16                getAppType                ( );
    UInt32                getAppTypeInternal        ( );
:done
:## this is a remark, allowed only outside :file blocks.
:## the above syntax is sufficient for most cases; but now follow some
:## more commands for global replace, file and dir creation, etc.
:## select-replace has 3 parms, and applies changes (parms 2+3) only
:## in lines containing the search term (parm 1).
:file include\Another.cpp
:select-replace /MY_TRACE(/\n"/"/
:select-replace _printf("spam: _printf(_while(0) printf(_
:set only-lf-output
:from 
    bool                  existsFile                (char *psz);
    // [patch-id]
    int                   existsFile                (char *psz);
:done
:mkdir sources
:create sources\MyOwnFix.hpp
// this file is generated by sfk patch.
##define OTHER_SYMBOL MY_OWN_SYMBOL
:done
:skip-begin
this is outcommented stuff. the skip-end is optional.
:skip-end
-template
-tpl
:patch "thepatch"
:root theproject
:file include\file1.hpp
:from 
    // [patch-id]
:from 
:done
:file sources\file1.cpp
:from 
    // [patch-id]
:done
error: cannot identify working dir. make sure you are in the correct directory.
-revoke
-redo
-keep-dates
-exact-match
-sim
-verify
-verbose
-stat
-nopid
-anyroot
unknown option: %s
use with no parameters to get help.
save_patch%c%s
error  : cannot simulate and revoke together.
* revoking changes from: %s
* patch revoked: %s - %d target files
* all changes revoked. the target files got the current time stamp,
* to ease recompile. you may use -keepdates to change this behaviour.
* all changes revoked, including original timestamps.
error  : cannot remove stale backup: %s
* checking target file compliancies
intact
valid
* patch %s: %s
still intact
valid and may be applied.
* all checked. the patch is %s.
patch  : %s
* there were errors. the patch cannot be applied.
* however, if an older patch is active, you may still -revoke it.
* creating backups
 permanently
* applying patches%s
* all changes re-applied: %s - %d target files
* all changes re-applied.
* patch applied: %s - %d target files
* all done.
save_patch
dummy
cp -p %s %s
error  : cannot backup patchfile to: %s
info   : make sure you are above the "%s" directory.
info   : make sure you are in the "%s" directory.
* NOTHING CHANGED: i will either apply ALL changes, or NONE.
* you may also try sfk patch -revoke or -redo.
error  : cannot open patchfile: %s
:skip-end
error  : skip-end without skip-begin in line %d
:skip-begin
error  : skip-begin twice in line %d
:patch 
:info 
:info
:info
:root 
:select-replace 
error  : too many global select-replace, only up to %d supported.
:create 
:mkdir 
:file 
:set only-lf-output
:set detab=
setting detab to %d
error  : unknown command in line %d: %s
info   : global select-replace never applied: %s, %s, %s
global select-replace applied %d times: %s, %s, %s
error  : missing filename after :file
error  : unable to open file: %s
info   : local select-replace never applied: %s, %s, %s
local select-replace applied %d times: %s, %s, %s
error  : missing filename after :create
warning: file already exists: %s
error  : file no longer exists: %s
warning: cannot remove: %s
removed: %s
error  : cannot create file: %s
:done
written: %s, %d lines.
error  : missing :done after :create of line %d
error  : missing filename after :mkdir
created: %s
src-> %s
pat-> %s
src*> %s
pat*> %s
command block too large, max %d lines supported.
error  : too many select-replace in one :file, only up to %d supported.
:from
unexpected command: %s
[patch-id]
error  : line %d: [patch-id] not allowed within :from block. expected in :to block.
error  : line %d: :from block missing
error  : line %d: :to block missing
error  : line %d: :from block empty
error  : line %d: :to block empty
error  : too many commands, only %d supported
error  : line %d: [patch-id] missing!
info   : you must supply at least one [patch-id] within a :to block per :file,
info   : otherwise i cannot identify already-patched files.
error  : cannot read target file: %s
%s%c%s
error  : cannot revoke, no backup file: %s
chmod +w %s
error  : cannot open %s
chmod -w %s
revoked: %s, %u bytes
revoked: %s
revoke failed: %s
error  : cannot delete stale backup: %s
warning: isn't patched, will not revoke: %s
del.bup: %s
error  : creation of backup file failed: RC %d
backupd: %s
error  : verify of backup file failed: %s
error  : different line endings!
CR/LF
error  :   the patch file uses %s line endings.
error  :   this target file uses %s line endings: %s
checked: %s is still patched
error  : %s already patched
pattern cache overflow, %d lines exceeded
output cache overflow, %d lines exceeded
error  : from-pattern %d of %d mismatch, in file %s
info   : check pattern content and SEQUENCE (must match target sequence).
error  : cannot overwrite target file: %s
lc1>%s
lc2>%s
gc1>%s
gc2>%s
Patched: %s, %d lines.
patched: %s, %d lines.
checked: %s, %d lines.
error  : %s no longer patched - probably overwritten
#include "%s" // [instrumented]
error  : out of memory at %d
?::?
wsw(
wsww(
FN BODY at %d: %s
] %s
{%s("%s");
class 
struct 
s-hit %d %d
MISS.%d: %s %d %d
error  : cannot read: %s
error  : cannot read: %s (%d %d)
save_inst/
warning: exclude, cannot instrument: %s
save_inst
// [instrumented]
skipped: %s - not instrumented
warning: cannot revoke, no backup: %s
error  : revoke failed: %s
skipped: %s - empty file
warning: too large, skipping: %s
warning: already instrumented, skipping: %s
skipped: %s - nothing to change
error  : cannot backup file to: %s
error  : unable to write: %s
redone : %s, %d hits
inst'ed: %s, %d hits
/from/to/ too short
from text too long
invalid slash pattern: %s
too many parts
wrong [] syntax: %s
chars]
missing end separator '%c'
to text too long
[parts 
wrong part number: %d
wrong parts syntax
[part
missing ]
unexpected text after end separator '%c': %s
too many match parts
match part overflow
miss %c %c
p%d %s
stoplit match: %s
to state %d seeking "%s"
to state %d over %d chars on %s
to state %d on %s mask %c
mask not done at end of src
point match len=%d
output buffer overflow
invalid part number: %d
ledit: output overflow
ledit: invalid match
FROM: %s
ERR : file exist with name: %s
ERR : dir does not exist: %s
redundant
exists
no outdir
bad outdir
ERR : %s - %s
TO  : %s
... rename failed, rc=%d
%02u:%02u:%02u
buffer overflow
missing filesize. specify as first parameter.
missing total time. specify as second parameter.
itime : %s = %s bytes
wrong time range format: %s
wrong time range end: %s
media: output file open on init
pal-dvd
dvd-pal
-target pal-dvd
ntsc-dvd
dvd-ntsc
-target ntsc-dvd
ffmpeg -y -i "%s" %s -codec copy "%s"
ffmpeg possible error, RC=%d
use -keeptmp to keep temporary output file.
cleaning up temporary: %s
--- Using bookmarks: ---
#EXTVLCOPT:bookmarks=
no #EXTVLCOPT:bookmarks= found within %s
no input file filename found within %s
input file not found: %s
from line %03u of M3U: %s
using: line %u, %.60s ...
using: line %u, %s
bytes=
time=
keep
skip
%s : %s-%s (%s-%s)
uneven number of boomarks found in %s
------------------------
missing file extension on output name: %s
%s-tmp.%s
using temporary: %s
no commands given, skipping: %s
input: %s%s
missing output filename
 (joined)
out  : %s%s%s
no such input file: %s
empty input file: %s
unable to open input file: %s
unable to write: %s
%s-%s (%s-%s)
%s-%s
$copy : %s
#skip : %s
bytes
invalid section length: %d at %s
file end reached.
error while writing: %s   
fwrite
part : kb.KEEP from %s
part : ke.SKIP from %s
part : cb.SKIP from %s
part : ce.KEEP from %s
would copy %d mb (%s bytes).
copied %s bytes.
 (output file exists)
 (overwritten)
$move : %s -> %s%s
cannot move %s -> %s
add option -force to overwrite existing output file.
output dir must be on same file system as input file.
.m3u
missing "-keepbook" command, skipping: %s
using: %s
zipread: fopen.mem %s
zipread: fopen.file %s
zipread: fread.file %lu
zipread: fread.mem max=%lu remain=%ld
error: incomplete zipfile data: %s   
zipread: fread.mem %lu done
zipread: fseek.file %ld
zipread: fseek.mem %ld
zipread: ftell.file %ld
zipread: ftell.mem %ld
zipread: fclose
zipread: setInput %lu bytes, %p
dummy.zip
opensub: %s within %s
internal #117081221
read tar
.tar
.tar.gz
.taz
.tgz
%s: Couldn't find 
%s%s, 
or %s%s
%4d/%02d/%02d %02d:%02d:%02d
out of memory
cannot create directory: %s
.bz2
.tbz2
.tar.bz2
cannot read: %s
.dat
%s: %s
tar read failed (1): %s
content too large, stopping read: %s within %s
tar read failed (2): %s
unexpected end of file (%d): %s
bad long name found within %s
object too large, skipping: %s within %s
out of memory (%ld): %s within %s
tar read failed (3): %s
buffer error while loading: %s within %s
int. error #121228: %s
error: broken archive: %s
gzclose failed: %s
zdeb: %s
zinf: %s
zwrn: %s
zerr: %s
1.2.3
%c%c%c%c%c%c%c%c%c%c
incorrect header check
unknown compression method
invalid window size
unknown header flags set
header crc mismatch
invalid block type
invalid stored block lengths
too many length or distance symbols
invalid code lengths set
invalid bit length repeat
invalid literal/lengths set
invalid distances set
invalid literal/length code
invalid distance code
invalid distance too far back
incorrect data check
incorrect length check
need dictionary
stream end
file error
stream error
data error
insufficient memory
buffer error
incompatible version
1.2.3
bzlib2 int. error #%d, version=%s.
bzlib2 error 1007 occurred.
 {0x%08x, 0x%08x}
    combined CRCs: stored = 0x%08x, computed = 0x%08x
1.0.5, 10-Dec-2007
SEQUENCE_ERROR
PARAM_ERROR
MEM_ERROR
DATA_ERROR
DATA_ERROR_MAGIC
IO_ERROR
UNEXPECTED_EOF
OUTBUFF_FULL
CONFIG_ERROR
      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use
      initial group %d, [%d .. %d], has %d syms (%4.1f%%)
      pass %d: size is %d, grp uses are 
      bytes: mapping %d, 
selectors %d, 
code lengths %d, 
codes %d
    block %d: crc = 0x%08x, combined CRC = 0x%08x, size = %d
    final combined CRC = 0x%08x
    [%d: huff+mtf 
rt+rld
28 February 2005
cannot flush zip
cannot flush multiple memfiles, flushfn not set
object too large, cannot read: %s
filename overflow: %s
error:  cannot allocate unzip buffers
%d archive%s successfully processed.
%d archive%s had warnings but no fatal errors.
%d archive%s had fatal errors.
%d file%s had no zipfile directory.
1 "zipfile" was a directory.
%d "zipfiles" were directories.
No zipfiles found.
%s:  cannot find zipfile directory in one of %s or
        %s%s.zip, and cannot find %s, period.
%s:  cannot find or open %s, %s.zip or %s.
unzip
note:  %s may be a plain executable, not an archive
   [%s]:
     Zipfile is disk %u of a multi-disk archive, and this is not the disk on
     which the central zipfile directory begins (disk %u).
warning [%s]:  end-of-central-directory record claims this
  is disk %u but that the central directory starts on disk %u; this is a
  contradiction.  Attempting to process anyway.
warning [%s]:  zipfile claims to be last disk of a multi-part archive;
  attempting to process anyway, assuming all parts have been concatenated
  together in order.  Expect "errors" and warnings...true multi-part support
  doesn't exist yet (coming soon).
warning [%s]:  %ld extra byte%s at beginning or within zipfile
  (attempting to process anyway)
error [%s]:  missing %ld bytes in zipfile
  (attempting to process anyway)
error [%s]:  NULL central directory offset
  (attempting to process anyway)
warning [%s]:  zipfile is empty
error [%s]:  start of central directory not found;
  zipfile corrupt.
error [%s]:  reported length of central directory is
  %ld bytes too long (Atari STZip zipfile?  J.H.Holm ZIPSPLIT 1.1
  zipfile?).  Compensating...
  End-of-central-directory signature not found.  Either this file is not
  a zipfile, or it constitutes one disk of a multi-part archive.  In the
  latter case the central directory and zipfile comment will be found on
  the last disk(s) of this archive.
caution:  zipfile comment truncated
.zip
.ZIP
 was
s were
Archive:  %s
%sEmpty zipfile.
warning:  cannot set time for %s
[%s]
28 February 2005
note:  didn't find end-of-central-dir signature at end of central dir.
error:  expected central file header signature not found (file #%lu).
error [%s]:  attempt to seek before beginning of zipfile
caution: filename not matched:  %s
caution: excluded filename not matched:  %s
  (please check that you have transferred or created the zipfile in the
  appropriate BINARY mode and that you have compiled UnZip properly)
zipinfo
Compiled with %s%s for %s%s%s%s.
warning:  cannot allocate wildcard buffers
warning:  skipped "../" path component(s) in %s
   creating: %s
chmod (directory attributes) error
mapname:  conversion of %s failed
checkdir error:  path too long: %s
checkdir error:  cannot create %s
                 unable to process %s.
checkdir error:  %s exists but is not directory
                 unable to process %s.
checkdir warning:  path too long; truncating
                   %s
                -> %s
checkdir:  cannot create extraction directory: %s
warning:  symbolic link (%s) failed: mem alloc overflow
warning:  symbolic link (%s) failed: no mem
warning:  symbolic link (%s) failed
-> %s 
warning:  cannot set UID %d and/or GID %d for %s
 (warning) cannot set UID %d and/or GID %d
warning:  cannot set times for %s
 (warning) cannot set times
chmod (file attributes) error
warning:  cannot set UID %d and/or GID %d for %s
warning:  cannot set modification, access times for %s
warning:  cannot set permissions for %s
Apr 15 2015
 on 
 (Linux ELF)
Unix
4.4.3
gcc 
   skipping: %-22s  need %s compat. v%u.%u (can do v%u.%u)
   skipping: %-22s  unsupported compression method %u
   skipping: %-22s  `%s' method not supported
store
shrink
reduce
implode
tokenize
unexpand
unexpand64
DCL implode
%s:  bad filename length (%s)
%s:  warning, no memory for comparison with local header
%s:  mismatching "local" filename (%s),
         continuing with "central" filename version
%s:  ucsize %lu <> csize %lu for STORED entry
         continuing with "compressed" size value
%s:  bad extra field length (%s)
file #%lu:  bad zipfile offset (%s):  %ld
%8sing: %-22s  %s%s
%s  %s:  %ld bytes required to uncompress to %lu bytes;
    %s      supposed to require %lu bytes%s%s%s
%s:  bad file comment length
local header sig
file #%lu:  bad local header
  (attempting to re-compensate)
warning:  %s appears to use backslashes as path separators
warning:  stripped absolute path spec from %s
   skipping: %-22s  %svolume label
warning:  cannot alloc memory for dir times/permissions/UID/GID
warning:  cannot alloc memory to sort dir times/perms/etc.
warning:  set times/attribs failed for %s
     failed setting attrib/times for %lu dir entries
warning:  deferred symlink (%s) failed:
          out of memory
warning:  deferred symlink (%s) failed:
          invalid placeholder file
finishing deferred symbolic links:
  %-22s -> %s
replace %s? [y]es, [n]o, [A]ll, [N]one, [r]ename: 
 NULL
(assuming [N]one)
new name: 
error:  invalid response [%c]
At least one %serror was detected in %s.
Caution:  zero files tested in %s.
%s:  stored in VMS format.  Extract anyway? (y/n) 
   skipping: %-22s  encrypted (not supported)
No errors detected in compressed data of %s.
No errors detected in %s for the %lu file%s tested.
%lu file%s skipped because of unsupported compression or encoding.
  error:  %s%s %s
  error:  %s%s
not enough memory to 
invalid compressed data to 
expand
explode
warning:  %s is probably truncated
%s:  unknown compression method
 bad CRC %08lx  (should be %08lx)
 compressed EA data missing (%d bytes)%s
 compressed WinNT security data missing (%d bytes)%s
bad extra-field entry:
      EF block length (%u bytes) exceeds remaining EF data (%u bytes)
 invalid compressed data for EAs
 unsupported NTSD EAs version %d
 bad CRC for extended attributes
 unknown compression method for EAs (%u)
 out of memory while inflating EAs
 unknown error on extended attributes
error:  unsupported extra-field compression type (%u)--skipping
error [%s]:  bad extra-field CRC %08lx (should be %08lx)
central
warning-
lseek
local
[empty] 
[text]  
[binary]
test
link
extract
explod
warning
error
inflat
%-22s 
symlink error
 n;^
Qkkbal
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
Z* ,	
H$6t
52F*
	#jT$
^6o}
[-&LMb#{'
w+OQvr
R1h58
SKyu
)\ZEo^m/
ru&o
i8P/
?(3w
H*0"ZOW
{kHw
)T`D
!AxU
l!;b	F
:1X:
y9*O
kM`~
Vc0a
dQy/
lDa>
7~8A
C-Yn
gqr<
$/o|
f-=v
mj>zjZ
l6qnk
IiGM>nw
1A26b
i91k
ewh/?y
*5KS
6~_'
F*.f
1wsHp
M8MF
Pe6^
#bML"
`F(>
vQO+t
[h1R
XsBI
hPU3
^oEZ_
2%k_
w3Xc
/P8i
OZw3(?
Z"0*
fP~V
^GP~
b;!l
V_:X1:
NJ2"v
O*9y]
fu`z
/yQA
&]|v
1.2.3
invalid distance too far back
invalid distance code
invalid literal/length code
								
        bucket sorting ...
        depth %6d has 
%6d unresolved strings
        reconstructing block ...
        main sort initialise ...
        qsort [0x%x, 0x%x]   done %d   this %d
        %d pointers, %d sorted, %d scanned
      %d work, %d block, ratio %5.2f
    too repetitive; using fallback sorting algorithm
%c%d%%
100%%
  Length     Date   Time    Name
 --------    ----   ----    ----
 Length   Method    Size  Ratio   Date   Time   CRC-32    Name
--------  ------  ------- -----   ----   ----   ------    ----
%s ("^" ==> case
%s   conversion)
%8lu  %-7s%8lu %4s  %02u%c%02u%c%02u %02u:%02u  %08lx %c
--------          -------  ---                            -------
%8lu         %8lu %4s                            %lu file%s
%9lu  %02u%c%02u%c%02u %02u:%02u  %c
 --------                   -------
%9lu                   %lu file%s
%03u
Stored
Shrunk
Reduce1
Reduce2
Reduce3
Reduce4
Implode
Token
Defl:#
Def64#
ImplDCL
PKres11
BZip2
Unk:###
NXFS
++--+-+
++--
error:  cannot open zipfile [ %s ]
        %s
error:  cannot delete old %s
error:  cannot create %s
error:  zipfile read error
warning:  filename too long--truncating.
warning:  extra field too long (%d).  Ignoring...
%s:  write error (disk full?).  Continue? (y/n/^C) 
error:  zipfile probably corrupt (%s)
%s exists and is a symbolic link%s.
--More--(%lu)
--- Press `Q' to quit, or any other key to continue ---
                                                         
[Warning: CRC error, discarding PKWARE extra field]
bus error
segmentation violation
 with no real file
[ %s ]
(incomplete l-tree)  
(incomplete d-tree)  
1.2.3
zPLR
$,6:<@C
K[\ebRjmosur.~
&`*E
y+^|(D
US]CQ
^(BM
kZ;&
)>W?
%t%5O
3YRkmp
F-Du
GCC: (Ubuntu 4.4.3-4ubuntu5.1) 4.4.3
GCC: (Ubuntu 4.4.3-4ubuntu5) 4.4.3
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rel.dyn
.rel.plt
.init
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.gcc_except_table
.ctors
.dtors
.jcr
.dynamic
.got
.got.plt
.data
.bss
.comment
