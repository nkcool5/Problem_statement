/lib64/ld-linux-x86-64.so.2
*#WQ
libc.so.6
fflush
__printf_chk
_IO_putc
fopen
optind
__strdup
perror
__stack_chk_fail
unlink
realloc
stdin
__assert_fail
strtod
strtol
isatty
fgets
calloc
strlen
memset
__errno_location
memcmp
clearerr
__fprintf_chk
stdout
fputs
memcpy
Borrow or rob
fclose
__vsnprintf_chk
strtoul
malloc
strcasecmp
optarg
stderr
getopt_long
fileno
fwrite
fread
__vfprintf_chk
memmove
_IO_getc
strcmp
__libc_start_main
ferror
free
__cxa_atexit
__gmon_start__
GLIBC_2.14
GLIBC_2.4
GLIBC_2.3.4
GLIBC_2.2.5
52q"
%4q"
%2q"
%*q"
%"q"
%zp"
%rp"
%jp"
%bp"
%Zp"
%Rp"
%Jp"
%Bp"
%:p"
%2p"
%*p"
%"p"
%Rn"
[]A\
AWAVE1
AUATE1
D$(1
5en"
-Jq"
={m"
=ln"
L$(dH3
8[]A\A]A^A_
T$ H;T$
=mf"
w	D	
ATUI
[]A\
[]A\
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
=wd"
=Pd"
AWAVI
AUATI
D$x 
D$|@
D$T 
5>a"
[]A\A]A^A_
Beeb
AWAVI
=A]"
[]A^A_
[]A^A_
@u:<
5j\"
uCE1
@uNH
O~ H
=:W"
O~ H
AWAVAUATE1
T$ M
D$PH
D$XH
T$8H
D$0I
T$8H
t$ H
D$0N
|$ H
D$@A
L$ H
L$(H
=yT"
=YQ"
D$HI
D$HI
=SP"
D$`t
D$HI
D$`t
D$HI
`8L)
dH3<%(
[]A\A]A^A_
D$,H
D$,H
D$ H
D$(H
D$0H
=@M"
D$ H
=	7"
=,6"
|$HH
|$HI
|$HH
=O5"
|$HI
|$HI
|$HH
|$HH
God A red nugget A fat egg under a dog
=#3"
|$HH
|$HI
|$HH
=K/"
|$HI
|$HH
=l+"
=I,"
%M)"
=W)"
|$HH
=%("
|$HH
=o'"
|$HH
|$HH
|$Hf
T$hH
L$ht`H
|$PH
L$hH
D$H;A
|$H1
|$HH
|$HI
|$HI
|$HI
|$HI
|$HI
|$HI
|$HI
t$HfA
t$HA
D$`;A$
|$Hf
J~@H
J~:H
< tDf
J~<H
H;8t.
H;8t
AUATUSH
[]A\A]
ATUI
t6Hc
[]A\
ATUH
AWAVAUATUSH
tOHc
8[]A\A]A^A_
u{H)
D9D$
Hc\$
L$(t:L
v(H)
Lcd$
p t L
?Hc\$
T$ I
Lcd$
Do nine men interpret Nine men I nod
ATUH
[]A\
ATUL
[]A\
[]A\
t#SH
AUATUSH
dH34%(
[]A\A]
AUATI
[]A\A]
]A\A]
ATUH
[]A\
gfff
W`H9
W H9
GxH)
taUS
[]A\
AWAVAUATUSH
D$(1
}DHc
D$(dH3
8[]A\A]A^A_
 tN;<
dH34%(
AWAV1
AUATI
[]A\A]A^A_
AWAVAUATSH
t.Ic
[A\A]A^A_]
D$x1
D$h 
D$l@
D$D 
D$xdH3
H+7Hc
H++H
s-Hc
[]A\A]A^A_
[]A\A]A^A_
AWAVI
ATUH
[]A\A]A^A_
D$	A
[]A\A]A^A_
AWAVA
[]A\A]A^A_
[]A\A]A^A_
AWAVE
AUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AVAUA
ATUI
L$0A
D$P	
[]A\A]A^
[]A\A]A^
D$PA
[]A\A]A^
AWAVA
AUATE
L$HA
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AVAUA
D$8D
[]A\A]A^
D$@A
]A\A]A^
D$@A
[]A\A]A^
[]A\A]A^
AUATI
[]A\A]
AVAUI
ATUH
[]A\A]A^
AWAVH
AUATI
[]A\A]A^A_
[]A\A]A^A_
D$	A
[]A\
[]A\
ATUSI
[]A\A]
ATUI
[]A\
AWAVI
AUAT
[]A\A]A^A_
5tXA
?<5t
AUATI
[]A\A]
AUATI
[]A\A]
5tk<
AUAT
[]A\A]
AWAVAUATA
[]A\A]A^A_
AVAUI
ATUA
[]A\A]A^
AVAU
ATUH
[]A\A]A^
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AUAT
[]A\A]
AUATI
[]A\A]
AUATI
[]A\A]
AUAT
[]A\A]
[]A\A]
AVAUATUH
]A\A]A^
[]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
ATUI
[]A\
AWAVI
AUATM
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUAT
]A\A]A^A_
AWAV
AUAT
X[]A\A]A^A_
AWAVD
AUAT
H[]A\A]A^A_
AWAV
AUAT
T$4E1
[]A\A]A^A_
AWAVE
AUATI
D$pD
T$<RD
X[]A\A]A^A_
AWAVAUATUSH
L$@E
t$@D
\$ A
T$@L
X[]A\A]A^A_
D$HD
\$<L
T$0H
L$(L	
L$(L
D$HL
T$0H
D$@f
d$@?
t$Bf
D$B1
t$DH
D$FH
AWAVAUATI
D$xH
L$pA
([]A\A]A^A_
([]A\A]A^A_
([]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUATI
([]A\A]A^A_
AVAUI
ATUE
@[]A\A]A^
AVAUATUSH
XZ[]A\A]A^
D$x1
A Santa lives evil at NASA
D$h 
D$l@
D$xdH3
AWAVH
AUATUSA
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVI
ATUSI
@uKA
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVA
AUAT
[]A\A]A^A_
ATUE
[]A\
AUATA
D$0E1
[]A\A]
AUATU
D$8D
L$@uV
L$0I
[]A\A]
t(H;x
D$(1
T$(dH3
t_H9
t H;Z
AWAVAUATUSH
[]A\A]A^A_
t+ATUH
[]A\
tCATUH
[]A\
tKATUI
[]A\
ATUI
[]A\
AUATI
[]A\A]
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
ATUSH
[]A\
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
\$ L
AUATL
[]A\A]
ATUH
[]A\
AUATA
[]A\A]
AWAVA
AUATA
L$hD
L$`H
T$P	
D$XD
[]A\A]A^A_
D$XD
[]A\A]A^A_
AWAVA
AUATA
L$XD
L$PH
D$h9D$`H
D$pH
9D$`
D$x9D$`
L$`H
L$hH
L$pH
L$x	
[]A\A]A^A_
[]A\A]A^A_
AWAVA
AUATH
T$HH
[]A\A]A^A_
AWAVE1
AUATA
'tUA
1u&A
([]A\A]A^A_
D;,$
D;l$
D;,$
D;l$
D;<$
D;|$
0< u)
ASARA
ASARA
AWAVA
AUATL
[]A\A]A^A_
set_branch_two_offsets
get_type_size
resolve_dst_region
validate_src_reg
get_subreg_address
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
%s:%d:%d: %s: 
%s:%s: 
gram.y
regfile != 3
%s: %d: %s at "%s"
error: wrong cache type
can't find register %s
non-int W/UW representation
non-float F representation
unknown immediate type %d
Invalid horiz size %d
Invalid execution size %d
syntax error
memory exhausted
warning
swizzle bits set in align1 instruction
error: indirect Source addr mode in align16 instruction
reg.vstride >= 0 && reg.vstride < (sizeof(vstride_for_reg) / sizeof(vstride_for_reg[0]))
reg.width >= 0 && reg.width < (sizeof(width_for_reg) / sizeof(width_for_reg[0]))
exec_size(insn) >= 0 && exec_size(insn) < (sizeof(execsize_for_reg) / sizeof(execsize_for_reg[0]))
execution size == width and hstride != 0 but vstride is not width * hstride
region width is 1 but horizontal stride is %d  (should be 0)
execution size and region width are 1 but horizontal stride is %d (should be 0)
execution size and region width are 1 but vertical stride is %d (should be 0)
must use the same flag register if both prediction and conditional modifier are enabled
resolved == 1 || resolved == 2 || resolved == 3
error: write mask set in align1 instruction
error: indirect Dst addr mode in align16 instruction
%s already defined and definitions don't agree
should be 'ENDIF execsize relativelocation'
ENDIF Syntax error: should be 'ENDIF'
IF should be 'IF execsize JIP UIP'
IF should be 'IF execsize relativelocation'
invalid syntax for send on gen6+
non-int D/UD/V representation: %d,type=%d
scalar register must be a0.0<0;1,0>:ud
Gen6+ doesn't have math function
Gen6- doesn't have vme function
Below Gen7.5 doesn't have CRE function
Gen6- doesn't support data port for sampler/render/constant/data cache
non-int D/UD/V/VF representation: %d,type=%d
Address immediate offset %d out of range
address register number %d out of range
accumulator register number %d out of range
flag register number %d out of range
flag subregister number %d out of range
mask register number %d out of range
mask stack register number %d out of range
notification register number %d out of range
state register number %d out of range
state subregister number %d out of range
control register number %d out of range
control subregister number %d out of range
error: relative offset %d out of range 
instruction_opcode(insn) != BRW_OPCODE_JMPI
unexpected token
input in flex scanner failed
bad buffer in yy_scan_bytes()
out of dynamic memory in yyensure_buffer_stack()
out of dynamic memory in yy_create_buffer()
fatal flex scanner internal error--end of buffer missed
fatal error - scanner input buffer overflow
out of dynamic memory in yy_get_next_buffer()
fatal flex scanner internal error--no action found
out of dynamic memory in yy_scan_buffer()
out of dynamic memory in yy_scan_bytes()
OPTIONS:
Can't find label %s
../../assembler/gen4asm.h
is_label(i)
e:l:o:g:abW
Couldn't open input file
Couldn't open output file
Read entry file error
export.inc
#define %s_IP %d
Could not flush output file
advanced
Degas are we not drawn onward no In union drawn onward to new eras aged
binary
export
input_list
output
<stdin>
usage: intel-gen4asm [options] inputfile
	-a, --advanced                       Set advanced flag
	-b, --binary                         C style binary output
	-e, --export {exportfile}            Export label file
	-l, --input_list {entrytablefile}    Input entry_table_list file
	-o, --output {outputfile}            Specify output file
	-g, --gen <4|5|6|7|8|9>              Specify GPU generation
Invalid Gen X decimal version
	0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,
	0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,
   { 0x%08x, 0x%08x, 0x%08x, 0x%08x },
label_name
static const char gen_eu_bytes[] = {
brw_pop_insn_state
brw_push_insn_state
brw_set_compression_control
../../assembler/brw_eu.c
!"not reached"
p->current != &p->stack[5-1]
p->current != p->stack
0x%08x: 
unset
  before: 
  after:  
  changed bits:
  bit %d, %s to %s
Instruction compact/uncompact changed (gen%d):
../../assembler/brw_eu_emit.c
execsize >= width
width == 1
../../assembler/brw_reg.h
(nr & ~(1 << 7)) < 16
dest.nr < 128
reg.nr < 128
!reg.negate
!reg.abs
reg.address_mode == 0
reg.file != 2
insn->header.access_mode == 1
dest.address_mode == 0
src0.file == 1
src0.address_mode == 0
src0.nr < 128
src1.file == 1
src1.address_mode == 0
src1.nr < 128
src2.file == 1
src2.address_mode == 0
src2.nr < 128
src1.type != 0
src1.type != 1
src0.type != 0
src0.type != 1
dest.type == src0.type
src0.type == src1.type
!"Bad type for brw_AVG"
dest.type != 7
!p->single_program_flow
dest.file == 1
src.file == 1
dest.hstride == 1
src.hstride == 1
!src.negate
!src.abs
src.type != 7
src.type == 7
intel->gen >= 6
src0.hstride == 1
src1.hstride == 1
src0.type != 7
src1.type != 7
src0.type == 7
src1.type == 7
!src0.negate
!src0.abs
!src1.negate
!src1.abs
msg_length < 16
swizzle_control != 2
block_end_ip != 0
intel->gen >= 7
hstride_for_reg[insn->bits1.da1.dest_horiz_stride] * reg_type_size[insn->bits1.da1.dest_reg_type] == 2
insn->header.execution_size >= 0 && insn->header.execution_size < (sizeof(execsize_for_reg) / sizeof(execsize_for_reg[0]))
type == 7 || type == 1 || type == 0
brw_is_single_value_swizzle(reg.dw1.bits.swizzle)
insn->bits1.da1.src0_reg_file != 3
intel->gen >= 4 || reg.address_mode == 0
!"realloc eu store memeory failed"
dest.file == 1 || dest.file == 2
src1.type == insn->bits1.da3src.src_reg_type
src2.type == insn->bits1.da3src.src_reg_type
src0.file != 0 || src0.nr != 0x20
src1.file != 0 || src1.nr != 0x20
insn->header.compression_control == BRW_COMPRESSION_NONE
insn->header.predicate_control == 0
if_inst != ((void *)0) && if_inst->header.opcode == BRW_OPCODE_IF
else_inst == ((void *)0) || else_inst->header.opcode == BRW_OPCODE_ELSE
if_inst->header.execution_size == 0
endif_inst->header.opcode == BRW_OPCODE_ENDIF
do_insn->header.opcode == BRW_OPCODE_DO
jmp_insn->header.opcode == BRW_OPCODE_JMPI
jmp_insn->bits1.da1.src1_reg_file == 3
insn->header.opcode != BRW_OPCODE_BREAK && insn->header.opcode != BRW_OPCODE_CONTINUE && insn->header.opcode != BRW_OPCODE_HALT
insn->bits3.break_cont.uip != 0
insn->bits3.break_cont.jip != 0
brw_shader_time_add
brw_find_loop_end
brw_set_uip_jip
brw_set_urb_message
brw_urb_WRITE
brw_oword_block_read_scratch
brw_oword_block_write_scratch
brw_math2
brw_math
brw_land_fwd_jump
alula
brw_WHILE
patch_IF_ELSE
convert_IF_ELSE_to_ADD
gen6_IF
brw_MUL
brw_AVG
brw_ADD
brw_set_3src_src2
brw_set_3src_src1
get_3src_subreg_nr
brw_set_3src_src0
get_3src_type
brw_set_3src_dest
brw_next_insn
brw_set_src1
validate_reg
brw_set_src0
brw_set_dest
brw_reg
brw_message_reg
../../assembler/gen8_instruction.c
gen8_exec_size(inst) >= 0 && gen8_exec_size(inst) < (sizeof(execsize_for_reg) / sizeof(execsize_for_reg[0]))
vstride == -1 || vstride == width * hstride
reg.subnr == 0 || reg.subnr == 16
(binding_table_index & 0xff) == binding_table_index
(msg_control & 0x3f) == msg_control
hstride == 0
vstride == 0
gen8_access_mode(inst) == 0
gen8_src0_reg_file(inst) != 3
(msg_type & 0x1f) == msg_type
gen8_set_dp_message
gen8_set_src1
gen8_validate_reg
gen8_set_src0
gen8_set_dst
../../assembler/ralloc.c
size >= 0
info->canary == 0x5A1106
ralloc_parent(ptr) == ctx
str != ((void *)0)
dest != ((void *)0) && *dest != ((void *)0)
ralloc_vasprintf_rewrite_tail
ralloc_vasprintf_append
printf_length
reralloc_size
get_header
0x%08xUD
0x%04xUW
0x%02xUB
Vector Float
0x%08xV
%-gF
*** invalid %s value %d 
null
acc%d
mask%d
msd%d
sr%d
cr%d
ARF%d
Eleele
src reg file
vert stride
horiz_stride
src reg encoding
,4,1>
channel select
src da16 reg type
g[a0
predicate inverse
predicate control align1
predicate control align16
*** invalid opcode value %d 
debug control
conditional modifier
.f%d
execution size
writemask
dest reg encoding
<4,1,1>
<%s>
 %d %d
target function
math function
math saturate
math signed
math scalar
math precision
 (%d, %d, %d, %d)
 (%d, %d, 
sampler target format
 (%d, %d, %d)
DP rc message type
, %d, %d, %d, %d)
urb opcode
urb swizzle
urb allocate
urb used
urb complete
unsupported target %d
mlen %d
 rlen %d
access mode
write enable control
dependency control
mask control
 compr4
compression control
end of thread
thread control
acc write control
interleave
transpose
urb_write
ff_sync
partial_precision
sqrt
sincos
intdivmod
intdiv
intmod
OWORD block read
RT UNORM read
OWORD dual block read
media block read
OWORD unaligned block read
DWORD scattered read
DWORD atomic write
OWORD block write
OWORD dual block write
media block write
DWORD scattered write
RT write
streamed VB write
RT UNORMc write
math
sampler
gateway
render
thread_spawner
const
data
.xyz
.xyw
.xzw
.yzw
nomask
NoDDClr
NoDDClr,NoDDChk
sechalf
compr
switch
.anyv
.allv
.any2h
.all2h
.any4h
.all4h
.any8h
.all8h
.any16h
.all16h
WE_normal
WE_all
AccWrEnable
.sat
.breakpoint
(abs)
cmpn
jmpi
else
endif
while
break
cont
halt
msave
mrest
push
wait
send
sendc
rndu
rndd
rnde
rndz
mach
sad2
sada2
line
Indirect align16 address mode not supported
;*3$"
3bb3fdbc282cc793c89e22aaf2e5c22a235751.debug
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
Tacocat
.fini_array
.jcr
.data.rel.ro
.dynamic
.got.plt
.data
.bss
.gnu_debuglink
