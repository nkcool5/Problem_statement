/lib64/ld-linux-x86-64.so.2
-eI]
libc.so.6
strcpy
exit
sprintf
setlocale
fopen
strncmp
strrchr
pipe
__strdup
perror
stpncpy
ftell
strncpy
fork
unlink
realloc
_libc_intl_domainname
abort
__dcgettext
strtol
fgets
strlen
__errno_location
dup2
stdout
fputc
fputs
memcpy
fclose
malloc
strcat
__xstat64
__ctype_b_loc
stderr
execvp
fwrite
textdomain
waitpid
fprintf
__stpcpy
fdopen
__ctype_toupper_loc
access
strcmp
__libc_start_main
free
__gmon_start__
GLIBC_2.14
GLIBC_2.2.5
GLIBC_2.3
%zO!
%rO!
%jO!
%bO!
%ZO!
%RO!
%JO!
%BO!
%:O!
%2O!
%*O!
%"O!
=4P!
AWAVA
AUATI
={N!
=qM!
/cpp
L$(D
T$,D
t$@H
=uL!
=TL!
D$(A
L$,H
[]A\A]A^A_
D$(1
L$,L
D$PH
AZA[
T$@H
|$81
T$@H
|$81
T$@H
|$81
|$81
T$@H
|$81
T$@H
|$81
T$@H
|$81
L$,H
=!F!
%}F!
%RF!
%'F!
AWAVI
AUATI
[]A\A]A^A_
=x?!
57>!
=.>!
=w=!
=%=!
=tC!
=m<!
tGUSH
=PB!
-8<!
=1;!
AWAVAUATUSH
D$ H
=z@!
=\@!
=9@!
=&@!
5};!
D$ H;(t
$H=5
[]A\A]A^A_
MakefileH
}	t*H
L$(H)
8[]A\A]A^A_
ATUA
=3<!
AWAVAUATA
5x5!
[]A\A]A^A_
H9D$
ATUA
ATUA
ATUA
=45!
AUATA
=.4!
[]A\A]
AWAVA
AUATA
D$PD
=c*!
[]A\A]A^A_
=c,!
=:,!
=1,!
=y+!
[]A\A]A^A_
=M)!
= &!
=K)!
=")!
5d,!
=~+!
]A\1
AVAUI
ATUI
=@+!
[]A\A]A^
=n)!
AWAVI
AUATUSH
=e(!
[]A\A]A^A_
=:$!
AWAVAUATUSH
=,!!
[]A\A]A^A_
-z !
tO[]A\A]A^H
[]A\A]A^
AVAUI
ATUI
[]A\A]A^
[]A\A]A^
[]A\
[]A\
AWAVI
AUATA
?Iu`A
NuYA
TuRA
[]A\A]A^A_
[]A\A]A^A_
AVAUA
[]A\A]A^H
AWAVI
AUATM
[]A\A]A^A_
<$&M
AWAVAUATUSH
(AYAZI9
_AXH
m(XZM
[(H9
[(A[A\H9
|$ H
[]A\A]A^A_
D9%M
[(Y^H
AWAVAUATUSH
[]A\A]A^A_
D9%-
[(A^A_H
]8_AXH
Eleele
(A[[M
[(AXAYH
[(AZA[H
ATUA
 []A\
 []A\
 []A\
 []A\
 []A\
ATUI
p[]A\
AWAV
AUATUSH
|$@H
[]A\A]A^A_
l$p1
D$xH
l$p1
D$xH
D$xH
D$pH
D$pH
D$xH
t$P1
D$XH
t$P1
D$XH
t$P1
D$XH
t$`1
t$hH
t$xH
t$p1
t$p1
D$XA
|$PI
t$XH
|$P%
D$XH
D$xH
t$`1
D$hH
AWAVAUATI
USE1
%t0H
/t+H
[]A\A]A^A_
_u:H
9+u0H
u([]A\
AUATA
[]A\A]
t:ATI
[]A\
AUATI
]A\A]A^
A\A]A^
AVAUATI
ub[]A\A]A^H
[]A\A]A^H
[]A\A]A^H
AUATI
[]A\A]
[]A\A]
AWAVAUATI
t\E1
~]E1
t$USH
ATUI
[]A\
AUATI
([]A\A]
AUATUSH
[]A\A]
svc_run 
returned
could no
t createH
 a handlH
AWAVAUATUSH
[]A\A]A^A_
unable t
o free a
rgumentsH
unable t
esulH
o free rf
t7SH
AUATI
[]A\A]
cannot gA
et transfD
port nam
cannot g
et transf
port inf
could no
modu
t get th
e right 
cannot c
reate se
rver han
[]A\A]
[]A\A]
[]A\A]
AWAV
AUATA
([]A\A]A^A_
t$[]A\A]A^
]A\A]A^
AWAV
AUAT
hh4A
L$ M
hh4A
[]A\A]A^A_
AWAV
AUATUSH
[]A\A]A^A_
ATUI
[]A\
AWAVAUATUSH
[]A\A]A^A_
5q| 
[]A\H
AWAVA
AUATL
[]A\A]A^A_
usage: %s infile
options:
-c		generate XDR routines
-C		ANSI C mode
-h		generate header file
Beeb
-M		generate MT-safe code
--help		give this help list
waitpid
rpcgen: too many defines
<stdin>
pipe
execvp
fork
%s: 
%s: unable to open %s: %m
<stdout>
_svc.c
_clnt.c
_xdr.c
_server.c
_client.c
_server
_client
# Parameters
CLIENT = %s
SERVER = %s
SOURCES.x = %s
TARGETS_SVC.c = %s %s %s 
TARGETS_CLNT.c = %s %s %s 
TARGETS = %s %s %s %s %s %s
# Compiler flags 
RPCGENFLAGS = 
# Targets 
all : $(CLIENT) $(SERVER)
$(TARGETS) : $(SOURCES.x) 
$(CLIENT) : $(OBJECTS_CLNT) 
$(SERVER) : $(OBJECTS_SVC) 
bool
u_int
u_long
u_short
-DRPC_XDR
#include "%s"
#include <rpc/rpc.h>
STDIN
-DRPC_HDR
_H_RPCGEN
#ifndef _%s
#define _%s
#include <rpc/rpc.h>
#include <pthread.h>
#ifdef __cplusplus
extern "C" {
#endif
/* the xdr functions */
#endif
#else /* K&R C */
#endif /* K&R C */
#endif /* !_%s */
-DRPC_CLNT
-DRPC_TBL
-DRPC_SERVER
-DRPC_CLIENT
-DRPC_SVC
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
Do nine men interpret Nine men I nod
#include <signal.h>
#include <sys/types.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netconfig.h>
#include <syslog.h>
illegal nettype: `%s'
--help
--version
2.23
rpcgen %s%s
_tbl.i
netpath
visible
circuit_v
datagram_v
circuit_n
datagram_n
rpcgen
/lib/cpp
	%s [-abkCLNTM][-Dname[=value]] [-i size] [-I [-K seconds]] [-Y path] infile
	%s [-c | -h | -l | -m | -t | -Sc | -Ss | -Sm] [-o outfile] [infile]
	%s [-s nettype]* [-o outfile] [infile]
	%s [-n netid]* [-o outfile] [infile]
-a		generate all files, including samples
-b		backward compatibility mode (generates code for SunOS 4.1)
-Dname[=value]	define a symbol (same as #define)
-i size		size at which to start generating inline code
-I		generate code for inetd support in server (for SunOS 4.1)
-K seconds	server exits after K seconds of inactivity
-l		generate client side stubs
-L		server errors will be printed to syslog
-m		generate server side stubs
-n netid	generate server code that supports named netid
-N		supports multiple arguments and call-by-value
-o outfile	name of the output file
-s nettype	generate server code that supports named nettype
-Sc		generate sample client code that uses remote procedures
-Ss		generate sample server code that defines remote procedures
-Sm 		generate makefile template 
-t		generate RPC dispatch table
-T		generate code to support RPC dispatch tables
-Y path		directory name to find C preprocessor (cpp)
-5		SysVr4 compatibility mode
--version	print program version
For bug reporting instructions, please see:
<https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs>
 * Please do not edit this file.
 * It was generated using rpcgen.
%s: C preprocessor failed with signal %d
%s: C preprocessor failed with exit code %d
cannot find C preprocessor: %s
file `%s' already exists and may be overwritten
%s: output would overwrite %s
%s: while writing output %s: %m
# This is a template Makefile generated by rpcgen
SOURCES_CLNT.c = 
SOURCES_CLNT.h = 
SOURCES_SVC.c = 
SOURCES_SVC.h = 
OBJECTS_CLNT = $(SOURCES_CLNT.c:%%.c=%%.o) $(TARGETS_CLNT.c:%%.c=%%.o)
OBJECTS_SVC = $(SOURCES_SVC.c:%%.c=%%.o) $(TARGETS_SVC.c:%%.c=%%.o)
CPPFLAGS += -D_REENTRANT
CFLAGS += -g 
LDLIBS += -lnsl -lpthread 
CFLAGS += -g 
LDLIBS += -lnsl
	rpcgen $(RPCGENFLAGS) $(SOURCES.x)
$(OBJECTS_CLNT) : $(SOURCES_CLNT.c) $(SOURCES_CLNT.h) $(TARGETS_CLNT.c) 
$(OBJECTS_SVC) : $(SOURCES_SVC.c) $(SOURCES_SVC.h) $(TARGETS_SVC.c) 
	$(LINK.c) -o $(CLIENT) $(OBJECTS_CLNT) $(LDLIBS) 
	$(LINK.c) -o $(SERVER) $(OBJECTS_SVC) $(LDLIBS)
clean:
	 $(RM) core $(TARGETS) $(OBJECTS_CLNT) $(OBJECTS_SVC) $(CLIENT) $(SERVER)
#if defined(__STDC__) || defined(__cplusplus)
#include <memory.h> /* for memset */
#include <sys/ioctl.h> /* ioctl, TIOCNOTTY */
#include <sys/types.h> /* open */
#include <sys/stat.h> /* open */
#include <fcntl.h> /* open */
#include <unistd.h> /* getdtablesize */
#include <sys/resource.h> /* rlimit */
#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif
#define _RPCSVC_CLOSEDOWN %s
Cannot specify more than one input file!
(Ubuntu GLIBC 2.23-0ubuntu10) 
Cannot use netid flag with inetd flag!
Cannot use netid flag without TIRPC!
Cannot use table flags with newstyle!
"infile" is required for template generation flags.
Cannot have more than one file generation flag!
void
bool_t
struct 
char *%s
opaque
God A red nugget A fat egg under a dog
%s%s %s
%s%s %s[%s]
%s%s *%s
struct {
	u_int %s_len;
	%s%s *%s_val;
} %s
#define %s %s
struct %s {
typedef struct %s %s;
extern %s_%s_nproc;
extern int 
_freeresult ();
extern  
enum clnt_stat 
bool_t 
CLIENT *
struct svc_req *
	bool_t %s;
	%s %s;
	union {
	} %s_u;
enum %s {
typedef enum %s %s;
 = %s
 = %d
 = %s + %d
typedef 
extern bool_t xdr_%s ();
extern struct rpcgen_table %s_%s_table[];
_freeresult (SVCXPRT *, xdrproc_t, caddr_t);
extern  bool_t xdr_%s (XDR *, %s%s);
sizeof (
%s), (xdrproc_t) xdr_%s
U_LONG
IXDR_PUT_
objp->%s = IXDR_GET_
*genp++ = IXDR_GET_
malloc failed
U_INT
%s(buf, objp->%s);
%s(buf, *genp++);
%s(buf);
register %s *genp;
for (i = 0, genp = objp->%s;
i < %s; ++i) {
bytes
pointer
 if (!xdr_%s (xdrs
(char **)
, %s
array
	 return FALSE;
vector
(char *)
 %s %s * %d
 %s%s 
Fatal error : no memory 
&objp->%s
		if (buf == NULL) {
		} else {
bool_t
xdr_%s (
XDR *xdrs, 
objp)
xdr_%s (xdrs, objp)
	XDR *xdrs;
	%s 
objp;
	return TRUE;
	register int32_t *buf;
	switch (objp->%s) {
	case %s:
&objp->%s_u.%s
		break;
	default:
		return FALSE;
enum
(enum_t *) objp
	int i;
	 return TRUE;
sizeof (bool_t), (xdrproc_t) xdr_bool
%s.%s_val, (u_int *) %s.%s_len
&%s->%s_val, (u_int *) &%s->%s_len
	if (xdrs->x_op == XDR_ENCODE) {
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
buf = XDR_INLINE (xdrs, (%s) * BYTES_PER_XDR_UNIT);
buf = XDR_INLINE (xdrs, (%d + (%s)) * BYTES_PER_XDR_UNIT);
		buf = XDR_INLINE (xdrs, %d * BYTES_PER_XDR_UNIT);
		buf = XDR_INLINE (xdrs, (%s) * BYTES_PER_XDR_UNIT);
		buf = XDR_INLINE (xdrs, (%d + %s)* BYTES_PER_XDR_UNIT);
buf = XDR_INLINE (xdrs, %d * BYTES_PER_XDR_UNIT);
u_char
u_quad_t
expected type specifier
array declaration expected
illegal result type
%s%d
only one argument is allowed
definition keyword expected
destroy
free
getpos
inline
reference
setpos
sizeof
union
voids allowed only inside union and program definitions with one argument
illegal (reserved) name :'%s' in type definition
no array-of-pointer declarations -- use typedef
variable-length array declaration expected
opaque -- illegal argument type
pointer to string not allowed in program arguments
arrays cannot be declared as arguments to procedures -- use typedef
Borrow or rob
illegal use of void in program definition
preprocessor error
unterminated string constant
empty char string
illegal character in file: 
const
switch
case
default
struct
typedef
unsigned
hyper
float
double
program
??????
constant or identifier expected
wrapstring
enum 
char *
%s_%s_svc
%s, line %d: 
too many files!
expected '%s'
expected '%s' or '%s'
expected '%s', '%s' or '%s'
failed in malloc
argument
%s_%s_%s
identifier
(SIG_PF)
(void(*)())
static void
closedown (int sig)
closedown (sig)
	int sig;
		extern fd_set svc_fdset;
		static int size;
		int i, openfd;
		struct t_info tinfo;
			exit (0);
		if (size == 0) {
			struct rlimit rl;
			rl.rlim_max = 0;
				return;
			}
			size = getdtablesize();
				openfd++;
		if (openfd <= 1)
		_rpcsvcstate = _IDLE;
	alarm (_RPCSVC_CLOSEDOWN);
#ifndef RPC_SVC_FG
%sint size;
%sstruct rlimit rl;
%sint pid, i;
%spid = fork();
%sif (pid < 0) {
%s	perror("cannot fork");
%s	exit(1);
%sif (pid)
%s	exit(0);
%srl.rlim_max = 0;
%ssize = getdtablesize();
%sfor (i = 0; i < size; i++)
%s	(void) close(i);
%s(void) dup2(i, 1);
%s(void) dup2(i, 2);
%ssetsid();
%si = open("/dev/tty", 2);
%sif (i >= 0) {
%s	if (nconf == NULL) {
cannot find %s netid.
%s		
%s_msgout ("%s");
%s		exit (1);
%s	}
%s	if (%s == NULL) {
cannot create %s service.
%s	freenetconfigent (nconf);
Tacocat
%s	if (!svc_reg (%s, %s, %s, 
, nconf)) {
	if (!svc_create (
, %s, %s, "%s")) {
	if (_rpcpmstart) {
A Santa lives evil at NASA
	svc_run ();
 *argp, struct svc_req *%s)
 (argp, %s, %s)
 (argp, %s)
	%s *argp;
	struct svc_req *%s;
	return (
*argp, 
argp->%s, 
%s));
(struct svc_req *%s, 
register SVCXPRT *%s)
(%s, %s)
	register SVCXPRT *%s;
		int fill;
_arg;
Degas are we not drawn onward no In union drawn onward to new eras aged
		%s
	} %s;
_res;
	char *%s;
	xdrproc_t _xdr_%s, _xdr_%s;
	bool_t (*%s)();
	char *(*%s)();
	_rpcsvcstate = _SERVING;
	switch (%s->rq_proc) {
%sexit (0);
%s_rpcsvcstate = _SERVED;
%sreturn;
noproc
		svcerr_%s (%s);
		_xdr_%s = xdr_%s;
		%s = (bool_t (*)()) 
		%s = (char *(*)()) 
		break;
getargs
decode
	%s = (*%s)(&%s, %s);
systemerr
freeargs
	if (!
	case NULLPROC:
static
void _msgout (msg)
	char *msg;
void _msgout (char* msg)
#ifdef RPC_SVC_FG
	if (_rpcpmstart)
	else
#else
extern
%s int _rpcpmstart;
%s int _rpcfdtype;
#define	_IDLE 0
#define	_SERVED 1
#define	_SERVING 2
mutex_t _svcstate_lock;
main (argc, argv)
	int argc;
	char **argv;
	int sock;
	int proto;
	struct sockaddr_in saddr;
	int asize = sizeof (saddr);
		int ssize = sizeof (int);
			exit (1);
		sock = 0;
		_rpcpmstart = 1;
		proto = 0;
		sock = RPC_ANYSOCK;
%spmap_unset (%s, %s);
	pid_t pid;
	char mname[FMNAMESZ + 1];
 !strcmp(mname, "timod"))) {
		char *netid;
		SVCXPRT *%s;
		int pmclose;
				exit(1);
		if (nconf)
			freenetconfigent(nconf);
		if (!svc_reg(%s, %s, %s, 
, 0)) {
unable to register (%s, %s).
		if (pmclose) {
		svc_run();
		/* NOTREACHED */
	else {
static
udp6
, 0, 0
%s		exit(1);
%s	if (!_rpcpmstart)
%s	proto = IPPROTO_%s;
, proto)) {
, IPPROTO_%s)) {
sock
%s	%s = svc%s_create(%s
SOCK_STREAM
SOCK_DGRAM
RPC_ANYSOCK
local
result
transp
rqstp
	mutex_lock(&_svcstate_lock);
	if (_rpcsvcstate == _IDLE) {
		if (!t_getinfo(0, &tinfo) && (tinfo.servtype == T_CLTS))
		if (_rpcfdtype == SOCK_DGRAM)
			getrlimit(RLIMIT_NOFILE, &rl);
			if ((size = rl.rlim_max) == 0) {
				mutex_unlock(&_svcstate_lock);
		for (i = 0, openfd = 0; i < size && openfd < 2; i++)
			if (FD_ISSET(i, &svc_fdset))
	if (_rpcsvcstate == _SERVED)
	mutex_unlock(&_svcstate_lock);
	(void) signal(SIGALRM, %s closedown);
%sgetrlimit(RLIMIT_NOFILE, &rl);
%sif ((size = rl.rlim_max) == 0)
%si = open("/dev/console", 2);
%s	(void) ioctl(i, TIOCNOTTY, (char *)NULL);
%sopenlog("%s", LOG_PID, LOG_DAEMON);
%s	nconf = getnetconfigent ("%s");
%ssyslog (LOG_ERR, "%%s", "%s");
%sfprintf (stderr, "%%s", "%s");
%s	%s = svc_tli_create (RPC_ANYFD, nconf, 0, 0, 0);
%s	(void) rpcb_unset (%s, %s, nconf);
unable to register (%s, %s, %s).
unable to create (%s, %s) for %s.
	if (%s == (SVCXPRT *)NULL) {
		(void) signal (SIGALRM, %s closedown);
		(void) alarm (_RPCSVC_CLOSEDOWN);
 *argp, void *%s, struct svc_req *%s)
	bool_t (*%s)(char *, void *, struct svc_req *);
	char *(*%s)(char *, struct svc_req *);
	bool_t (*_xdr_%s)(), (*_xdr_%s)();
%smutex_lock(&_svcstate_lock);
%smutex_unlock(&_svcstate_lock);
		_xdr_%s = (xdrproc_t) xdr_%s;
		%s = (bool_t (*) (char *, void *,  struct svc_req *))
		%s = (char *(*)(char *, struct svc_req *)) 
	memset ((char *)&%s, 0, sizeof (%s));
	if (!svc_%s (%s, (xdrproc_t) _xdr_%s, (caddr_t) &%s)) {
	%s = (*%s)((char *)&%s, %s);
	%s = (bool_t) (*%s)((char *)&%s, (void *)&%s, %s);
	%s = (bool_t) (*%s)(&%s, &%s, %s);
	if (%s > 0 && !svc_sendreply(%s, (xdrproc_t) _xdr_%s, (char *)&%s)) {
	if (%s != NULL && !svc_sendreply(%s, (xdrproc_t) _xdr_%s, %s)) {
_freeresult (%s, _xdr_%s, (caddr_t) &%s))
		(void) svc_sendreply (%s, (xdrproc_t) xdr_void, (char *)NULL);
		syslog (LOG_ERR, "%%s", msg);
		fprintf (stderr, "%%s\n", msg);
	syslog (LOG_ERR, "%%s", msg);
		/* Started by a port monitor ? */
		/* Whether Stream or Datagram ? */
 /* States a server can be in wrt request */
static int _rpcsvcstate = _IDLE;
	 /* Set when a request is serviced */
			/* Mutex lock for variable_rpcsvcstate */
main (int argc, char **argv)
	if (getsockname (0, (struct sockaddr *)&saddr, &asize) == 0) {
		if (saddr.sin_family != AF_INET)
		if (getsockopt (0, SOL_SOCKET, SO_TYPE,
				(char *)&_rpcfdtype, &ssize) == -1)
	struct netconfig *nconf = NULL;
	mutex_init (&_svcstate_lock, USYNC_THREAD, NULL);
	if (!ioctl(0, I_LOOK, mname) &&
		(!strcmp(mname, "sockmod") ||
		struct netconfig *nconf = NULL;
		if ((netid = getenv("NLSPROVIDER")) == NULL) {
		} else if ((nconf = getnetconfigent(netid)) == NULL) {
		if (strcmp(mname, "sockmod") == 0) {
			if (ioctl(0, I_POP, 0) || ioctl(0, I_PUSH, "timod")) {
		pmclose = (t_getstate(0) != T_DATAXFER);
		if ((%s = svc_tli_create(0, nconf, NULL, 0, 0)) == NULL) {
			(void) signal(SIGALRM, %s closedown);
			(void) alarm(_RPCSVC_CLOSEDOWN);
%s	if (!svc_register(%s, %s, %s, 
	if ((_rpcfdtype == 0) || (_rpcfdtype == %s)) {
argument
*%s, %s%s)
*argp, %s%s)
(%s)
(%s%s)
	%s%s;
argp
clnt
enum clnt_stat 
 arg;
	static 
char 
	 return 
	 if 
		TIMEOUT));
	arg.%s = %s;
	return 
	if 
		TIMEOUT));
		return (NULL);
	return ((void *)%s%s);
	return (%s%s);
/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { %d, 0 };
	memset((char *)%s%s, 0, sizeof(%s));
(clnt_call (clnt, %s, (xdrproc_t) xdr_void, 
(caddr_t) NULL,
		(xdrproc_t) xdr_%s, (caddr_t) %s%s,
		TIMEOUT) != RPC_SUCCESS) {
(clnt_call (clnt, %s, (xdrproc_t) xdr_%s
, (caddr_t) &arg,
		(xdrproc_t) xdr_%s, (caddr_t) %s%s,
	if (clnt_call (clnt, %s,
		(xdrproc_t) xdr_%s, (caddr_t) %s%s,
		(xdrproc_t) xdr_%s, (caddr_t) %s%s,
		TIMEOUT) != RPC_SUCCESS) {
	return (clnt_call(clnt, %s,
		(xdrproc_t) xdr_%s, (caddr_t) %s%s,
		(xdrproc_t) xdr_%s, (caddr_t) %s%s,
		TIMEOUT));
clnt_res
	xdr_%s,
sizeof ( 
	(char *(*)())RPCGEN_ACTION(
					
 * WARNING: table out of order
WARNING %s table is out of order
int %s_nproc =
	sizeof(%s_table)/sizeof(%s_table[0]);
	(char *(*)())0,
 	(xdrproc_t) xdr_void,			0,
 	(xdrproc_t) xdr_void,			0,
struct rpcgen_table %s_table[] = {
	bool_t retval;
	return &result;
	return (void *) &result;
	return retval;
	SVCXPRT *transp;
	xdrproc_t xdr_result;
	caddr_t result;
	return 1;
void
(char *host)
(host)
char *host;
	CLIENT *clnt;
#ifndef	DEBUG
enum clnt_stat retval_%d;
 *result_%d;
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
#endif	/* DEBUG */
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	retval_%d = 
	result_%d = 
(void*)
_arg, &result_%d, clnt);
_arg, clnt);
(&result_%d, clnt);
_%s, 
&result_%d, 
	if (result_%d == (
*) NULL) {
	char *host;
	if (argc < 2) {
		exit (1);
	host = argv[1];
exit (0);
	 * insert server code here
	 */
_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
_freeresult (transp, xdr_result, result)
	xdr_free (xdr_result, result);
	 * Insert additional freeing code here, if needed
	 */
	clnt = clnt_create (host, %s, %s, "%s");
	if (retval_%d != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
main (int argc, char *argv[])
main (argc, argv)
alula
int argc;
char *argv[];
		printf ("usage: %%s server_host\n", argv[0]);
;*3$"
struct rpcgen_table {
	char	*(*proc)();
	xdrproc_t	xdr_arg;
	unsigned	len_arg;
	xdrproc_t	xdr_res;
	unsigned	len_res;
retval
b38847e3f988f837c62d65495dc9101c8b01e5.debug
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.dynamic
.got.plt
.data
.bss
.gnu_debuglink
