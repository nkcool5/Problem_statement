/lib64/ld-linux-x86-64.so.2
libpcre.so.3
_ITM_deregisterTMCloneTable
__gmon_start__
_Jv_RegisterClasses
_ITM_registerTMCloneTable
pcre_version
_fini
pcre_free
pcre_exec
pcre_compile
_init
libstdc++.so.6
_ZTVN10__cxxabiv117__class_type_infoE
__gxx_personality_v0
_ZTVN10__cxxabiv120__si_class_type_infoE
__cxa_guard_abort
_ZTVN10__cxxabiv121__vmi_class_type_infoE
__cxa_pure_virtual
_ZdlPv
_Znam
__cxa_allocate_exception
_ZdaPv
_ZTIPKc
__cxa_guard_release
_Znwm
__cxa_throw
__cxa_guard_acquire
libgcc_s.so.1
_Unwind_Resume
libc.so.6
fflush
strcpy
__printf_chk
exit
fopen
strncmp
strrchr
ftell
strncpy
__stack_chk_fail
mkdir
realloc
strpbrk
popen
strspn
__assert_fail
strtod
strtok
strtol
fgetc
fgets
calloc
strlen
ungetc
memset
strstr
strcspn
__errno_location
fseek
memcmp
__fprintf_chk
stdout
fputc
memcpy
fclose
strtoul
malloc
__ctype_b_loc
getenv
sscanf
stderr
fscanf
pclose
fwrite
fread
strchr
qsort
__ctype_toupper_loc
__ctype_tolower_loc
__sprintf_chk
__xstat
memmove
strcmp
strerror
__libc_start_main
ferror
_edata
__bss_start
_end
GCC_3.0
CXXABI_1.3
GLIBCXX_3.4
GLIBC_2.4
GLIBC_2.14
GLIBC_2.3
GLIBC_2.2.5
GLIBC_2.3.4
%zW8
%rW8
%jW8
%bW8
%ZW8
%RW8
%JW8
%BW8
%:W8
%2W8
%*W8
%"W8
%zV8
%rV8
%jV8
%bV8
%ZV8
%RV8
%JV8
%BV8
%:V8
%2V8
%*V8
%"V8
%zU8
%rU8
%jU8
%bU8
%ZU8
%RU8
AWAVM
AUATI
=[]8
[]A\A]A^A_
AUATUSH
D$X1
l$0H
l$8H
l$8H
l$hH
T$XdH3
h[]A\A]
AWAVA
AUATA
=?[8
[]A\A]A^A_
=	Z8
AUATA
=iT8
D$XH
[]A\A]
AUATI
~THc
[]A\A]
AVAUI
ATUA
[]A\A]A^
AVAUI
ATUA
]A\A]A^
AVAUI
ATUA
]A\A]A^
AWAVA
AUATI
[]A\A]A^A_
=UJ8
AWAVI
AUAT
=-M8
=NL8
=IL8
[]A\A]A^A_
=oK8
=aD8
AVAUA
ATUI
]A\A]A^
AVAUI
ATUA
=S@8
]A\A]A^
=*?8
[]A\A]A^H
AUATI
=NB8
=IB8
= B8
[]A\A]
AUATI
[]A\A]
=K98
AVAUI
ATUA
=v?8
]A\A]A^
AVAUI
ATUA
~THc
]A\A]A^
=Y68
=958
AVAUI
ATUS
t`[]A\A]A^
[]A\A]A^
AWAVA
AUATA
[]A\A]A^A_
AWAVI
AUAT
[]A\A]A^A_
AUATA
[]A\A]
AWAVI
AUATA
[]A\A]A^A_
AWAVA
AUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AVAU
ATUA
~BHc
[]A\A]A^
AVAUA
ATUI
[]A\A]A^
AVAUATUH
-helf
dH34%(
 []A\A]A^
AWAVI
AUATA
[]A\A]A^A_
AWAV
AUATA
[]A\A]A^A_
AWAV
AUATA
[]A\A]A^A_
[]A\
[]A\
AWAVAUATUSH
[]A\A]A^A_
%O(8
%7%8
txSH
AUATUSH
[]A\A]
[]A\A]
AWAVAUATA
D$X1
|$0H
\$0H
|$8H
t$XUSH
D$@H
\$0H
|$8H
D$pH
D$HH
\$`H
|$hH
D$xH
D$PH
L$XdH3
h[]A\A]A^A_
AUATUSH
[]A\A]
[]A\A]
AWAVI
AUATI
[]A\A]A^A_
trHc
t#Hc
[]A\
AWAVI
AUATI
Y^ul
L$ I
([]A\A]A^A_
ATUStGH
8~tqH
[]A\L
[]A\
[]A\
AWAVAUATUSH
8[]A\A]A^A_
8[]A\A]A^A_
L$(H
d$(L
D$ H
D$(H
t$ H
D$ L
D$(t
D$ H
T$ H
T$ H
D$(H
T$0I
l$(H
L$01
T$ H
T$ H
AWAVAUATUSH
[]A\A]A^A_
AWAV
AUAT
D$X1
L$XdH3
h[]A\A]A^A_
|$0L
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
t$XS
t$XU
t$XH
D$0H
l$8H
D$`H
D$@H
l$hH
D$pH
D$HH
D$xH
D$PH
AWAV
AUATUSH
[]A\A]A^A_H
H[]A\A]A^A_
|$8H
AWAVE1
AUATUSH
L$0fE
D$0H
\$?H
t$8H
\$8M
L$(H
D$ H
[]A\A]A^A_
D$DH
D$HH
D$ H
D$ H
D$ H
D$ H
D$ E1
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
l$(H
D$ H
D$ H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
l$(H
l$(H
D$ H
l$(H
l$(H
D$ H
l$(H
l$(H
D$ H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
D$ H
l$(H
l$(H
D$ H
l$(H
D$ H
D$ H
D$ H
D$ H
t$XH
D$XM
D$hH
T$XL
D$ H
l$(H
l$(H
D$ H
l$(H
l$(H
l$(H
l$(H
D$ H
D$ H
D$pH
l$(H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
D$ H
D$hH
D$Pt
T$hI
T$XH
t$pE
D$ H
T$PH
D$ L
l$(H
D$ H
l$(H
D$ H
D$ H
T$PH
D$ H
D$ H
l$(H
5||7
T$PH
D$XH
D$Pt_H
T$PH
D$hH
t$XI
t$XH
D$ H
l$(H
l$(H
l$(H
D$ H
D$ H
D$ H
l$(H
D$ L
D$ H
D$ H
D$ H
D$ L
D$ H
L$XH9L$P
D$ H
|$PH
D$ H
=~|7
D$ H
D$PH
T$`H
|$PL
D$`M
t$`H
t$XH
=)y7
D$ H
-zw7
D$ H
D$ H
=6t7
D$ H
D$ H
t$hI
T$`L
t$hH
D$ H
D$ H
t$hI
T$`L
t$hH
D$ H
l$(H
l$(H
D$ H
5Ul7
D$ H
D$ H
D$ H
D$ H
D$ H
T$PE1
D$ H
D$ H
D$ H
D$ H
l$(H
D$ H
D$ H
l$(H
D$ H
l$(H
D$ L
D$ L
D$ L
D$ L
D$ L
D$ L
D$ H
D$ H
D$ L
D$ L
D$ L
D$ L
D$ L
D$ L
D$ L
5zY7
=#b7
D$ H
D$ H
D$ H
D$ H
L$ H
L$ H
D$ H
D$ H
D$ H
l$(H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
5.T7
=/T7
D$ H
D$ H
D$PH
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
T$PH
D$ H
T$PH
D$ H
D$ H
=aN7
D$ H
D$ H
D$ H
l$(H
l$(H
l$(H
D$ H
D$ H
5]L7
D$ H
=]K7
=BK7
D$ H
=tJ7
=cJ7
D$ H
D$ H
A]A^H
D$ H
D$ H
D$ H
_AXH
D$ H
AYAZH
D$ H
D$ H
D$ H
D$ H
D$ H
D$`E
T$`H
D$PuJ
t$`H
t$`L
D$ H
D$ H
D$ H
D$ H
D$ H
l$(H
D$ L
D$ H
D$ H
D$ H
D$ H
A[[H
D$ H
D$ H
AYAZH
D$ H
A[[H
D$ H
l$(H
D$ H
l$(H
D$ L
D$ L
l$(H
D$ L
l$(H
l$(H
D$ L
D$ H
D$ f
D$ H
D$ H
D$ E1
D$ fD
D$ fD
T$ H
\$(H
D$ H
D$ H
T$ H
D$ H
D$ H
=/)7
D$ H
D$ H
l$(H
l$(1
l$(1
=)(7
l$(1
l$(1
l$(H
D$ L
D$ L
D$ L
D$ L
D$ L
D$ L
D$ L
D$ H
D$ L
D$ L
D$ L
D$ L
D$ H
D$ H
D$ L
D$ H
D$ H
D$ H
D$ H
D$ H
t$PH
D$ H
l$(H
D$ L
D$ L
D$ L
D$ L
D$ L
D$ H
D$ H
D$ H
l$(H
D$ L
D$ L
l$(H
D$ L
D$ L
l$(H
D$ H
l$(H
D$ L
D$ L
D$ L
D$ L
D$ L
D$ H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
D$ H
l$(H
D$ H
l$(H
l$(H
l$(H
D$ L
D$ H
D$ H
l$(H
D$ H
l$(H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
|$PH
D$ H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
l$(H
D$ H
D$ H
D$ H
D$ H
D$ H
5Z	7
D$ H
l$(H
l$(H
D$ H
D$ H
l$(H
D$ H
D$ H
D$ H
l$(H
l$(H
D$ L
l$(H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
l$(1
l$(H
D$ H
D$ H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
l$(H
D$ H
T$PH
T$XH
D$ H
D$ H
l$(H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
l$(H
D$ H
D$ H
D$ H
l$(H
l$(1
l$(1
l$(1
l$(1
l$(1
D$ H
D$ H
D$ L
L$XH
D$xH
|$pH
D$ L
T$PH
L$X1
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
T$PH
D$ H
D$ H
l$(H
D$ H
|$XL
t$XL
D$ H
D"l$p
D$XH
D$XH
l$hH
L$`H
T$XH
D$PH
D$ L
T$XH
L$`H
l$pD)
t$`L
t$`H
t$`H
D$ H
D$ H
T$hL
t$XH
t$XH
l$(H
D$ H
D$ H
D$ H
D$ H
D$ H
T$PH
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
L$PH
D$ H
D$ H
D$ H
D$ H
l$(H
T$PH
T$PH
T$PH
D$ H
D$ H
D$ H
D$ H
D$ H
L$`H
T$XH
D$ H
D$ H
D$ H
T$PH
T$PH
T$PH
D$ E1
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ L
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
D$ H
t$XH
t$XH
|$PI
D$ H
D$ H
D$pt
T$hH
|$PL
D$ H
D$ H
D$xH
T$PH
|$PI
D$hL
D$`D
t$`H
l$hH
D$`L
|$PA
|$PA
|$`H
L$hA
l$`L
|$`L
D$ H
D$ H
|$xH
D$X1
D$Pt
|$XH
T$hL
T$`L
\$`L
D$ H
D$ H
D$ H
t$PH
L$hI
AXAY
D$ H
t$PH
D$ L
D$ L
D$ H
D$ H
D$ L
t$ H
t$ H
8(ur
AUATI
[]A\A]A^
t[AWAVI
AUATI
t*E1
[]A\A]A^A_
t$xL
t$xL
_AXA
|$pL
|$pH
|$pH
t$pH
t$pH
D$(H
D$ ~\
9D$ u
D$(H=
t$xI
|$pH
|$pH
|$pH
t$pH
t$pH
t$pH
t$pH
t$xI
L$ H
AWAVI
AUATI
|$hH
T$ H
L$`dH
\$xL
D$HH
D$(ZYt
|$ H
|$PH
|$8E1
|$8~,
|$XL
t$0H
l$HD
l$HH
|$(H
D$(H
L$ H
d$`f
[]A\A]A^A_
t$`H
l$XL
AWAVI
AUATUSH
t$(1
|$(H
D$0L
t$HH
[]A\A]A^A_
t$(H
|$0I
t$HH
D$lIc
|$PH
D$xH
9D$l
D$hH
9D$l
D$0H
t$PH
L$@H
T$8H
L$xH
d$p1
|$0E1
l$Xf.
t$pH
l$8E
L$XL
D$@H
t$HH
t$HH
5D|6
l$p1
t$HH
l$pD
l$ E
|$p1
l$pL
AVAUATUI
)t#H
[]A\A]A^
AUAT
[]A\A]
[]A\
[]A\
5zw6
t;SH
StBH
t3SH
AUATUSH
[]A\A]
[]A\A]
[]A\A]
trATUH
[]A\
T$8H
D$PH
[]A\
D$HH
D$0H
t$HP
T$ H
D$8H
T$(H
D$@H
t(SH
AUATA
[]A\A]
[]A\A]
ATUI
[]A\
[]A\
ATUI
[]A\
[]A\
ATUI
[]A\
[]A\
ATUA
[]A\
[]A\
tGSH
tkAUAT
[]A\A]
[]A\A]
ATUI
ATUSH
t8Hc
[]A\
AUATI
[]A\A]
[]A\A]
AUATI
[]A\A]
[]A\A]
[]A\A]
AWAV
AUATI
%tRH
dH3<%(
[]A\A]A^A_
\$ I
\$!A
|$`H
l$ H
|$ H
T$ H
D$ H
T$aH
<)t<
H9\$
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ATUI
D$pH
t$(H
T$0H
L$8L
D$@H
D$ L
t@H;
P[]A\
AWAVAUATUSH
[]A\A]A^A_
AVAUA
ATU@
]A\A]A^
ATUH
[]A\
ATU1
[]A\
u+A9
T$ H
L$(H
L$(H
t$ H
T$(H
L$(H
T$(H
D$X1
|$0H
\$0H
t$XSH
D$8H
\$0H
D$hH
D$@H
\$`H
D$pH
D$HH
D$xH
D$PH
L$XdH3
AVAUATUI
[]A\A]A^
]A\A]A^
AVAUATUI
tQE1
3H;n
]A\A]A^
3H;n
3H;n
AVAUATUH
[]A\A]A^
]A\A]A^
AUATE1
E9l$
[]A\A]
AUATUSH
~9E1
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATUSH
E9l$
E9l$
[]A\A]A^A_
AVAUATUSL
]A\A]A^
=jB6
|$(H
T$(H
T$ H
T$(H
ATUSL
A;l$
[]A\
ATU1
A9\$
[]A\
AVAUATUSL
[]A\A]A^
]A\A]A^
AVAUI
ATUSL
]A\A]A^
]A\A]A^
ATU1
A9\$
ATUSH
[]A\
x*9p
AUATA
/t{A
[]A\A]
5 B6
H;x r
=d@6
AWAV
AUAT
[]A\A]A^A_
x E9
AUATUSH
'IcD$
 t\A
[]A\A]
Q t;Hc
I Hc
tKATUH
[]A\
AUATI
tIL9
_t$H
[]A\A]
[]A\A]
tpAUATI
t=L9
[]A\A]
[]A\A]
tKATUH
[]A\
ATUH
"tFH
tXD:#u
[]A\
/Hcu
u Hc
USLc
}5Ic
K Hc
K Hc
AUATI
{ Hc
[]A\A]
{ Ic
AWAVAUATI
[]A\A]A^A_
$HcP
6HcQ
ATUSL
~%Hc
t$ )
[]A\
[]A\
ATUSH
u Ic
[]A\
AWAVI
AUATM
|$HH
T$@D
D$8D)
D$0H
D$8tsH
l$(H
D$ H
T$hHc|$h
D$HL
t$`H
p H9
HcD$PH
d$ L
l$(H
|$XH
t$@L
|$ H
'tfH
9t$P
D$8M
D$0I
HcD$8H
"tvH
|$XL
t$@L
|$ H
D$(L
t$HH
T$`H
D$lH
t$HH
x[]A\A]A^A_
[]A\A]A^A_
D$HL
P L)
x[]A\A]A^A_
D$HH
P H)
AVAU
]A\A]A^
]A\A]A^
]A\A]A^
]A\A]A^
AUATA
}`Hc
[]A\A]
[]A\A]
AUATUSH
[]A\A]
AVAUATUA
[]A\A]A^
t$(H
T$0H
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
ATUI
[]A\
ATUH
AUATI
[]A\A]
ATUH
[]A\
AUAT
[]A\A]
AWAV
AUATUSH
D$PE
d$$H
D$$1
X~>H
D$DH
D$HL
L$D9
D$@A
HcD$@
L$$9
D$ H
t>E9o
D$ ;D$$
HcD$ H
D$0L
L$0L
D$(H
D$0H
L$0L
D$(H
t$$I
l$DH
\$HH
[]A\A]A^A_
	w&H
AUATUSH
[]A\A]
[]A\A]
ATUH
[]A\
AUATUSH
tDH9
[]A\A]
[]A\A]
[]A\A]
ATU1
[]A\
[]A\
AVAUATUA
[]A\A]A^
[]A\A]A^
AWAVM
AUATI
[]A\A]A^A_
ATUSH
AUATI
[]A\A]
[]A\A]
[]A\A]
ATUH
u	[]A\
AWAVA
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATI
D$h1
L$hdH3
x[]A\A]A^A_
|$@H
\$HH
t$hS
t$hH
D$@H
\$HH
D$pH
D$PH
\$xH
D$XH
D$`H
AWAVAUATUSH
[]A\A]A^A_
AVAUI
ATUH
D$X1
|$0L
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
`[]A\A]A^
AVAUATUSH
[]A\A]A^H
]A\A]A^
AVAU
ATUSH
[]A\A]A^
[]A\A]A^
AWAV
AUATUSH
[]A\A]A^A_
AWAV
AUATUSH
D$x1
D$xdH3
[]A\A]A^A_
|$PH
\$XH
t$xS
t$xH
D$PH
\$XH
D$`H
D$hH
D$pH
D$xdH3
[]A\A]A^A_
AWAV
AUATUSH
[]A\A]A^A_
AWAV
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
AVAU
ATUH
[]A\A]A^H
AVAU
ATUSH
[]A\A]A^
AVAUATUSH
[]A\A]A^
tGSH
AUATI
[]A\A]
[]A\A]
AWAVAUATUSH
D$X1
|$0H
l$8H
t$XU
t$XH
D$0H
l$8H
D$`H
D$@H
l$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
h[]A\A]A^A_
AWAV
AUATUSH
L9,$
[]A\A]A^A_
[]A\
ATUH
AVAUI
[]A\A]A^
AWAVH
AUATUSH
D$X1
|$0L
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
h[]A\A]A^A_
AWAVAUATI
D$01
L$8H
t$0H
UATH
[]A\A]A^A_
|$HH
t$0H
L$ I
L$8H
AWAVAUATUSH
[]A\A]A^A_
9D$(
t9f.
t$,H
t$ H
t$ H
|$ 1
AVAUATUI
]A\A]A^
ATUSH
AUAT
[]A\A]
[]A\A]
AVAUI
]A\A]A^
ATUH
[]A\
ATUSH
[]A\
tSUSH
tdSH
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUAT
[]A\A]A^A_
[]A\
AWAVM
AUATI
8[]A\A]A^A_
t$pL
D$ 1
9D$ 
D"t$ 
|$ H
|$(L
AWAVAUATUSH
|$`H
\$PH
D$8M
\$ H
L$@9
t$8L
D$(E
D$(E1
9D$X
t$8L
D$(E
D$(E1
t$8L
T$(A
D$H1
H9D$
H9D$
T$XL
|$hL
\$(D!
[]A\A]A^A_
"\$(
T$XL
|$hL
\$(D!
|$hL
D$XA
"\$(
l$p1
l$(1
l$(@
D$`H
D$`H
\$ H
L$09
\$XH
L$h9
l$pL
t$HL
D$@E
D$@1
D$`M
"\$@
l$pL
T$XH
l$pL
t$HL
D$x1
H9D$
t$PL
L$8L
D$HH
T$ H
|$xI
T$xL
\$@D!
|$hL
D$XA
t$pH
t$hL
\$(L
D$`H
l$p1
l$(1
t$@H
|$@H
t$@H
|$@H
t$xH
t$pH
t$hL
\$(L
"\$x
"\$H
D$`H
9D$h
H9D$
t1E1
H9D$
t$(I
t$(I
t$XH
T$pE
D$xA
9D$h
H9D$
t.E1
H9D$
t$xH
\$@L
t$xH
H9D$
t.E1
H9D$
t$HH
|$XH
|$hL
|$HH
t$XH
D$`H
9D$XA
D$`H
AWAVAUATUSH
\$0H
L$D9
t$8L
D$ E
D$ E1
D$PM
l$ 1
tTE1
|$ A
t$8H
|$ 1
t$8H
D$ @
D$H1
D$PH
T$XL
|$`L
\$ D!
[]A\A]A^A_
[]A\A]A^A_
"\$ 
"\$X
|$h1
|$ 1
|$ @
@"l$H
L$HH
|$XL
|$`L
D$XA
=vm5
D$PH
T$0H
|$PH
x[]A\A]A^A_
|$XL
t$hH
t$`L
\$ L
d$h1
d$X1
D$PH
|$XH
t$`L
T$hu/H
T$X9D$ 
T$ H
|$HL
|$P1
D$PH
9D$`
D$PH
|$HL
t$ L
t$XH
|$HH
|$ H
D$PH
9D$H
AWAVI
AUATH
%Dc5
[]A\A]A^A_
AWAVAUATUSH
H[]A\A]A^A_
\$8H
L$$9
|$(H
[]A\A]A^A_
|$(H
L$0H
L$0H
=7\5
L9|$
|$(H
AWAVAUATI
[]A\A]A^A_
ED$ 
ED$ 
ED$ 
D$ tYH
D$,~G1
9\$,u
D$0t
D$0H
AWAVI
AUATI
[]A\A]A^A_
AWAVI
AUAT
[]A\A]A^A_
|$ H
|$ H
T$ H
[]A\
[]A\
ATUSH
[]A\
AUATI
[]A\A]H
ATUI
[]A\
|$XH
[]A\H
AUATH
[]A\A]1
[]A\A]
[]A\A]1
AWAVI
AUATI
]A\A]A^A_
AVAUATUH
|$XM
]A\A]A^
AWAVAUATI
([]A\A]A^A_
AUATH
[]A\A]
[]A\A]
AWAVAUATI
([]A\A]A^A_
<Ftx
<9vqH
AUATI
|$XL
[]A\A]
AWAVI
AUAT
[]A\A]A^A_
AWAVAUATI
D$X1
|$0L
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
h[]A\A]A^A_
AVAU
ATUE1
]A\A]A^
AWAV1
AUATI
4$E1
[]A\A]A^A_
AWAVI
AUAT
4$E1
[]A\A]A^A_
AUATUSH
]A\A]1
AUATUSH
]A\A]1
AWAVAUATUSH
|$0H
|$(H
\$ L
D9d$@
|$8H
|$ L
\$ L
T$(H
X[]A\A]A^A_
|$0L
t$(H
|$0H
|$0H
|$0H
AWAVAUATI
D$h1
|$@H
\$HH
t$hS
t$hH
D$@H
\$HH
D$pH
D$PH
\$xH
D$XH
D$`H
D$hdH3
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
[]A\A]
[]A\A]
ATUH
[]A\
[]A\
ATUH
|$0H
t$(S
t$(H
\$8H
l$hH
t$XU
t$XH
l$hH
[]A\
AWAV
AUATUSH
D$x1
|$PH
l$XH
t$xU
t$xH
D$PL
t$XH
D$`L
D$hH
D$pH
t$xU
t$xH
D$PH
l$XH
D$`H
D$hH
D$pH
L$xdH3
[]A\A]A^A_
h ]S
[]A\
[]A\
[]A\
[]A\
[]A\
AWAVAUATI
L$8H
H[]A\A]A^A_
AWAVAUATUSH
&uLH
L$ H
D$ H
T$(1
t$0H
T$(1
h[]A\A]A^A_
AWAVAUATUSH
T$|H
D$(I
D$0I
D$|L
T$|H
[]A\A]A^A_
D$8t
t$8H
D$pH
\$xH
D$pH
T$xH
T$ H
D$pH
\$xH
T$ H
D$ H
AWAVI
AUAT
|$hL
d$@H
T$8E1
\$ I
<$E1
l$pL
t$xA
l$pL
t$xI
t$01
|$01
t$0H
L$`D
t$PL
t$H1
t$8H
[]A\A]A^A_
l$pL
T$ H
t$8H
t$8H
|$hH
t$8H
\$hH
t$8H
t$(H
L$ H
t$@H
|$P1
|$hI
t$(L
|$hL
t$8H
AUATI
([]A\A]
AVAUATUH
D$X1
L$XdH3
`[]A\A]A^
|$0H
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
h[WU
h[YS
h@hS
UhjYS
AVh|YS
ATUH
AWAVAUATUSH
[]A\A]A^A_
ATUH
ATUH
AUATI
[]A\A]
AUATH
[]A\A]
[]A\A]
AUATI
[]A\A]
!t>H
[]A\A]
ATUH
AWAVAUATI
8[]A\A]A^A_
8[]A\A]A^A_
t$ H
|$(H
AWAVI
AUAT
|$XL
|$hH
|$XL
|$hH
[]A\A]A^A_
ATUH
AWAVAUATI
[]A\A]A^A_
AVAUI
ATUH
D$X1
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
`[]A\A]A^
\$8H
ATUH
[]A\
AWAVH
AUAT
D$X1
|$0H
\$8H
t$XS
t$XH
D$0H
\$8H
T$PH
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
L$XdH3
h[]A\A]A^A_
AWAVAUATUSH
T$ H
D$`f
\$PH
L$,9
|$`H
\$HA
|$@L
|$ H
|$8H
|$@H
\$HA
|$ H
|$8H
x[]A\A]A^A_
l$PL
d$hL
l$ L
x[]A\A]A^A_
AVAUH
ATUI
D$X1
|$0L
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
`[]A\A]A^
ATUI
D$(1
D$(dH3
0[]A\
AWAVAUATI
D$x1
|$PL
D$XH
\$PM
t$xAWSH
D$`L
D$XH
\$PH
D$hM
D$pH
L$xdH3
[]A\A]A^A_
AUATI
[]A\A]
ATUH
u	[]A\
[]A\
AVAUATUS
[]A\A]A^
[]A\A]A^
AWAV
AUATI
$tyL
[]A\A]A^A_
|$pL
|$pL
|$pL
|$pL
|$pL
|$pL
ATUH
[]A\
ATUS
]A\A]A^
]A\A]A^
AWAVI
AUATI
[]A\A]A^A_
|$pH
|$pH
AWAVAUATI
[]A\A]A^A_
|$pL
|$pL
|$pL
|$pL
AWAVI
AUATI
T$xH
T$(H
d$4E
D$(H
\$4E
T$4E
|$0H
|$ H
L$4E
D$0E
|$8L
|$@1
|$P1
|$HL
T$XH
|$`I
|$hL
|$pL
T$xE1
|$hH
|$(E1
D$(L
A_XL
|$pL
L$(H
T$4E
|$(E1
D$(H
T$hH
|$PA
|$HA
T$@H
T$HH
D$(H
t$(L
[]A\A]A^A_
|$(H
L$pH
t$8H
L$PH
D$PH
T$@H
|$(H
|$(H
L$ H
D$(H
|$(H
A^A_
|$(H
5,}4
AZA[
|$(H
AWAVI
AUATI
[]A\A]A^A_
AWAVAUATI
AWhG
L$@I
t$ 1
t$ L
[]A\A]A^A_
D$XH
D$XH
L$PH
|$(H
|$@I
|$8I
he{S
hv{S
D$H1
d$(H
d$(H
D$XH
D$XH
L$PH
AWAVI
AUATH
[]A\A]A^A_
AWAVI
AUATI
D$Pt
|$(1
t$pH
|$hL
D$xH
|$ H
|$ H
D$xH
L$hH
|$8E1
t$(L
|$HL
|$H1
|$@L
|$@1
|$PL
|$PL
|$81
|$ H
9D$\
|$(1
|$PA
T$H1
T$P1
t$pH
|$xH
[]A\A]A^A_
D$`L
|$pH
D$0L
D$`I
|$pL
|$pL
D$0L
D$`I
D$`L
|$pH
|$pH
|$pL
|$pL
|$pH
|$(1
t$pH
|$pH
|$pL
D$0H
L$`H
L$`H
D$`H
T$@E1
|$(I
|$pL
|$pH
D$`I
D$`I
|$p1
|$p1
|$p1
D$`I
D$`I
AWAVI
AUATUSH
[]A\A]A^A_
T$@H
t$8H
L$@H
|$81
T$8L
L$ H
D$s1
\$hH
d$PL
D$HH
|$@H
D$8E
t$hL
D$x~
D$xH
D$x~
D$xH
|$X1
D$x~
D$xH
|$`1
t$@H
|$PL
t$`L
d$PL
l$XH
t$(H
T$8H
t$@H
D$@H
T$ H
t$01
[]A\A]A^A_
T$0H
t$ L
59>4
5	>4
|$(1
5?=4
|$(1
5p<4
T$8H
t$8H
t$8H
t$(H
L$8H
t$(H
|$ 1
|$(1
AWAVAUATI
|$ L
|$@I
|$8H
|$PH
T$HI
[]A\A]A^A_
d$ H
D$ H
T$PH
D$ H
9D$x
D$ 1
t$X1
t$H1
|$ L
|$01
|$01
|$01
D$ H
|$ L
t$`H
|$p1
|$p1
t$pL
|$`H
t$ I
T$`L
|$p1
5=(4
AVAUATUH
[]A\A]A^
AWAVE1
AUATI
[]A\A]A^A_
D$ 1
t$(E1
t$ H
t$(A
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
D$(I
hm}S
T$ I
8[]A\A]A^A_
T$ H
D$ L
[]A\A]A^A_
t$(H
t$(H
t$(H
AWAVAUATI
D$ H
D$(H
x[]A\A]A^A_
D$ H
D$(H
D$0H
[]A\A]A^A_
x[]A\A]A^A_
l$XA
T$XI
|$PL
|$PI
L$@H
T$XI
AWAVAUATI
D$@H
[]A\A]A^A_
DD$8H
|$HE1
l$XL
|$8H
L$DE
t$XL
D$`~
D$`H
D$`~
D$`H
t$ L
D$`~
D$`H
|$ L
|$H1
D$DE
|$8H
|$PL
|$PH
l$XH
|$@A
T$HE1
T$ 1
t$XL
|$8H
|$PL
|$H1
|$8H
|$PL
T$HE1
|$8H
|$PL
T$HH
ATUH
[]A\
[]A\H
tf[]A\H
AWAVAUATUSH
[]A\A]A^A_
D$(H
L$$E
D$$E
D$7t
D$ 1
[]A\A]A^A_
ATUH
AUATUSH
[]A\A]
AUATUSH
[]A\A]
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
T$ t
t$ M
t$8L
D$HL
AVAUATUH
[]A\A]A^
[]A\
AWAVI
AUATUSH
[]A\A]A^A_
L$PH
L$@H
t$HH
t$@1
T$hL
L$XL
D$0H
L$PL
t$0H
D$8H
T$8H
l$Pf
AUATI
[]A\A]
AVAUATUH
[]A\A]A^
]A\A]A^
ATUH
[]A\
[]A\
AVAUATI
]A\A]A^
]A\A]A^
ATUH
[]A\
ATUH
[]A\
t+H9
t&<.t"H
[]A\
[]A\
AWAVI
AUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AVAUI
ATUH
]A\A]A^
AWAVI
AUATI
D$x1
|$PH
\$XH
t$xS
t$xH
D$PH
\$XH
D$`H
D$hH
D$pH
L$xdH3
[]A\A]A^A_
|$PI
\$XH
t$xS
t$xH
D$PH
\$XH
D$`H
D$hH
D$pH
AVAU
ATUI
]A\A]A^
AWAVI
AUATI
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUAT
T$(M
[]A\A]A^A_1
t$(H
|$0L
|$0L
t$8H
D$ H
D$ H
kXt>H
|$(H
|$@H
|$0H
D$HL
|$0H
D$xH
T$HL
T$@H
t$(H
D$8M
D$ H
AVAUATUH
D$X1
|$0H
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
T$XdH3
`[]A\A]A^
AWAVI
AUATI
D$Pt
|$81
T$xH
|$hH
D$pH
|$(H
D$pH
L$hH
|$0E1
|$ H
t$8L
l$HH
|$H1
l$@H
|$@1
l$PH
|$PH
|$01
|$(1
9D$d
|$(1
|$81
|$PA
T$H1
T$P1
T$xH
\$(1
|$pH
[]A\A]A^A_
T$@E1
|$x1
|$x1
AWAVI
AUATI
T$xH
T$0H
|$<E
D$0H
T$xE1
L$0H
Borrow or rob
D$ I
L$8L
|$HH
|$`L
T$@I
T$@H
T$pH
D$@H
|$@H
|$(1
\$8E
T$PH
|$(H
|$XH
|$hH
|$X1
l$0E1
|$xE1
|$ 1
|$ 1
5&t3
|$ 1
|$ 1
5Ss3
AYAZ
|$ 1
d$<E
|$0E1
D$0H
|$@H
L$XH
D$<E
[]A\A]A^A_
|$0H
L$(I
l$<E
D$0H
l$0L
D$0H
|$0H
|$0H
L$HH
5$g3
|$0H
5Xf3
|$0H
|$0H
A[A\
AWAVAUATI
[]A\A]A^A_
T$(H
L$@H
|$ H
L$0H
|$`L
l$XH
D$|D
t$pL
T$@H
T$HH
T$HH
T$HH
|$`1
|$XH
|$PL
|$`L
l$XH
T$(H
AWAV1
t$HH
L$pH
T$@I
[]A\A]A^A_
|$H1
5'Z3
|$H1
AWAV1
t$HH
L$pH
T$@I
|$(1
5nX3
E|$`
|$(1
AWAVAUATUSH
t$ H
|$XI
t$ H
|$PH
t$ H
|$hH
\$ L
[]A\A]A^A_
T$8H
D$0H
|$0H
T$8H
D$0H
|$0H
D$(9
t$`L
d$xL
d$ f
t$x1
t$`1
t$H1
l$XL
T$pI
|$@1
5'K3
|$@1
|$@1
\$ H
t$ H
|$ 1
|$ L
|$ L
5SG3
|$ 1
5=F3
AVAUATUH
[]A\A]A^
AWAVE1
AUATI
[]A\A]A^A_
D$ 1
t$(E1
L$ I
t$(A
AWAVAUATUSH
[]A\A]A^A_
AVAUATUH
[]A\A]A^
ATUH
[]A\
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
=843
AWAVI
AUATUSH
[]A\A]A^A_
t$PH
T$ H
|$01
T$ H
|$(1
T$ H
|$8L
t$HH
|$PH
|$(A
|$8A
T$8H
t$HH
|$ 1
5G-3
|$ 1
t$0H
T$(E1
AWAVAUATUSH
[]A\A]A^A_
hm}S
H=0UE
!t}H
AUATUSH
[]A\A]
AUATUSH
[]A\A]
[]A\A]
AWAVAUATUSH
-,"3
[]A\A]A^A_
AVAUATUH
[]A\A]A^
ATUH
[]A\
AWAVI
AUATUSH
L$`H
D$8I
|$81
T$PL
|$01
T$ 1
t$8H
l$@1
t$0H
D$8H
T$0H
T$ H
\$XI
D$`H
ATUH
D$`H
[]A\A]A^A_
t,I9
t'<.t#L
AWAVAUATI
t[L9
[]A\A]A^A_
[]A\
AUAT
[]A\A]
ATUH
[]A\
AWAVAUATUSH
L$0D
D;,$
D;,$
[]A\A]A^A_
D$0H
L$<H
|$(D
ATUH
[]A\
t`ATE1
[]A\
AUATI
 txH
[]A\A]
[]A\A]
AUATI
[]A\A]
AUATI
[]A\A]
[]A\A]
AUATUSH
[]A\A]
tdSH
AUATI
[]A\A]
[]A\A]
AWAVAUATI
[]A\A]A^A_
ATUI
AWAVM
AUATI
L$x1
D$xdH3
[]A\A]A^A_
|$PH
T$XM
t$xAW
t$xH
D$PL
|$XH
D$`L
D$hH
D$pH
ATUH
[]A\
ATUH
 []A\
AWAVA
AUATA
D$(1
D$ H
T$ H
D$ H
T$ H
L$(dH3
8[]A\A]A^A_
D$ XD
D$ XD
AVAUI
ATUI
Z[]A\A]A^
]A\A]A^
AWAVI
AUATH
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATI
L$ I
[]A\A]A^A_
[]A\A]A^A_
AWAVA
AUATUSH
D$(1
L$(dH3
8[]A\A]A^A_
D$ H
T$ H
D$ XD
AWAVAUATI
D$(1
L$(dH3
8[]A\A]A^A_
D$ H
T$ H
D$ XD
AWAVI
AUAT
D$x1
D$xdH3
[]A\A]A^A_
|$PL
\$ H
t$xH
D$PL
T$XH
D$`M
D$hH
D$pH
t$xAW
D$PL
|$XH
D$`L
D$hH
D$pH
D$xdH3
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATI
([]A\A]A^A_
AWAVI
AUATI
D$GH
D$H1
D$9M
D$0H
D$(L
T$(H
L$HdH3
X[]A\A]A^A_
AWAVAUATUSH
D$ 1
|$0L
l$ I
D9d$
D9d$
|$0H
l$8H
|$ 1
L$ I
D;d$
D$(H
[]A\A]A^A_
D$(H
|$ 1
T$ 1
AWAVI
AUATI
T$(L
t$ H
<$E1
D9|$
<$E1
D9|$
t$ L
<$E1
|$81
l$8M
l$8H
D$ I
T$(H
[]A\A]A^A_
D$ H
T$(I
AWAVI
AUATUSL
t$ H
T$@H
L$8L
t$(H
|$ L
T$8H
D$0E1
t$0L
d$PH
D9l$
d$PH
l$XH
|$01
|$(H
L$0H
T$(H
t$ H
|$(L
t$ H
D$(H
T$@M
t$ H
[]A\A]A^A_
T$ H
D$HH
t$ 1
|$01
T$01
D$(H
T$@M
t$ H
AWAVI
AUATI
[]A\A]A^A_
([]A\A]A^A_
 uYI
AWAVI
AUATI
 tgI
T$ E1
|$(I
|$ H
8[]A\A]A^A_
t$ 1
t$ A
T$ E1
t$ A
AWAVAUATI
([]A\A]A^A_
-R}2
AUATUSH
[]A\A]
ATUA
 []A\
AWAVAUATUSH
D$H1
|$ H
D$HdH3
X[]A\A]A^A_
AWAVAUATUSH
n(dH
L$H1
t$(L
~(tdH
;l$8
9l$8t~M
9l$8I
$9D$8
l$8A)
D$ H
T$ E1
L$FH
D$0H
t$0H
$9L$8
\$8H
D$G1
L$GL
|$ M
AYAZL
9l$8
D$ H
 tAI
L$HdH3
X[]A\A]A^A_
|$ A
T$ E1
T$ H
D$G1
AWAVAUATUSH
L$hL
D$XL
L$xH
t$(H
D$ H
D$0H
D$8dH
|$0L
D$HH
D$ND
t$(1
D$pt
L$H9L$
l$0E1
|$`H
D$@I
D9l$
|$`L
D$@H
T$81
t$(H
L$XH
T$`E1
L$H9L$
|$0E1
D;l$H
T$xE1
t$0H
t$h1
D$XH
9l$H
9l$H
[]A\A]A^A_
t$8L
t$(E1
T$hE1
L$H9L$
t$01
D$HD
AXAYH
|$8H
t$`H
L$H9L$
D$OH
T$H9T$
t$0D
|$HA
D$@1
t$0H
T$8H
t$(E1
T$ E1
t$0H
T$xE1
D$@H
T$ 1
T$8H
t$(E1
T$8H
t$(H
D$OH
AZA[
L$H9L$
T$xE1
T$8H
T$xE1
t$8L
 t.H
t$(L
AWAVAUATM
l$8L
d$HL
t$PE
D$0H
l$XL
\$@L
|$`D
D$pH
t$0H
|$/H
T$`H
t$0H
D$XA
_AXL
|$XA
D;d$
AQAWM
UAVH
[]A\A]A^A_
D;d$
t$0H
AWAVAUATI
[]A\A]A^A_
A[A\H
=9B2
_AXH
AYAZH
AWAVAUATUSH
5m;2
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
AUATUSH
[]A\A]
]A\A]
AWAVI
AUAT
[]A\A]A^A_
QATPAWL
|$0L
D$8L
L$(H
T$ E1
t$ H
T$(H
t$ H
AWAVI
AUAT
[]A\A]A^A_
D$ H
|$pH
|$pM
D$xL
|$pH
t$ E1
t$(M
D$8j
t$@M
t$(H
L$HL
|$pH
|$pM
D$xL
|$pH
AWAVI
AUATH
|$pH
T$(dH
D$xH
D$pH
D$xH
4$E1
d$(I
_AXH
t$0H
\$ E1
|$(L
t$ H
|$(H
D$pL
T$xH
|$(H
T$ A
T$(H
4$E1
|$(H
D$pL
|$xH
[]A\A]A^A_
L$8H
T$(I
AWAVI
AUATH
T$Kt
\$`E
t$0H
D;t$`
|$XD
T$(t
D;t$`
D$0I
"D$K
t$x1
"D$ 
D$0H
T$`E
t$dH
D$PH
D$(t
\$(H
L$L9L$<I
D$d;D$`
l$<L
D9t$L|
9D$L
|$ H
;l$`
9D$L
;l$`
L$LE
D$(H
t$x1
9D$<
9l$<
D$@H
|$@L
D$hI
L$pH
L$pH
L$pE1
9l$<
D$0H
L$L9L$<
L$L9L$<
\$<I
9\$L
D$<9
t$hI
D9|$<
L$@I
\$dI
D$hI
t$hI
L$`9L$d
[]A\A]A^A_
L$L9L$<
D$0H
D$0H
T$x1
D$(H
9D$<
T$0H
T$xE1
AWAVAUATI
[]A\A]A^A_
L;<$u
D$+M
D$,P
L$ Qj
T$+A
D$<H
AWAVI
AUATI
D$x1
L$xdH3
[]A\A]A^A_
|$PH
\$XH
t$xS
t$xH
D$PH
\$XH
D$`H
D$hH
D$pH
AWAVAUATUSH
t$0H
l$ H
D$`H
t$8L
\$@H
D$`H
\$(H
L$@H
D$hH
T$(E1
T$`E1
T$HE1
T$hE1
T$ E1
T$PE1
L$(H
t$HE1
A_XL
A\A^
|$0A
|$0H
t$8A
AXAYH
AZA[H
D$X1
[]A\A]A^A_
D$@H
D$(H
D$XH
l$XE1
t9f.
t$`H
D$X1
L$(H
D$8A
T$(E1
L$0H
T$(E1
AWAVI
AUAT
T$(H
t$hH
t$H1
D$pL
T$`I
d$0H
[]A\A]A^A_
t$0E1
L$HE1
|$01
 t8H
T$pE1
D$0~c
 t>H
|$0E1
 t8H
|$01
T$xE1
D$0~v
D$P1
T$@E1
D$01
\$@D
D$@t;
l$@1
l$@1
|$@1
|$@1
|$@1
|$@1
D$PE1
|$@1
L$xH
T$pE1
D$0L
|$@f
|$@H
_AXL
T$PI
|$PM
T$@H
|$@1
|$@1
l$@1
t$0H
l$@1
T$8E1
8Chs
L$0H
T$PE1
l$0H
D$@L
 t@1
L$PH
|$@E1
D$0H
l$@1
t$pH
L$pL
L$0H9
T$xA
 t8H
D$@tI
l$@1
l$@1
|$@1
|$@1
T$8E1
|$@1
t$PA
|$PA
A[A\L
D9|$PH
|$@1
|$@1
|$@1
T$xE1
|$PM
AYAZ
|$@1
|$@E1
AYAZ
|$@1
|$@1
T$pH
|$@1
|$@H
T$pE1
L$pL
D$ H
D$pH
t$PL
|$@1
|$@1
|$@1
l$@1
t$0H
l$@1
|$@1
|$@1
|$@E1
T$pH
|$@1
|$@1
|$@1
|$@H
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
D$x1
L$xdH3
[]A\A]A^A_
l$XH
t$xU
t$xH
D$PH
l$XH
D$`H
D$hH
D$pH
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
AUATI
[]A\A]
AWAVAUATUSH
D$XH
l$TH9
asgmA
efneA
udqsA
ahit
nik{
{l~rH
L9t$
t$XL
\$`H
L$ D
t$TH
t$ D
H3|$ L1
L3T$ L
$.L1
|$HH1
|$8H
|$0H
|$@H
dH34%(
[]A\A]A^A_
|$hH
asgmA
efneA
udqsA
ahit
nik{
{l~r
H	D$ 
AWAVAUATUSH
|$(H
|$(L
[]A\A]A^A_
AWAVI
AUATUSH
\$pL
t$hH
|$(1
D9d$
D$0t
|$XH
D9d$
|$(1
|$(1
|$ 1
|$ 1
D9d$
D9d$
D;d$D
\$ H
D$pH
\$pH
|$H1
\$pL
T$hI
t$`L
\$`H
|$x1
t$H1
t$`1
5~u1
T$hH
=7t1
T$hH
L$DE1
=Fs1
5$s1
|$ 1
[]A\A]A^A_
D9d$
|$XL
D$0H
t$hH
=2o1
T$hH
|$pH
t$`1
5Ym1
T$hH
T$(H
=vm1
t$ H
=Vm1
=Am1
=;m1
T$(H
t$ H
T$hH
=pl1
T$(H
=Pl1
t$ H
=0l1
T$`H
\$pL
|$xH
=Aj1
=%j1
l$DH
=li1
==i1
|$`H
t$hH
5Hh1
=1h1
\$hH
D$DL
T$hA)
=;g1
=ng1
=_f1
AWAVAUATUSH
8[]A\A]A^A_
=0d1
=Vd1
T$ H
=\a1
=o`1
=O`1
=1`1
[]A\A]A^A_
=k^1
=s^1
=`^1
=n\1
=9\1
=I[1
=&[1
=[Y1
=9Y1
D$(H
D$ H
AVAU
ATUH
=9X1
=9X1
=!X1
=mW1
=*W1
[]A\A]A^
=!W1
=mV1
=ZV1
=pU1
=EU1
=9T1
=0S1
=-S1
=FS1
=0S1
[]A\A]A^H
=iQ1
=UQ1
AUATI
D$X1
L$XdH3
h[]A\A]
|$0H
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
=fN1
=vN1
=:N1
_AXL
=QM1
=fL1
=GL1
=uL1
=WL1
=:L1
=@K1
=`K1
AVAUATUH
=LI1
]A\A]A^
=!H1
AVAUI
ATUH
]A\A]A^
AVAUATUH
[]A\A]A^
=WE1
ATUH
5jD1
=oC1
=AC1
5.C1
=7C1
=vB1
=2B1
="B1
5~B1
=oB1
5kB1
=TB1
5XB1
=9B1
5EB1
="B1
D$X1
|$0H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
D$XdH3
ATUH
u	[]A\
[]A\
5%<1
AWAVI
AUATI
[]A\A]A^A_
ATUH
tb[]A\
[]A\
AWAVAUATUSH
[]A\A]A^A_
ATUS
]A\A]A^
]A\A]A^
AWAVI
AUATI
[]A\A]A^A_
|$pH
|$pH
AWAVA
AUATE1
[]A\A]A^A_
AVAU
ATUI
]A\A]A^
AWAVI
AUATI
[]A\A]A^A_
AWAVAUATUSH
d$XM
D$PH
T$XH
D$`I
D$hH
D$pH
t$xAT
t$xH
D$PL
d$XH
D$`L
D$hH
D$pH
[]A\A]A^A_
AWAVI
AUATI
D$Pt
t$@1
t$xH
|$hH
D$pH
D$pH
L$hH
|$(E1
|$@I
L$ L
|$HL
|$H1
|$PL
|$P1
|$(1
|$81
|$(H
D$ 9D$`
t$@1
t$x1
t$8H
|$pH
[]A\A]A^A_
D$XH
L$0H
L$0H
L$XH
L$XH
L$XH
L$XH
D$XH
L$0H
L$0H
T$PE1
T$H1
|$x1
t$8H
|$@H
|$x1
AVAUI
D$X1
L$XdH3
`[]A\A]A^
|$0L
d$0M
t$XATH
D$8L
d$0H
D$hH
D$@L
d$`H
D$pH
D$HH
D$xH
D$PH
t$8M
AWAVAUATUSH
h[]A\A]A^A_
T$(1
T$(H
D$01
\$8L
t$8H
t$8L
D$X~
D$XH
D$X~
D$XH
|$@1
T$0H
|$HL
|$@L
|$@L
l$HH
[]A\A]A^A_
|$@L
t$8H
t$(1
T$(L
D$(E
T$(H
t$(H
t$(H
T$(H
T$(H
AWAVI
AUAT
|$HI
|$8H
|$PH
T$HI
[]A\A]A^A_
T$P1
L$(9L$x
\$0I
t$X1
t$@1
D$|I
t$ H
|$ 1
|$ 1
|$ 1
T$8E1
t$`L
|$p1
|$p1
t$pL
|$`H
T$`L
|$p1
ATUSH
[]A\
AWAVAUATUSH
D$x1
D$xdH3
[]A\A]A^A_
|$PH
\$XH
t$xS
t$xH
D$PH
\$XH
D$`H
D$hH
D$pH
D$xdH3
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
AWAVI
AUAT
T$(I
ARhG
D$ H
[]A\A]A^A_
|$0I
|$(I
D$Hho
AVhp
D$(1
t$ H
t$(H
\$8H
l$@H
\$8H
t$ 1
\$XH
D$HH
D$HH
L$@H
D$HH
D$HH
L$@H
t$PL
AWAVAUATI
[]A\A]A^A_
T$XH
AWAVI
AUAT
T$@H
DD$hL
\$xH
T$0H
D$0H
|$HI
|$h1
AZA[E1
|$HH
|$HL
D$xH
D$ I
|$PL
\$,E
D$8H
ED$`
|$8H
l$8H
T$,E
t$ 1
|$`H
|$XI
L$xE1
L$xH
T$@E1
|$pH
l$,E
|$0I
|$HH
T$(I
|$0E1
|$HH
|$HH
|$ 1
|$HH
|$ 1
|$HI
|$h1
|$HH
|$ 1
|$HI
AXAY
|$HH
|$ 1
D$0H
|$HH
|$ 1
l$0H
t$h1
[]A\A]A^A_
t$p1
t$xH
D$0I
L$PH
d$ H
D$0L
\$xL
|$HH
D$0H
D$0H
l$hH
|$hH
|$0H
|$0H
|$h1
|$HI
|$h1
D$0H
l$0H
|$HH
|$0H
|$0H
t$p1
l$h1
|$0H
|$HI
|$h1
AXAY
|$0H
|$HH
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUATE1
[]A\A]A^A_
t$ E1
L$(I
t$ A
AWAVAUATI
[]A\A]A^A_
AVAUATUH
[]A\A]A^
AWAVAUATUSH
D$(M
T$ I
8[]A\A]A^A_
D$ H
[]A\A]A^A_
t$(H
t$(H
t$(H
AWAVAUATE1
D$ H
D$(H
D$0H
D$8H
X[]A\A]A^A_
D$ H
D$(H
D$0H
D$8H
[]A\A]A^A_
X[]A\A]A^A_
T$HH
D$@I
D$@1
ATUI
D$X1
L$XdH3
`[]A\
|$0H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
AWAVI
AUATE1
[]A\A]A^A_
|$(H
L$8I
|$0A
l$HD
t$HL
t$HH
D$X~
D$XH
D$X~
D$XH
|$01
t$@H
|$PL
|$ L
|$0L
l$oL
t$PH
l$HH
D$8~
D$8E
T$0E1
|$0L
T$0H
AUATUSH
[]A\A]
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
L$ E
[]A\A]A^A_
D$ E
AUATUSH
]A\A]
AUATUSH
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
\$81
T$8ARL
AVAUATUH
[]A\A]A^
5um0
=fm0
5|l0
=ml0
5Ol0
=@l0
5"l0
ATUH
[]A\
AWAVI
AUATUSH
[]A\A]A^A_
\$XH
AShG
t$HL
T$hAR
t$PL
T$xH
D$pH
D$0H
d$xM
t$@L
d$xH
D$pH
\$xH
5A[0
D$pL
d$xH
=GR0
AVAUH
ATUI
[]A\A]A^
[]A\A]A^
AWAVAUATI
|$PH
[]A\A]A^A_
5AN0
AUATI
[]A\A]
[]A\A]1
AVAUATUI
]A\A]A^
ATUH
[]A\
AWAVI
AUATH
(D:L$`H
([]A\A]A^A_
AWAVI
AUATH
(D:L$`H
([]A\A]A^A_
D$X1
|$0H
D$8H
T$XdH3
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
AVAUATUI
[]A\A]A^
[]A\A]A^H
[]A\A]A^H
=t90
]A\A]A^
[]A\A]A^
]A\A]A^
ATUI
[]A\
AVAU
ATUI
]A\A]A^
ATUI
[]A\
ATUI
[]A\
ATUH
[]A\
ATUH
[]A\
=i-0
ATUH
[]A\
AUATUSH
[]A\A]
AWAVI
AUAT
D$(1
L$(dH3
8[]A\A]A^A_
AWAVAUATI
[A\A]A^A_]
AWAVAUL
ATSI
[A\A]A^A_]
AVE1
AWAVAUATSH
[A\A]A^A_]
AWAVAUATI
D$(1
\$(dH3
8[]A\A]A^A_
AWAVAUATUSH
D$(1
L$(dH3
8[]A\A]A^A_
AUAT
([]A\A]
AVAU
ATUH
 []A\A]A^
AWAV
AUATUSH
D$H1
L$HdH3
X[]A\A]A^A_
|$0H
|$0H
|$0H
|$0H
AWAVAUATUSH
|$pdH
\$xH
D$@H
\$HH
D$PH
D$XH
D$`H
[]A\A]A^A_
|$`H
AWAVAUATUSH
D$H1
|$0H
L$HdH3
X[]A\A]A^A_
|$0H
AUATUSH
|:Hc
 w+H
 v_)
[]A\A]
AWAV1
AUATUSH
D$H1
L$HdH3
X[]A\A]A^A_
|$0H
|$0H
|$0H
AWAVAUATI
([]A\A]A^A_
AVAUATUH
 []A\A]A^
AWAVAUATI
|$PdH
D$x1
\$XH
D$hH
|$@H
t$xS
t$xH
D$@H
\$HH
D$PH
D$XH
D$`H
L$xdH3
[]A\A]A^A_
|$@H
|$@H
AWAVAUATI
[A\A]A^A_]
D$81
AWAVAUATI
[A\A]A^A_]
ATUSH
[]A\
AUATI
[]A\A]
AUATI
[]A\A]
AUATUH
]A\A]A^
]A\A]A^
AUATUSH
[]A\A]
AUATI
[]A\A]
AWAVI
AUAT
[]A\A]A^A_
AVAUATUSH
]A\A]A^
AUATUSH
[]A\A]
AUATUSH
[]A\A]
AWAVA
AUATA
[]A\A]A^A_
[]A\A]A^A_
AWAVA
AUATA
[]A\A]A^A_
|$0L
l$0H
|$`H
\$`H
D$8H
\$0H
D$@H
D$HH
D$PH
t$XUH
D$8H
l$0H
D$hH
D$@H
l$`H
D$pH
D$HH
D$xH
D$PH
[]A\1
AWAVAUATUSH
[]A\A]A^A_
ATUI
ATUSH
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AWAVH
AUATI
[]A\A]A^A_
[]A\A]A^A_
AWAVE1
AUATA
[]A\A]A^A_
D$0H
AVAU1
ATUA
]A\A]A^
AWAVE1
AUAT1
[]A\A]A^A_
AVAUATUH
[]A\A]A^
[]A\A]A^
AWAVI
AUATI
[]A\A]A^A_
AWAVA
AUATA
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
ATUH
[]A\
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
~SE1
$9D$
AWAVAUATUSH
t;E1
[]A\A]A^A_
AVAUATUSt
[]A\A]A^
AUATUSH
[]A\A]
[]A\A]
ATUH
[]A\
AWAVAUATUSH
[]A\A]A^A_
@ H=
AWAVAUATUSH
[]A\A]A^A_
AWAVA
AUATA
AZA[
[]A\A]A^A_
([]A\A]A^A_
AWAVAUATE1
L$$H
([]A\A]A^A_
AWAVAUATI
[A\A]A^A_]
AVAUA
ATUA
[]A\A]A^
Zu	H
ATUH
[]A\
AWAVAUATI
[]A\A]A^A_
D$ H
D$(H
D$0H
D$8H
D$@H
D$HH
T$Xt
L$,E
D$HH
D$PH
D$ H
D$0H
D$(H
D$8E
D$@A
|$hH
|$xH
|$xH
D$pH
T$`H
t$hH
T$`H
T$hH
|$hH
T$`H
D$pH9D$
|$xH
L$`H
|$`H
t$xI
H;l$p
t$hH
D$XL
|$`H
L$XH
t$xI
H;l$pt~H
|$`1
L$XH
t$xI
H;l$pu
t$hH
D$XE1
AUATUSH
[]A\A]
AUATUSH
[]A\A]
AWAVA
AUATA
h	5T
L$xdH3
[]A\A]A^A_
|$PH
t$PM
t$xAVH
D$XL
t$PH
D$`L
D$hH
D$pH
AWAVE1
AUATA
[]A\A]A^A_
T$ 	
|$`H
d$`M
D$hL
d$`H
D$pL
D$xH
D$ I
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
=1~/
=[}/
=Z|/
tTUSH
AWAVI
AUATH
D$@L
l$(H
\$0D
l$@A
l$(H
\$0H
T$8H
t$HL
|$(L
T$8H
D$(H
L$81
T$(H
T$@H
T$(H
L9t$
[]A\A]A^A_
H9D$
H9D$
l$(H
\$0A
AWAVAUATUSH
[]A\A]A^A_
=qr/
=9r/
=Nq/
5Bp/
=(o/
5Kn/
=Nm/
=%n/
D$X1
|$0H
\$8H
l$0H
=)d/
t$XSUH
D$@H
\$8H
l$0H
D$pH
D$HH
l$`H
\$hH
D$xH
D$PH
D$XdH3
=Jc/
=)c/
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
AUAT
([]A\A]
AWAVAUATUSH
|$@H
t$(H
D$Ht
|$HH
T$HI
\$(L
|$8H
|$(H
D$0B
t_D9l$
|$ 1
|$(I
D9l$
|$0H
D;l$8H
T$01
|$(H
\$(H
t$XL
t$(1
[]A\A]A^A_
|$0H
L$@H
|$ 1
t$(1
t$@L
T$(H
|$@H
|$X1
D$@H
D$@H
=*T/
\$(H
|$@H
T$(H
|$@L
9\$|}
l$HH
D$8H
|$8H
\$8H
l$HH
\$@L
L$@H
D$@L
D$@L
AWAVAUATUSH
8[]A\A]A^A_
t$ 1
t$ 1
t$ 1
=#Q/
[]A\A]A^A_
~AE1
T$(E1
hWAU
t$0A
L$(A
t$ 1
T$ L
T$ E1
T$ L
T$ E1
T$ L
AVAUATUH
hWAU
Z[]A\A]A^
]A\A]A^
AWAVAUATUSH
([]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
=[@/
=E@/
[]A\A]A^A_
hWAU
h ST
h@ST
hGJT
D$8E
5o;/
L$8E1
=93/
D$8E
L$8E1
\$@H
T$Pj
h8KT
ARh4
AQh4
APh4
]A^L
T$ 1
L$(I
T$01
=r'/
L$8E1
L$8E1
D$ E1
hWAU
|$8I
t$81
|$8I
t$81
hWAU
AWAVAUATUSH
[]A\A]A^A_
hWAU
D$81
hWAU
T$8L
hWAU
T$8L
hWAU
T$8L
AWAVAUATUSH
[]A\A]A^A_
hWAU
hWAU
AWAVAUATUSH
([]A\A]A^A_
hWAU
hWAU
AWAVAUATUSH
[]A\A]A^A_
hWAU
|$ L
hWAU
A^A_
hWAU
hWAU
|$ L
hWAU
hWAU
hWAU
hWAU
AVAUATUH
[]A\A]A^
hWAU
hWAU
hWAU
hWAU
AWAVI
AUATUSH
[]A\A]A^A_
hWAU
|$(H
hWAU
hWAU
hWAU
ATUH
[]A\
AWAVAUATUSH
\$pL
D$0H
ATSH
\$pL
d$xH
h8KT
L$XAQh4
APh4
D$89D$<
t$8H
[]A\A]A^A_
AUATUSH
[]A\A]
AWAVI
 AUATUSH
<$E1
[]A\A]A^A_
D$PH
AWAVI
AUATA
[]A\A]A^A_
AWAVI
AUATI
D$x1
Lct$
D$xdH3
[]A\A]A^A_
L;%.
|$PH
\$XH
t$xS
D$PH
\$XH
D$`H
D$hH
D$pH
D$xdH3
[]A\A]A^A_
|$PH
d$PM
t$xAT
D$XL
d$PH
D$`L
D$hH
D$pH
AUATI
[]A\A]
ATU1
[]A\
ATUH
[]A\
[]A\
[]A\
AUATE
[]A\A]
AWAVH
AUATA
:t0@
	wfIc
[]A\A]A^A_
AWAVM
AUATM
|$@H
[]A\A]A^A_
AWAVI
AUATI
H[]A\A]A^A_
AWAVI
AUAT
tmf.
t$ I
:t3A
t$ L
T$(B
t$7H
t$7H
T$(B
x[]A\A]A^A_
t$ E1
:t4@
t$ L
:t3A
:t3A
AWAVAUATI
:t5A
|$(@
t$ H
8[]A\A]A^A_
AWAVAUATUSH
D$X1
T$ H
t$81
t$81
D$XdH3
h[]A\A]A^A_
D$(1
L$@H
AVAU
ATUI
[]A\A]A^
AWAVI
AUATH
D$(H
D$ t*H
|$0H
|$0L
t$x1
D$pL
l$xH
[]A\A]A^A_
D$8L
AWAVAUATUSH
T$XH
L$ L
L$ L
D$XH
\$HH
5sz.
|$8I
L$@A
|$01
t$(I
[]A\A]A^A_
l$01
|$8E1
AWAVAUATI
|$`H
l$hH
D$PL
D$PH
l$XH
D$`H
D$hH
D$pH
[]A\A]A^A_
L$PL
AUATI
[]A\A]
AUATUSH
[]A\A]
5tp.
AWAVI
AUATM
57o.
[]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
AWAVAUATUSH
T$8H
D$ E1
t$PA
ATAVL
h@{S
[]A\A]A^A_
D$(H
D$(H
L$ H
D$X1
|$0H
t$XSH
D$8H
\$0H
D$hH
D$@H
\$`H
D$pH
D$HH
D$xH
D$PH
D$XdH3
D$XdH3
AWAV
AUATI
D$h1
|$@H
\$HH
D$hdH3
x[]A\A]A^A_
t$hI
t$hSM
t$hS
t$hH
D$@H
\$HH
D$pH
D$PH
\$xH
D$XH
D$`H
AWAVI
AUAT
|$ H
D$/A
[]A\A]A^A_
AWAVAUATI
D$h1
|$@L
\$HH
t$hS
t$hH
D$@H
\$HH
D$pH
D$PH
\$xH
D$XH
D$`H
L$hdH3
x[]A\A]A^A_
AWAVI
AUATUSH
t$ L
t$ H
|$0H
|$ H
\$(L
l$8L
T$@H
t$81
t$(1
D$\I
x[]A\A]A^A_
5FO.
t$ 1
|$ 1
|$ L
t$`H
|$ L
T$0E1
T$ H
t$@H
|$`1
5#L.
AWAVAUATI
t$8H
|$(L
|$ L
t$0L
|$ L
|$ L
l$@H
t$8H
t$8H
t$@H
X[]A\A]A^A_
X[]A\A]A^A_
AWAVAUATI
D$81
L$8dH3
H[]A\A]A^A_
T$ H
T$(H
AWAVI
AUATUSH
T$xdH
t$01
t$01
t$`M
|$0E
|$H1
l$`L
T$h1
t$PH
]A\L
T$h1
t$PH
AZA[
T$@H
D$0H
|$P1
l$0L
d$01
d$0L
L$xE1
|$(1
|$8L
|$ 1
D$HH
t$x1
|$pL
L$8L
D$(1
D$ H
T$ L
D$PH
D$hH
L$pH
t$p1
[]A\A]A^A_
T$ L
D$(H
T$HH
T$hE1
t$PH
|$H1
|$`H
T$x1
t$`H
T$HH
|$PL
T$`j
A^A_H
D$ H
t$H1
L$`H
|$PL
D$HH
L$xE1
t$P1
AWAVAUATI
[]A\A]A^A_
ATUI
|$0dH
D$X1
\$0H
l$8H
t$XSH
D$8H
\$0H
D$hH
D$@H
\$`H
D$pH
D$HH
D$xH
D$PH
D$XdH3
`[]A\
AWAVE1
AUATUSH
[]A\A]A^A_
Y^t"H
|$PH
|$XH
t$xH
D$PH
|$XH
D$`H
D$hH
D$pH
D9d$
D9d$
AWAVAUATI
[]A\A]A^A_
t$(1
t$ H
t$ H
t$ H
t$ H
AUATUSH
]A\A]
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
AUATUSH
[]A\A]
AWAV
AUATUSH
[]A\A]A^A_
AVAUATUH
[]A\A]A^
AWAVI
AUATUSH
D$pL
D$pH
D$XM
t$8hq
t$ph
D$PL
D$PH
D$P1
T$dH
D$P1
T$(H
D$P1
D$PH
D$PH
|$PI
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
ATUI
[]A\
AWAVAUATI
D$XtbH
|$ H
D$HH
|$HH
l$HH
\$@H
t$(1
|$PH
\$(I
l$ H
\$ H
t$PL
t$ 1
T$(I
[]A\A]A^A_
t$ 1
T$ H
t$(L
L$HH
|$P1
T$P1
L$ H
L$XI
|$ H
l$(H
D$tH
T$P1
AWAVAUATI
([]A\A]A^A_
D$X1
[]A\A]A^A_
AWAVAUATUSH
|$(H
[]A\A]A^A_
t$ H
l$(H
D$0H
D$81
T$@RL
AVAUI
_AXH
AYAZH
]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
ATUI
AVAUI
]A\A]A^
ATUH
StdH
8~ti
[]A\
[]A\E1
AWAV
AUATUSH
([]A\A]A^A_
[]A\A]A^A_
T$$M
L$ 1
AWAVAUATI
([]A\A]A^A_
<"t}<\
</t <*td
AWAVI
AUATUSH
[]A\A]A^A_
t{ATU
[A^]
AWAVI
AUATI
|$PL
T$pH
L$XdH
|$@A
d$4E1
T$(H
L$ E1
L$ H
T$(E1
|$8H
\$4E
t$ H
L$4E
\$@H
T$4E
t$ H
|$XA
|$PH
[]A\A]A^A_
t$ H
D9d$0
D$ H
D$`H
D$`H
T$xH
|$hH
_AXH
L$`H
L$`H
D$`L
t$81
t$ H
t$8H
|$(A
|$hH
|$(E1
|$hH
L$`H
AWAVAUATI
[]A\A]A^A_
[]A\A]A^A_
|$(1
|$(1
AWAVAUATUSH
t$(H
D$xL
|$8H
|$0H
t$0H
|$(L
t$XH
T$81
T$0E1
|$(L
9l$$
l$HM
|$(L
\$(H
t$pL
t$(1
T$8I
T$`1
L$@I
_AXE
T$PH
[]A\A]A^A_
t$PL
t$(1
T$(H
t$8H
t$PH
|$p1
T$PH
|$(H
t$8L
L$PH
L$PH
AWAVI
AUATUSH
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
t$ L
AWAVI
AUATUSH
[]A\A]A^A_
AWAVI
AUAT
D$ L
[]A\A]A^A_
|$`H
d$hM
D$`L
d$hH
D$pL
D$xH
-$|-
=M{-
AUATI
=dz-
[]A\A]
[]A\A]
AWAVAUATUSH
=	w-
=6v-
=+v-
[]A\A]A^A_
=*v-
AUATUSH
53t-
5Ws-
5Ns-
5%s-
5Cs-
5*s-
5is-
=gs-
=or-
=$r-
=	r-
=fr-
5^r-
5Cr-
=mp-
=Rp-
5ip-
=jp-
5fp-
=Wp-
5[p-
=,p-
5@p-
=Ap-
=Qo-
5uo-
=6o-
5bo-
=Ko-
5Oo-
5<o-
=zn-
=dn-
=xn-
[]A\A]
[A^]
=Yd-
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUAT
|$HL
L$XdH
t$@A	
D$ 1
L$ H
t$ I
t$ H
d$8E
\$8E
|$HH
[]A\A]A^A_
|$XA
T$hH
|$HH
D$ H
T$8E
|$ H
|$pA
t$(1
|$8H
t$01
|$(1
|$`H
T$@H
|$`I
5?Z-
AXAY
|$`I
|$01
AWAVAUATUSH
D$(H
h[]A\A]A^A_
D$ I
|$HI
T$@H
|$0L
L$ H
|$81
|$@I
T$8H
|$01
|$ H
[]A\A]A^A_
|$(1
|$(1
5oS-
AWAVI
AUATI
D$PtgH
|$@H
h[]A\A]A^A_
h[]A\A]A^A_
|$X1
<9v<
|$ H
|$ H
\$8H
\$ H
AWAVI
AUATUSH
T$(I
D$PE
D9l$
D9,$
t$8L
T$(I
[]A\A]A^A_
|$@I
L$ H
T$(M
L$0I
D$PH
|$XI
T$|1
~>E1
D9t$|
\$8I
|$81
AUATI
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
t$ L
L$ H
L$(I
ATUH
[]A\
AWAVAUATUSH
=h8-
=@8-
[]A\A]A^A_
|$0I
t$ H
|$8I
T$0H
|$(L
d$ H
AWAVAUATUSH
[]A\A]A^A_
AWAV
AUATUSH
[]A\A]A^A_
AWAV
AUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
D$x1
L$xdH3
[]A\A]A^A_
|$PH
t$PL
l$XM
t$xAUAVH
D$`L
t$PL
l$XH
D$hL
D$pH
AUATA
D$81
L$8dH3
H[]A\A]
AWAVAUATUSH
D$`E
l$0H
D$01
h~GL
D$PH
D$XL
L$P9
D$4A
HcD$4
L$09
D$ f
t>E;o
9D$0
HcD$
D$( A
L$ I
\$(M
D$(L
D$ D
D$@L
L$@L
D$8H
D$@H
D$ L
L$@L
D$8H
D$ L
\$(L
t$0H
\$XD
9L4h
 D;d$0E
D9l$P
C(9C
9T$0
 D;d$0E
[]A\A]A^A_
D$PD
AWAVAUATUSH
T$PH
D$@L
D$8;
D;d$8
L$8D
\$(D
L$8L
l$ H
l$<E1
t$ E1
t$8H
|$@H
T$@L
[]A\A]A^A_
t$8H
|$HI
D$@1
t$8H
AWAVAUATUSH
T$XH
t$0H
D$4;
L$49L$H
L$HH
|$81
D$09D$
l$HD
d$4L
u8D9
\$TH
l$8f
t$4H
t$8H
|$(L
D9d$H
|$(H
t$8H
t$4H
t$8H
L$09L$
D$8H
x[]A\A]A^A_
L$HH
|$81
|$8D
|$hI
t$@H
AWAVAUATUSH
t$0E
T$8t<H
T$8H
t$0H
[]A\A]A^A_
t$,H
|$PH
u.D9d$
D$,9D$L
D$01
AUATUSH
[]A\A]
[]A\A]
AVAUI
ATUSH
]A\A]A^
]A\A]A^
AWAVI
AUAT
|$@L
T$xH
L$hdH
t$P	
T$ H
D$(1
L$(H
T$ E1
l$(I
l$(I
|$@H
[]A\A]A^A_
D$8L
|$8H
|$(L
t$H1
\$8I
T$PH
\$(H
d$PH
|$(H
|$pH
t$(H
AYAZH
|$0D
l$X1
|$pH
|$ D
|$(L
|$pH
|$8H
|$ E1
|$pH
|$X1
AWAVAUATUSH
|$8H
t$ H
D$@t
|$@H
|$@H
 t&L
|$pH
D9d$
\$ L
t$ I
|$8H
\$ H
t$HL
t$(1
t$ 1
\$(I
T$0I
[]A\A]A^A_
t$ 1
\$ L
T$ H
t$0H
|$0H
D$@H
|$H1
\$XI
|$ H
t$0H
T$0H
AWAVAUATUSH
([]A\A]A^A_
[]A\A]A^A_
AUhE
AUhO
AWAVAUATI
[]A\A]A^A_
t$ L
hVAU
t$0h
t$Hh
hVAU
t$0hP
t$ L
t$ L
|$ 1
D$HH
D$HL
L$@H
D$8I
D$8L
D$8L
|$ 1
L$@H
|$ H
L$@H
T$ H
D$ L
L$@H
D$@L
D$8I
D$8~#H
D$8H
D$8~#H
D$8~#H
T$ H
AWAVAUATUSH
[]A\A]A^A_
t$ E1
L$(I
t$ A
ATUI
[]A\
AWAVAUATUSH
D$h1
L$hdH3
x[]A\A]A^A_
AXAYE
|$@L
d$HM
t$hAT
D$@L
d$HH
D$pH
D$PL
d$xH
D$XH
D$`H
d$@M
t$hAT
D$HL
d$@H
D$xH
D$PL
d$pH
D$XH
D$`H
AWAVAUATUSH
D$h1
T$hdH3
x[]A\A]A^A_
|$@L
t$HM
t$hAV
t$hH
D$@L
t$HH
D$pH
D$PL
t$xH
D$XH
D$`H
t$hAV
t$hH
D$@L
t$HH
D$pH
D$PL
t$xH
D$XH
D$`H
AWAVAUATUSH
D$h1
T$hdH3
x[]A\A]A^A_
|$@L
t$HM
t$hAV
t$hH
D$@L
t$HH
D$pH
D$PL
t$xH
D$XH
D$`H
t$hAV
t$hH
D$@L
t$HH
D$pH
D$PL
t$xH
D$XH
D$`H
AUATI
[]A\A]
ATUI
AWAVAUATUSH
D$h1
T$hdH3
x[]A\A]A^A_
|$@L
t$HM
t$hAV
t$hH
D$@L
t$HH
D$pH
D$PL
t$xH
D$XH
D$`H
t$hAV
t$hH
D$@L
t$HH
D$pH
D$PL
t$xH
D$XH
D$`H
AVAUATUH
[]A\A]A^
AVAUATUH
[]A\A]A^
ATUH
AWAVAUATUSH
D$h1
=:y,
59x,
=o~,
=>~,
=$~,
=r},
=X},
=>},
=+},
=c},
5/},
= },
=_|,
=s|,
=_|,
=;|,
=?|,
=+|,
=G|,
=C|,
L$hdH3
x[]A\A]A^A_
=&{,
=+q,
=9z,
|$HM
t$hAW
t$hH
D$@H
T$HH
D$pH
D$PI
T$xH
D$XH
D$`H
5Qy,
5@y,
=!y,
=Yo,
=4o,
=Rw,
=Av,
=5v,
:t3I
AUATI
[]A\A]
[]A\A]
=iu,
AWAVAUATUSH
|$HH
L$PdH
|$0A
t$8E1
|$(E
d$8E
L$(A
|$HI
[]A\A]A^A_
t$(E
l$8E
|$PA
T$`H
D$hL
\$pH
l$xM
\$(H
l$xA
L$(H
t$ 1
L$(H
D$8H
D$(E
t$ H
|$XI
|$01
\$(E1
\$pH
|$XI
5*a,
AZA[
|$XI
|$01
AWAVI
AUATUSH
[]A\A]A^A_
t5f.
[]A\A]A^A_
AWAVI
AUATUSH
|$hH
|$8H
D$0E1
\$(L
t$(H
L$D~@
T$DI
=?a,
[]A\A]A^A_
=J],
D94$H
D94$H
D9l$
D$(H
l$(L
l$(E1
t$PH
D$XH
D$0H
\$0I
T$8I
=BW,
|$tH
|$`H
\$(D
\$PH
D$xH
\$ Hc
T$ H
L$0H
l$`H
=8U,
9L$ 
HcD$
l$0H
|$(H
l$0A
$9L$ 
\$(1
9D$ 
L$(1
l$XLc
l$0L
T$8H
D$`1
D9l$ 
T$8H
|$H1
\$tE
T$tE
L$ E
D$(H
t$HL
|$HL
|$hH
t$PH
t$xH
=jI,
|$ 1
5!D,
|$ 1
T$8H
D$0E1
d$0I
D$xH
=nC,
=	D,
=pC,
D=_C,
=LC,
5)B,
t$8H
t$8L
l$(L
=tA,
=Y@,
=B@,
|$P1
=[?,
d$ L
|$xH
tXI9
t$tE
d$ H
L9l$
=P=,
txf.
|$xL
T$8H
=79,
L$ 9
T$8H
t$ 1
D$0L
9\$ 
|$HL
D$ H
T$8H
d$pE
T$8H
l$pE
\$HH
L$8H
|$H1
D$ E
|$H1
|$HH
|$H1
|$hH
t$PH
t$hH
L$hH
t$PH
AWAVAUATUSH
[]A\A]A^A_
=)-,
ATUI
=f,,
[]A\
AWAVAUATI
5O+,
[]A\A]A^A_
|$pH
D$xH
D$@H
\$HH
D$PH
D$XH
D$`H
=]),
\$@1
=[(,
=Q(,
t$hUS
D$PH
\$@H
l$HH
D$XH
\$pH
l$xH
D$`H
5g',
\$@1
=U',
t$hUS
D$PH
\$@H
l$HH
D$XH
\$pH
l$xH
D$`H
|$pH
\$xH
D$@H
\$HH
D$PH
D$XH
D$`H
D$@H
\$HH
D$PH
D$XH
D$`H
\$@H
l$HH
t$hUS
D$PH
\$@H
l$HH
D$XH
\$pH
l$xH
D$`H
=D#,
=r",
=X",
=E",
=+",
=}",
=r!,
=1!,
=u ,
=H ,
=2 ,
AWAVI
AUATH
[]A\A]A^A_
AVAUATUH
[]A\A]A^
]A\A]A^
AVAUATUH
[]A\A]A^
AVAUI
ATUSH
D$X1
=y	,
=_	,
=L	,
=9	,
=&	,
\$0H
t$XSH
D$8H
\$0H
D$hH
D$@H
\$`H
D$pH
D$HH
D$xH
D$PH
L$XdH3
`[]A\A]A^
AUATH
_uBH
[]A\A]
[]A\A]
AWAVE1
AUATA
[]A\A]A^A_
AWAVAUATUSH
|$0H
t$ H
|$ H
D$TH
D$0H
D$@t
\$@H
D;d$
D9d$
t$ I
|$(H
\$ H
t$HL
t$ 1
D$0L
[]A\A]A^A_
D+D$
|$(H
t$ 1
T$ H
t$8H
D$0H
D$(H
L$@H
|$(1
|$H1
|$ H
T$lH
T$lH
l$0H
D$0H
l$8H
t$0H
D$0H
D$0H
L$0H
D$0H
AUATUSH
[]A\A]
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATI
D$X1
L$XdH3
h[]A\A]A^A_
|$0H
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
ATUI
[]A\
AUATUSH
[]A\A]
ATUH
Z[]A\
AWAVI
AUAT
|$@L
T$pH
L$`dH
t$H	
T$ H
T$ E1
|$@H
[]A\A]A^A_
t$01
d$8E
L$8E
D$(H
t$(L
|$hH
|$0H
L$(H
L$(H
D$(H
D$(H
|$0H
T$xI
l$P1
|$hH
D$@I
D$@I
|$ L
|$hH
L$(H
|$0H
|$hH
|$P1
[A^]
AUATI
[]A\A]
AWAVI
AUATUSH
8[]A\A]A^A_
[]A\A]A^A_
AUATUSH
[]A\A]
AWAVI
AUATUSH
[]A\A]A^A_
h=YS
h=YS
AXAYH
AZA[H
[]A\A]A^A_
AWAVI
AUAT
L$ D
D$,L
L$0dH
|$pL
\$xH
D$pH
\$xH
dH34%(
[]A\A]A^A_
t$,D
D$pH
\$xH
T$,E
AWAVI
AUAT
D$h1
|$@L
t$HM
t$hAV
D$@L
t$HH
D$pH
D$PL
t$xH
D$XH
D$`H
\$HH
t$hS
D$@H
\$HH
D$pH
D$PH
\$xH
D$XH
D$`H
\$hdH3
x[]A\A]A^A_
AWAVH
AUATUSH
D$81
t$(1
t$(H
<ut~H
t$0H
<$"tVL
L$0L9
L$8dH3
H[]A\A]A^A_
t$0H
<$"tJL
d$0M9
0tqM
D$(I
D$(L)
tDE1
[]A\
AWAVH
Eleele
AUATI
|$PH
D$ H
D$pH
D$0H
D$8L
|$@L
t$@E1
t$8H
|$xH
l$8I
t$ 1
t$h1
t$`1
|$XH
D$8L
|$hH
[]A\A]A^A_
|$xH
AUATA
[]A\A]
[]A\A]1
AWAVI
AUATI
L$7D
D$5H
t$8dH
L$5H
\$0H
l$@1
8D$7
|$8H
[]A\A]A^A_
L$0H
t$8E1
t$x1
l$xH
D$XM9
t$hA
<utvL
?"tLL
\$`L
L$ M
t$8E1
|$ L
?"tKL
L$0L
t$8H
t$8L
D$xM
L$HH)
L$xH)
L$PH
AWAVI
AUATA
[]A\A]A^A_
AWAVE1
AUATUSD
D$ t
D$(uz@
[]A\A]A^A_
\$ 1
t$0M
t$ H
\$pH
l$xM
l$@A
D$pL
l$xH
t$ H
\$xH
|$8H
l$@I
D$pH
\$xH
t$8L
t$0L
L$PH
t$ H
t$8I
t$8L
\$pI
t$xM
l$@A
D$pL
t$xH
t$ H
\$xH
|$0H
l$@I
D$pH
\$xH
t$81
D$(H
D$8H
t$(H
t$(L
AWAVI
AUATUSL
|$huPM
=8j+
=ui+
[]A\A]A^A_
=Qi+
=1i+
AWAVI
AUATI
T$(H
L$0dH
hbVU
|$H1
A[]L
|$(E1
|$(H
5;a+
L$@H
AYAZH
|$(E1
|$pL
\$xH
D$pH
\$xH
\$(H
[]A\A]A^A_
5,\+
L$@H
_AXH
|$(E1
t$@H
|$ A
<$E1
D$pH
\$xH
t$ A
<$Hc
t$ L
t$ M
hnIU
AWAVE
AUATI
D$81
T$4H
D$4L
L$4A
5IP+
D$8dH3
H[]A\A]A^A_
L$4H
L$4H
D$4H
|$(E1
=cM+
=EM+
AWAVAUATUSH
|$@H
5rL+
|$@I
T$ L
D8d$+
9l$,
D$`A
|$8H
9l$ H
5A<+
:D$Pv
t$@L
D$`u
l$8H
t$01
T$8H
5P<+
[]A\A]A^A_
self
D$@D
|$@D
|$hL
9l$,
|$0L
L$@H
5|5+
5)4+
|$H1
5@3+
5(3+
D$`H
T$hE1
D$@H
=>0+
D$@H
D$@H
AZA[
|$81
L$@H
AYAZE
t$01
D$ P
D$4PD
L$pH
L$`D
|$PA
=v"+
=O"+
AXAY
L$P8
|$81
L$P8
|$81
ATUH
[]A\
[]A\
[]A\
AVAUI
ATUI
]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
t$ E1
L$(I
t$ A
ATUH
[]A\
ATUI
[]A\
AWAVAUATUSH
D$x1
L$xdH3
[]A\A]A^A_
|$PL
|$XM
t$xAW
t$xH
D$PL
|$XH
D$`L
D$hH
D$pH
t$xAW
t$xH
D$PL
|$XH
D$`L
D$hH
D$pH
|$PL
D$XH
h QU
PhOPU
AYAZ
A[A_
AWAVAUATI
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
hbVU
hbVU
h=YS
h QU
h8RU
AUATI
[]A\A]
[]A\A]
[]A\A]
AWAV1
AUAT
[]A\A]A^A_
D$ 1
T$ H
T$ H
L$ H
UhX!T
AUhX!T
AWAVAUATI
[]A\A]A^A_
AVhX!T
AWhX!T
AWAVAUATUSH
[]A\A]A^A_
PhX!T
h=YS
hbVU
_AXH
A^A_
A\A]
AWAVAUATUSH
[]A\A]A^A_
hbVU
hbVU
Y^E1
ATUI
[]A\
[]A\
AWAVAUATUSH
[]A\A]A^A_
Lcl$
AUATUSH
[]A\A]
[]A\A]
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
Lc|$
Lc|$
AVAUATI
]A\A]A^
heVU
hwVU
h#RU
heVU
h!WU
hPWU
h QU
h QU
h#RU
hLVU
AWAVI
AUATI
XZt0;\$
[]A\A]A^A_
ATUI
[]A\
[]A\
AUATUSH
[]A\A]
AUATA
[]A\A]
[]A\A]
AWAVI
AUATUSH
|$0H
t$8H
h[]A\A]A^A_
|$8H
t$ H
|$(H
D$@t
D$@A
L$@H
D$0H
\$0H
T$(H
t$0H
t$`AV
|$8H
T$8H
t$ H
t$(L
D$0H
D$0H
AUATI
[]A\A]
[]A\A]
AWAVAUATUSH
~hf.
[]A\A]A^A_
AWAVH
AUATUSH
[]A\A]A^A_
t$ I
|$0H
T$8H
L$0H
D$(N
|$(H
9\$0
AWAVAUATUSH
t)D9t$
D9t$
([]A\A]A^A_
ATUH
[]A\
AWAVH
AUATI
[]A\A]A^A_
[]A\A]A^A_
u-[]A\A]A^
]A\A]A^H
AWAVAUATUSH
D$`E
d$0H
D$01
h~>H
D$PH
D$XL
L$P9
D$4A
HcD$4
L$09
D$ f
tFE;o
9D$0
HcD$
D$( A
\$ I
|$(H
D$(H
D$ D
D$@L
L$@L
D$8H
D$@H
D$ L
L$@L
D$8H
D$ L
\$(H
t$0I
l$PH
\$XH
[]A\A]A^A_
AWAVAUATUSH
T$ 1
L$0H
T$ 1
9D$4
\$8L
[]A\A]A^A_
T$ 1
AVAUATUI
[]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AUATI
[]A\A]
AWAVI
AUATI
]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
t$(H
|$pH
=aw*
t$hL
[]A\A]A^A_
t$PL
\$(H
\$xH
T$pE1
|$(L
t$0H
|$8H
hq{S
h8KT
|$X1
L$$9L$D
D$x1
|$(L
t$(H
L$xH
D$xH
t$`L
\$x1
|$PI
t$(1
D$XA
A\A^H
L$PA
T$xH
T$DH
t$`H
=kf*
L$PH
T$01
|$(H
=_X*
L$PH
T$0I
L$hH
=aW*
t$(H
D$xH
t$(1
|$h1
5)[*
D$xH
ATUH
AWAVAUATUSH
([]A\A]A^A_
AVAUATUH
]A\A]A^
]A\A]A^
AWAVAUATI
[]A\A]A^A_
=_W*
AUATUSH
=XV*
[]A\A]
=<H*
AUATUSH
=1U*
]A\A]
=YG*
ATUH
=)F*
[]A\
[A^]
=yC*
AWAVI
AUAT
|$@L
L$PH
T$pdH
t$(	
|$@H
[]A\A]A^A_
D$XH
|$`D
t$ 1
l$(H
D$(H
L$(I
\$@L
D$8~J
t$hH
|$ 1
|$XH
T$xI
t$@L
t$hH
l$01
L$XH
T$8E
|$hH
|$`H
|$hH
t$`L
5J6*
|$ H
|$ L
|$ H
|$ H
|$XH
L$(H
\$8E
l$`M
|$hI
|$hH
|$01
D$pH
D$pH
D$pH
l$p1
|$ H
AWAVE1
AUATA
5+/*
[]A\A]A^A_
AWAVI
AUATUSH
T$;H
\$(1
|$0H
H[]A\A]A^A_
AWAVI
AUATUSH
|$HL
D$ H
|$PH
T$PH
t$ H
D$(I
D$(H
|$pD
L$(H
L$(H
\$HH
T$@H
T$?H
|$ L
T$(H
D$XL
\$0H
T$(H
t$PH
t$(L
T$?L
	vIH
|$ I
\$x1
|$ H
|$0L
|$XL
|$ H
[]A\A]A^A_
T$PH
T$@H
D$ H
|$0L
T$PH
T$@H
[]A\A]A^A_
AWAVAUATI
L$`A
[]A\A]A^A_
|$(1
5w	*
L$`A
|$(1
T$ I
AWAVAUATI
D$h1
|$@L
|$HM
t$hAW
t$hH
D$@L
T$HH
D$pH
D$PM
T$xH
D$XH
D$`H
D$hdH3
x[]A\A]A^A_
AWAVI
AUAT
t$(dH
|$@H
|$(I
d$(I
L$ L
t$8I
[]A\A]A^A_
AWAVAUATI
D$xH
D$pt
D$|H
T$pE1
L$LI
|$(H
D9l$ 
|$@H
D9l$ 
D9l$L
l$LD+
[]A\A]A^A_
|$X1
t$PL
t$h1
t$`1
T$8I
t$`1
T$8L
t$8H
T$pL
L$@E1
\$PH
\$pI
D$ H
T$8H
|$P1
AUATI
[]A\A]
AWAVAUATUSH
[]A\A]A^A_
t$(L
L$ I
ATUH
[]A\
AWAVAUATUSH
D$h1
AXAY
|$@L
d$HM
t$hAT
D$@L
d$HH
D$pH
D$PL
d$xH
D$XH
D$`H
|$@H
|$HM
t$hAW
D$@L
T$HH
D$pH
D$PM
T$xH
D$XH
D$`H
t$hAW
D$@L
T$HH
D$pH
D$PM
T$xH
D$XH
D$`H
t$hAW
D$@L
T$HH
D$pH
D$PM
T$xH
D$XH
D$`H
L$hdH3
x[]A\A]A^A_
p E1
AWAVAUATI
[]A\A]A^A_
AUATUSH
[]A\A]
AWAVI
AUATH
|$@L
D$8H
|$HA
d$PD
l$XA
t$0f
t$8H
[]A\A]A^A_
d$PD
l$XL
	vGH
L$ H
T$0H
|$0L
AVAUATUH
[]A\A]A^
AWAVI
AUATI
[]A\A]A^A_
|$ H
T$ H
|$0A
d$8L
d$8L
l$(L
l$(A
	vGH
L$(H
T$0H
tJE1
|$(L
AWAVI
AUATI
[]A\A]A^A_
|$ H
T$ H
|$0A
d$8L
d$8L
l$(L
l$(A
	vGH
L$(H
T$0H
tJE1
|$(L
AVAUATUH
[]A\A]A^
AVAUATUH
[]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUATI
D$X1
|$0L
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
D$XdH3
[]A\A]A^A_
AWAVAUATUSH
t$ H
[]A\A]A^A_
D$PE1
d$ L
l$(H
d$ L
l$(tFH
D$PH
|$0I
T$0H
|$@D
|$@D
	vKH
L$(H
T$8H
tBE1
T$0H
t$ 1
ATUH
AWAVAUATI
D$X1
|$0L
l$0H
t$XUH
D$8H
l$0H
D$hH
D$@H
l$`H
D$pH
D$HH
D$xH
D$PH
D9cl
=i~)
D9cX
=)~)
D9cl
D9cX
={})
=5})
D9cl
D9cX
=Y|)
D9cl
=<|)
~'E1
=	|)
D9cX
=y{)
D9cl
=M{)
=){)
D9cX
D$XdH3
h[]A\A]A^A_
=uz)
=5z)
AWAVAUATI
=yy)
=Oy)
=)y)
|$pA
[]A\A]A^A_
=5x)
=ow)
=Iw)
t$pH
=wv)
=Yv)
=6v)
|$@L
l$@H
t$hU
D$HH
l$@H
D$xH
D$PH
l$pH
D$XH
D$`H
D9{l
=Ut)
=1t)
D9{X
D9kl
D9kX
=;s)
=yr)
D9cX
=9r)
D9cl
~'E1
D9cX
=Yq)
D9cl
=-q)
=	q)
D9cX
=up)
=Ep)
D9cl
=ho)
|$@L
l$@H
t$hU
D$HH
l$@H
D$xH
D$PH
l$pH
D$XH
D$`H
D9kl
D9kX
=Im)
D9kl
D9kX
=Xl)
=9l)
=Mk)
AWAVAUATI
|$pA
={j)
[]A\A]A^A_
=5j)
=)i)
=wh)
=Yh)
|$pA
t$pH
=ag)
=>g)
|$@L
l$@H
t$hU
D$HH
l$@H
D$xH
D$PH
l$pH
D$XH
D$`H
D9{l
=ue)
=Qe)
D9{X
=	e)
D9cl
D9cX
=[d)
t$pH
~%f.
=fc)
|$@L
l$@H
t$hUH
D$HH
l$@H
D$xH
D$PH
l$pH
D$XH
D$`H
D9cl
D9cX
=k`)
="`)
=e_)
=1_)
=i^)
|$pA
t$pH
~%f.
=i])
=F])
|$@L
l$@H
t$hU
D$HH
l$@H
D$xH
D$PH
l$pH
D$XH
D$`H
D9{l
=}[)
=Y[)
D9{X
D9cl
D9cX
=kZ)
|$pA
t$pH
~%f.
=YY)
=/Y)
=GX)
=aW)
=7W)
=OV)
=3V)
=	V)
=jU)
=>U)
=yT)
=IT)
AWAVAUATUSH
~%f.
=fS)
=WR)
=9R)
|$pA
=uQ)
t$pH
=AP)
|$@L
l$@H
t$hUH
D$HH
l$@H
D$xH
D$PH
l$pH
D$XH
D$`H
=!N)
D9{l
D9{X
D9sl
=]M)
=9M)
D9sX
=zL)
~"E1
=YL)
D9cX
D9cl
~'E1
D9cX
=iK)
=9K)
D9cl
D9cX
[]A\A]A^A_
D9cl
=9I)
=	I)
|$@L
l$@H
t$hUH
D$HH
l$@H
D$xH
D$PH
l$pH
D$XH
D$`H
D9sl
D9sX
D9sl
=]F)
=9F)
D9sX
=mE)
=4E)
AWAVAUATI
D$X1
=dD)
=	D)
=WC)
=9C)
|$0L
l$0H
t$XUH
D$8H
l$0H
D$hH
D$@H
l$`H
D$pH
D$HH
D$xH
D$PH
=iA)
D9cl
==A)
D9cX
D9cl
D9cX
=+@)
D9cl
=m?)
=I?)
D9cX
=	?)
D9cl
~'E1
D9cX
=Y>)
=)>)
D9cl
D9cX
=I=)
~%f.
L$XdH3
h[]A\A]A^A_
=m<)
=t;)
=Y;)
AWAVAUATUSH
5 2)
551)
gfffH
[]A\A]A^A_
AWAVI
AUATUSH
5n-)
gfffI
[]A\A]A^A_
gfffI
AWAVAUATUSH
t$ H
D$X1
T$(I
|$ L
9D$HI
D9t$
5(%)
|$ H
t$8H
T$HH
5y!)
L$XdH3
h[]A\A]A^A_
T$ H
gfff
L$0H
T$T1
D9|$T
|$81
t$01
gfff
L$0H
t$01
AVAUI
ATUSH
[]A\A]A^
AUATUSH
[]A\A]
AWAVI
AUAT
gfffL
gfffH
gfffH
[]A\A]A^A_
AWAVA
AUATUSH
u8Ic
([]A\A]A^A_
([]A\A]A^A_
AUATUSH
[]A\A]
AWAVI
AUATUSH
l$0H
;l$,
|$ H
D;l$`D
D$dH
t$ E
l$`H
=F	)
;l$,
|$@L
\$ H
t$@1
t$0L
\$0H
t$XL
t$H1
t$81
t$01
\$8I
T$PI
[]A\A]A^A_
l$@D
t$01
|$81
T$0H
t$PH
|$PI
\$PH
|$X1
\$ H
t$@1
l$0H
|$PH
t$PH
AWAVAUATI
([]A\A]A^A_
[]A\A]A^A_
AXAY
AWAVAUATI
[]A\A]A^A_
AWAVAUATUSH
D$h1
L$hdH3
x[]A\A]A^A_
|$@H
t$hU
t$hH
D$@H
l$HH
D$pH
D$PH
l$xH
D$XH
D$`H
AXAYL
t$hU
t$hH
T$@H
D$@H
l$HL
D$pH
D$PH
l$xH
D$XH
D$`H
hWAU
AWAVAUATI
[]A\A]A^A_
AXAY
ATUH
hB{S
AWAVAUATI
[]A\A]A^A_
D$(A
AZA[
ATUH
AUATUSH
D$`x
D$xH
|$`H
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
[]A\A]
[]A\
AWAVAUATUSH
C@t*
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
t?f.
AVAUI
ATUSH
]A\A]A^
]A\A]A^
AWAVH
AUATI
[]A\A]A^A_
AUATUSH
D$X1
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
h[]A\A]
ATUH
ATUSH
AUATUSH
|$@H
|$@H
[]A\A]
ATUSH
AVAUATI
]A\A]A^
AWAVAUATUSH
[]A\A]A^A_
AWAVI
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
D$@L
L$8D
UAWH
L$HL
D$PH
t$(H
D9t$0
|$(D
t$PH
D$XL
|$HH
T$PH
L$`H
D$XH
L$XH
t$H1
D9t$0
x[]A\A]A^A_
L$hL
D$`H
T$HH
\$ H
t$8H
|$`H
|$0D
t$PH
t$PH
D9t$H
T$(D
|$`H
t$@H
T$PI
T$PI
T$PH
T$PI
T$PH
|$(H
T$PI
|$(H
D$XH
D$XH
|$XH
x[]A\A]A^A_
AWAVAUATSH
_AXj
[A\A]A^A_]
AWAVAUATI
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
[]A\A]
[]A\A]
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
tVHc
[]A\A]A^A_
AVAUI
]A\A]A^
[]A\
[]A\
tCUSH
AVAU
ATUI
[]A\A]A^
]A\A]A^
ATUI
[]A\
=#x(
ATUI
[]A\
D$h1
$x)V
T$X1
9\$X
D$X1
9\$X
$x)V
D$hdH3
9\$X
=~u(
$x)V
AWAVI
AUATUS1
GX~"
|$0L
d$0M
t$XATH
D$8L
d$0H
D$hH
D$@L
d$`H
D$pH
D$HH
D$xH
D$PH
CX~&1
[]A\A]A^A_
|$`L
|$`L
l$hM
AUAWH
D$@L
|$0L
l$8H
D$HL
D$PH
CX~&1
|$`L
l$hM
=I~(
D$0L
l$8H
D$@L
D$HH
D$PH
=q|(
=R|(
|$`L
|$`L
l$hM
=n{(
AUAWH
D$@L
|$0L
l$8H
D$HL
D$PH
CX~&1
=yz(
=Zz(
|$`L
|$`L
l$hM
=~y(
AUAWH
D$@L
|$0L
l$8H
D$HL
D$PH
CX~&1
=qx(
=Rx(
~%f.
=	x(
CX~!f
=Yw(
=>w(
=zu(
=9u(
CX~!f
=nt(
AWAVAUATUSH
=vs(
=2s(
=yr(
=Er(
=aq(
SXE1
=9q(
D9kX
CXE1
D9kX
=_p(
~%f.
=Co(
[]A\A]A^A_
CXE1
=Yn(
D9kX
=<n(
=)n(
=[m(
=@m(
=-m(
ATUH
=yl(
=El(
=Yk(
=>k(
=+k(
AUATA
\t/L
[]A\A]
[]A\A]
[]A\
[]A\
AWAVAUATUSH
(t0H
[]A\A]A^A_
"tFA
)tHH
[]A\A]A^A_
=dg(
==g(
=#g(
=ub(
=ab(
=Mb(
=9b(
=%b(
=Ma(
=9a(
=%a(
=%a(
=!a(
=va(
=ja(
=6a(
AUATI
.t@L
[]A\A]
[]A\A]
AWAVAUATUSH
=r`(
5,\(
t$ L
5p[(
56[(
[]A\A]A^A_
[]A\A]A^A_
<*tq
D$(A
L$(H
==W(
AWAV
AUAT
=ZV(
 t=L
t$DH
\$ L
T$@H
[]A\A]A^A_
|$0L
$u/H
|$PI
5KR(
T$@E
|$0H
t$PL
t$`L
t$|L
t$|H
T$@H
\$@L
L$pH
L$`1
AXAYt
|$|H
5_P(
-JQ(
T$@H
|$(L
\$ L
T$@H
|$(H
 t'L
d$(1
5dL(
t$DH
t$DH
T$@H
|$(H
}t!L
T$@H
|$(H
\$ H
T$@H
\$ H
T$@H
5[G(
HcT$
D$@H
|$XL
El$@
\$0H
T$@H
|$(H
%t5L
D$`A
t$DH
t$DH
HcT$
|$@H
|$XL
Dd$@
L$HD
5 C(
T$H9T$
DD$L
T$@H
|$(H
L$H9L$
\$0H
5y?(
\$ L
T$@H
|$(H
%t5L
d$`M
t$PI
t$PI
d$hD
D$hA
HcT$
\$@H
t$xH
T$xE
D$H9
t$xH
ED$L
L$`H
|$PH
T$`u
|$(H
D$8H
|$(H
5	7(
t$|L
t$|H
|$(H
T$@H
T$@H
|$(H
|$(H
 t\H
\$@E
AWAVAUATUSH
[]A\A]A^A_
5d1(
d$8H
\$0A
|$0D
T$ L
D9d$P
D9d$,
5u-(
50-(
D$ L
d$ L
t$(A
h[]A\A]A^A_
5=+(
=.+(
t$@H
HcD$HH
D$HH
D$HH
|$WH
D$HH
t$@H
H;L$ r
AWAVAUATUSH
=+*(
5s)(
$t~A
$t`H
[]A\A]A^A_
D9t$
=y%(
=W&(
=,#(
5@"(
L9|$
AUATI
[]A\A]
AUATI
[]A\A]
upHcN
AVAUI
ATUI
(u_M
]A\A]A^
]A\A]A^
]A\A]A^
ATUA
[]A\1
[]A\
ATUA
[]A\1
[]A\
AWAVI
AUATI
[]A\A]A^A_
ATUA
[]A\
[]A\
[]A\
AWAVE1
AUATI
T$(H
L$8I
t$ H
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAV1
AUATI
teAVAWH
[]A\A]A^A_
D$ 1
T$ L
AWAV1
AUATI
[]A\A]A^A_
AUATI
[]A\A]
[]A\A]
AWAVM
AUATI
[]A\A]A^A_
AWAVI
AUAT
D$0D
|$ H
D$0H
[]A\A]A^A_
L$0t
D$0H
T$ H
t$0L
L$8M
|$0H
D$0H
D$0H
\$0M
D$0H
|$ L
T$ H
L$XM
T$ H
t$(H
D$8L
D$8H
|$ H
ATUH
D$X1
L$XdH3
`[]A\
|$0H
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
AWAVAUATUSH
L$ L
D$(D
[]A\A]A^A_
|$ I
|$x1
T$(L
AWAVE
AUATA
[]A\A]A^A_
AWAVAUATA
|$ I
t$ 1
[]A\A]A^A_
AWAV
AUAT
[]A\A]A^A_
@t1L
AWAV
AUAT
[]A\A]A^A_
AWAVA
AUATA
[]A\A]A^A_
ATUSH
[]A\
AWAVAUATI
[]A\A]A^A_
AWAVI
AUATA
D$X1
D$ H
D$`H
\$0D
<+tHH
D$XdH3
[]A\A]A^A_
ATUI
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
D$ H
[]A\
AUATUSH
[]A\A]
[]A\A]
ATUI
L$8L
D$@L
L$Ht7
)D$P
)L$`
)T$p
D$ H
[]A\
AWAVAUATI
([]A\A]A^A_
T$$M
L$ H
L$(H
AUATUI
t3[L
]A\A]A^
[]A\A]A^
AVAUATUSH
D$X1
\$0H
|$8H
t$XATSH
D$@H
\$0H
|$8H
D$pH
D$HH
\$`H
|$hI
D$xH
D$PH
D$XdH3
`[]A\A]A^
AWAV
AUATI
([]A\A]A^A_
[]A\A]A^A_H
([]A\A]A^A_
AVAU
ATUSH
[]A\A]A^
]A\A]A^
S~RH
ATUS
u;[]A\
AVAUA
ATUS
]A\A]A^
AWAVA
AUATUS
([]A\A]A^A_
t>SH
ATUSH
[]A\
;/tLH
ATUH
[]A\
Hc|$
ATUH
Hc|$
[]A\
ATUSH
[]A\
Hc|$
ATUH
Hc|$
Hc|$
[]A\
AUATA
Hc|$
[]A\A]
Hc|$
ATUSH
[]A\
AWAVAUATI
[]A\A]A^A_
ATUH
[]A\
ATUI
[]A\
ATUSH
t"[]A\
[]A\
AVAUI
]A\A]A^
[]A\A]A^
t3USH
ATUI
[]A\
[]A\
ATUI
D$X1
|$0H
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
D$XdH3
[]A\1
L$XdH3
`[]A\
L$XdH3
[]A\
D$XdH3
[]A\
/tP1
AWAVAUATUSH
 tpH
[]A\A]A^A_
H;\$
AVAUATUI
tTI9
[]A\A]A^
[]A\A]A^
<:tE<<tY
[]A\A]A^
<:t'<<t;
tzH)
<:t"<<t6
<<t,
<<t/
AWAVA
AUATI
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUATA
|$ H
T$(L
D$81
D$$f.
0D;d$ 
L$4A
\$8dH3
H[]A\A]A^A_
0wvE
L$4A
t$,L
L$4A
AWAVI
AUATUSH
T$(L
XZxmL
[]A\A]A^A_
t[US1
ATUI
Degas are we not drawn onward no In union drawn onward to new eras aged
|$0dH
D$X1
\$0H
t$XSH
D$8H
\$0H
D$hH
D$@H
\$`H
D$pH
D$HH
D$xH
D$PH
D$XdH3
`[]A\
AWAVAUATUSH
?%tGE
[]A\A]A^A_
[]A\A]A^A_
AWAVI
AUAT
|$`L
\$`H
l$hH
D$pH
\$`H
l$hH
D$xH
D$hH
L$`H
D$pI
D$xH
D$ H
|$`H
\$`H
l$hH
D$pH
\$`H
l$hH
D$xH
|$ H
[]A\A]A^A_
|$ H
AWAVAUATUSH
[]A\A]A^A_
([]A\A]A^A_
ATUI
[]A\
ATUSH
[]A\
AVAUI
ATUH
]A\A]A^
ATUI
[]A\
ATUI
[]A\
AUATI
[]A\A]
AUATI
[]A\A]
AUATI
[]A\A]
AUATI
[]A\A]
AVAUI
ATUI
]A\A]A^
[]A\A]A^
AWAVI
AUATI
D$(1
L$(dH3
8[]A\A]A^A_
T$ H
t$ L
|$ H
AWAVAUATUSH
D$81
D$8dH3
H[]A\A]A^A_
T$0H
t$(H
|$0H
D$(H
AWAVI
AUATI
([]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATI
[]A\A]A^A_
AVAUI
ATUH
XZt+E
dH34%(
 []A\A]A^
AWAVAUATUSH
D"d$
D9t$
([]A\A]A^A_
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
T$ I
D$ H
[]A\A]A^A_
D$ H
AUATI
D$H1
D$ >IV
D$(GIV
D$04IV
D$HdH3
X[]A\A]
AVAUATUSH
[]A\A]A^
[]A\A]A^
]A\A]A^
AWAVI
AUATI
D$H1
D$ 4IV
D$(hIV
D$0QIV
D$HdH3
X[]A\A]A^A_
AWAVM
AUATI
D$81
$teL
L$8dH3
H[]A\A]A^A_
T$0H
t$(H
|$0H
|$(H
\$(L
ATUSH
D$X1
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
D$XdH3
[]A\
D$XdH3
`[]A\
AWAVI
AUATUSH
[]A\A]A^A_
ATUI
 []A\
ATUSH
[]A\
[]A\
ATUSH
[]A\
[]A\
ATUI
[]A\
AVAUI
ATUSH
D$X1
|$0L
\$0H
l$8H
t$XUSH
D$@H
\$0H
l$8H
D$pH
D$HH
\$`H
l$hH
D$xH
D$PH
L$XdH3
`[]A\A]A^
AVAUATA
USttH
[]A\A]A^
ATUStUH
 t:H
[]A\
ATUSH
[]A\
AUATUSH
[]A\A]
ATUSH
[]A\
[]A\
ATUSH
[]A\
t?SH
AUATA
[]A\A]
AVAUE1
ATUI
[]A\A]A^
StJH
StfH
ATUSte
[]A\
[]A\
ATUI
k([]A\
AVAUATUSH
[]A\A]A^
4BfA
_trH
537'
=47'
<LtR<U
5\)'
=])'
<Ftk<L
`t-H
\t-H
(t!H
"t"H
5r!'
=s!'
5L!'
=M!'
AWAVA
AUATUSH
([]A\A]A^A_
</tq<*tL
AUATI
D$DH
[]A\A]
\$(H
[]A\A]
=bH'
\$(H
[]A\A]
AWAVA
AUATA
t-</
[]A\A]A^A_
<'tm<\u
<"t!<\u
<*t$H
=^D'
ATUH
[]A\
[]A\
:.td
t{USH
AUATUS1
D$X1
|$0L
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
h[]A\A]
AWAVAUATUSH
D$X1
|$0L
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
h[]A\A]A^A_
AWAVAUATUSH
D9d$
D9|$
D;|$
D9d$
[]A\A]A^A_
~Nf.
AWAVI
AUATUSH
[]A\A]A^A_
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
D9|$
D;|$$
[]A\A]A^A_
ED$H
|$8H
ATUI
[]A\
[]A\
AWAVI
AUATUSH
|$ H
|$ H
|$ H
]A\A]A^A_
l$(H
t$ L
8[]A\A]A^A_
8[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
AUATI
[]A\A]
AUATI
%!#'
|$0dH
l$0H
|$`H
\$`H
D$8H
\$0H
D$@H
D$HH
D$PH
t$XUH
D$8H
l$0H
D$hH
D$@H
l$`H
D$pH
D$HH
D$xH
D$PH
[]A\A]
=( '
t6SH
ATUH
[]A\
[]A\
AUATI
tlL;%
[]A\A]
[]A\A]
[]A\A]H
AVAU
ATUH
[]A\A]A^
]A\A]A^
AUATI
USE1
[]A\A]
AWAVI
AUATUSH
D9t$(
D9t$(
[]A\A]A^A_
t$8H
\$ D
t$,M
\$ D
AWAVI
AUATUSH
[]A\A]A^A_
AWAVI
AUATI
t$ H
D$ H
D$(H
8[]A\A]A^A_
AWAVAUATUSH
|$8H
D9|$
\$8H
[]A\A]A^A_
|$0H
\$ L
AWAVI
AUAT
[]A\A]A^A_
ATUI
[]A\
[]A\
AWAVAUATUSH
D$(1
L$(dH3
8[]A\A]A^A_
T$ H
AVAUI
]A\A]A^
[]A\A]A^
AUATI
[]A\A]
[]A\A]
ATUH
]A\A]A^
[]A\A]A^
]A\A]A^
AVAUI
]A\A]A^
[]A\A]A^
AWAVI
AUATI
D$(1
D$(dH3
[]A\A]A^A_
L;<$
L$(dH3
8[]A\A]A^A_
AWAVI
AUATUSH
|$`H
D$`H
\$hH
D$pH
D$xH
[]A\A]A^A_
AVAUI
ATUSH
[]A\A]A^
]A\A]A^
[]A\A]A^
[]A\A]A^
AWAVAUATI
[]A\A]A^A_
twI9
AUATUSH
[]A\A]A^
]A\A]A^
t)SH
AUATA
D$X1
|$0H
\$0H
t$XSH
D$8H
\$0H
D$hH
D$@H
\$`H
D$pH
D$HH
D$xH
D$PH
D$XdH3
h[]A\A]
D$XdH3
[]A\A]1
ATUH
[]A\
t|ATUH
[]A\
[]A\
[]A\
AUAT
[]A\A]
[]A\A]
AUATI
D$X1
|$0L
\$0H
l$8H
t$XUSH
D$@H
\$0H
l$8H
D$pH
D$HH
\$`H
l$hH
D$xH
D$PH
L$XdH3
h[]A\A]
AUATI
T$0H
L$8L
D$@H
D$ L
X[]A\A]
AUATI
T$0H
L$8L
D$@H
D$ L
X[]A\A]
AWAV
AUATUSH
D$h1
|$@H
L$@H
\$HH
t$hSAV
D$PH
L$@H
\$HH
D$XI
L$pH
\$xH
D$`H
\$HH
D$@H
t$hSAV
T$PH
D$@H
\$HH
T$XI
D$pH
\$xH
T$`H
D$hdH3
[]A\A]A^A_
ATUH
[]A\
[]A\
AUATUSH
[]A\A]
ATUS
t%<(t!<.u
[]A\
)t+H
u3H)
AWAVAUATUSH
[]A\A]A^A_
ATUI
[]A\
ATUH
[]A\
AWAVI
AUATA
[]A\A]A^A_
AUAT
[]A\A]
AWAVE1
AUATI
D$X1
|$0H
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
L$XdH3
h[]A\A]A^A_
ATUI
[]A\
8)u5
ATUS
.uEH
)tqA
[]A\
[]A\
AUATUSH
D$X1
L$XdH3
[]A\A]
|$0L
\$8H
L$XdH3
h[]A\A]
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
AUATUSH
D$X1
L$XdH3
[]A\A]
L$XdH3
h[]A\A]
|$0L
\$8H
t$XS
t$XH
D$0H
\$8H
D$`H
D$@H
\$hH
D$pH
D$HH
D$xH
D$PH
ATU1
[]A\
AVAUATUSH
]A\A]A^
AWAVAUATUSH
D$(1
d$ L
D$(dH3
8[]A\A]A^A_
t$ L
|$ H
|$ I
tLATI
[]A\
AWAVI
AUATA
[]A\A]A^A_
D$`H
D$`H
D$`H
AWAVAUATI
D$81
t$ H
D$(H
|$0f
A[]t
AYAZt
_AXt
|$ L
d$01
|$(M
L$8dH3
H[]A\A]A^A_
AWAVAUATUSH
<$E1
([]A\A]A^A_
tdUSH
AWAVI
AUATI
L$0dH
D$ H
t$ A
D$@E
D9l$
D$@H
name
size
T$8H
name
type
ltyp
mang
descript
basetypeH
basemangH
lextype
T$0H
[]A\A]A^A_
basetype
basemang
mangH
=iq&
AWAVAUATI
([]A\A]A^A_
AWAVI
AUATI
[]A\A]A^A_
AWAVI
AUATUS
[]A\A]A^A_
AVAUATUSH
]A\A]A^
[]A\A]A^
AWAVAUATI
|$xH
|$xL
D$xL
|$pH
[]A\A]A^A_
|$xL
D$8H
L$ M
T$0L
t$xL
|$xL
D$ H
AWAVAUATI
tZf.
|$@L
t$@M
t$hAVH
D$HL
t$@H
D$xH
D$PL
t$pH
D$XH
D$`H
|$HH
|$pL
T$pH
D$HH
T$@H
D$PI
D$XH
D$`H
[]A\A]A^A_
AWAVAUATUSH
|$0H
|$0H
[]A\A]A^A_
T$|H
\$xI
D$ H
D$(H
L$PH
D9t$xH
t$ L
|$HH
|$PL
t$ M
|$HM
\$8H
T$hL
\$PL
\$PL
T$`H
D$(H
|$ 1
AZA[u
T$(H
|$@L
T$0H
t$@L
\$PD
|$8H
AXAYH
D$xH
D$`H
|$8H
T$hH
\$`H
t$hH
\$8L
L$LL
D$ H
T$(H
D$`H
AWAVAUATUSH
t$0H
T$8H
L$(f
(tbA
t$(H
\$0I
\$ H
T$8L
[]A\A]A^A_
=YS&
d$pM
T$xL
D$xL
d$pH
|$ L
AWAVI
AUATI
|$0H
D$HH
t$ H
|$0L
t$(H
|$ H
L$8L
D$0H
[]A\A]A^A_
D$Xt
D$X@
D$(H
l$ H
l$`t
D$`H
D$8H
L$0H
T$pH
t$hH
AXAY~lE
l$PL
t$(H
|$PH
L$H1
Y^t#L
t$PH
T$PH
t$XM
t$8L
L$0H
T$pM
t$@L
|$PM
D$@H
d$HM
d$PL
D$hH
t$XH
D$(H
D$hA
AUATUSH
[]A\A]
=UE&
=rt&
=1E&
AWAVAUATI
[]A\A]A^A_
~\E1
= s&
=5s&
=or&
[]A\
AUATI
tlL9%
[]A\A]
[]A\A]
=*p&
=zo&
AUATI
=Oo&
L;%2o&
[]A\A]
[]A\A]
-Vn&
=Jm&
AUAT
=7=&
d$0H
l$8M
=l<&
D$0H
\$8H
D$@H
D$HH
D$PH
|$`L
\$`H
L$hH
D$8H
\$0H
D$@H
D$HH
D$PH
t$XUATH
D$@L
d$0H
l$8H
D$pH
D$HL
d$`H
l$hH
D$xH
D$PH
[]A\A]1
AWAVAUATI
= j&
[]A\A]A^A_
[]A\A]A^A_
AWAVE1
AUATI
=Vh&
=Bh&
[]A\A]A^A_
D9<$tfD
ATUH
=mf&
AWAVAUATUSH
D$81
L$8dH3
H[]A\A]A^A_
%me&
-^e&
|$(H
|$0H
=td&
D9d$
T$(H
t$0L
|$0H
|$(A
D9l$
~0E1
D9,$
t$0L
=q]&
=@]&
AWAVAUATUSH
[]A\A]A^A_
AWAVAUATUSH
[]A\A]A^A_
=>Y&
D$ 9D$$
t$ H
5qW&
l$HM
l$HH
AVAUATUA
=TQ&
]A\A]A^
]A\A]A^
AVAUI
ATUE1
]A\A]A^
=FH&
AVAUATI
=EG&
=JF&
=AE&
[]A\A]A^
AVAUI
ATUI
[]A\A]A^
=AC&
|$0H
t$XAUH
D$8L
l$0H
D$hH
D$@L
l$`H
D$pH
D$HH
D$xH
D$PH
|$`H
l$`H
D$8H
l$0H
D$@H
D$HH
D$PH
AWAVI
AUATUSH
=AA&
[]A\A]A^A_
AVAUATUSH
[]A\A]A^
AWAVAUATUSH
l$ H
t$(H
t$0H
[]A\A]A^A_
|$(L
T$HI
l$8H
|$0H
d$@L
t$HM
=H9&
t$ H
d$@L
t$HH
t$0H
|$8H
T$0I
T$@H
AWAVAUATUSH
|$`H
|$(E1
D$ L
|$@L
=\5&
=F5&
|$8I
|$8H
D$0H
|$(H
=T2&
=g1&
l$ H
t$hE
|$PH
t$pH
|$XH
[]A\A]A^A_
|$XL
|$(L
|$@L
|$HL
=*,&
AWAVE1
AUATI
HcT$
[]A\A]A^A_1
8#t%
D9t$
AWAVE1
AUATUSH
[]A\A]A^A_1
"tAH
/t~1
*tTL
\toA
ATUH
[]A\
[]A\
ATUI
ATUI
T$0H
L$8dH
D$@L
T$0H
D$ H
P[]A\
AVAUI
ATUH
[]A\A]A^
ATUI
T$0H
L$8dH
D$@L
T$0H
D$ H
P[]A\
AWAVA
AUATL
[]A\A]A^A_
Syntax error. Extraneous '}'
Empty character constant
/*@SWIG
Illegal token '%s'.
wchar_t
unsigned
bool
__int8
__int16
__int32
__int64
private
friend
decltype
static_assert
operator 
delete
new[]
delete[]
and_eq
bitand
bitor
compl
not_eq
xor_eq
catch
explicit
auto
using
final
restrict
union
sizeof
volatile
%module
%insert
%name
%rename
%namewarn
%includefile
%beginfile
%endoffile
%val
%out
%constant
%typedef
%native
%pragma
%extend
%fragment
%inline
%typemap
%feature
%except
%importfile
%echo
%apply
%clear
%types
%parms
%varargs
%template
%warn
Missing '%c'. Reached end of input.
Missing semicolon. Reached end of input.
Missing '}'. Reached end of input.
Syntax error. Bad operator name.
class keyword used, but not in C++ mode.
%%val directive deprecated (ignored).
%%out directive deprecated (ignored).
firstChild
nested:outer
feature:extend
nodeType
storage
cdecl
parentNode
lastChild
csym:
sym:weak
sym:typename
sym:symtab
sym:needs_symtab
requires_symtab
pattern
needs_defaultargs
nestedworkaround
feature:%s
noblock
parser.y
!Getattr(n, "defaultargs")
ismember
isextendmember
parser:makename
hasvalue
hasconsttype
feature:immutable
deleted
feature:ignore
$ignore
feature:warnfilter
already_warned
previous definition of '%s'
previous declaration of '%s'
 (Renamed from '%s')
%s:%d:%s
%s:%d:%s
notype name %s
partialargs
len == Len(found_scopename)
Undefined scope '%s'
classforward
feature:varargs
v(...)
feature:kwargs
compactdefargs
templatetype
templateparms
feature:new
feature:compactdefaultargs
Unknown directive '%s'.
Syntax error in input(1).
rawval
Unsupported constant value
$file
$line
section
emitonly
maininput
options
Couldn't find '%s'.
allprotected
wrap:name
%s%d
typemapcopy
typemapitem
convcode
variadic
abstracts
externc
uname
Unexpected ')'.
lambda
enum class
enum struct
$unnamed%d$
tdname
allows_typedef
enum 
unnamedinstance
protectedbaselist
privatebaselist
prev_symtab
nested:innerscope
nested:nscope
class_rename
Classprefix
templateparm
feature:flatnested
nested:unnamedtype
<unnamed>
template_parameters
partialarg
partialspecialization
partials
partialparms
templcsymname
%s<(
template<class> 
typename 
class... 
typename... 
'%s' is not a namespace.
Unknown namespace '%s'
'%s' is not a namespace
Syntax error in input(3).
conversion_operator
explicit constexpr
static constexpr
static thread_local
extern thread_local
template<class> %s %s
%s[%s]
Identifier %s not defined.
Extra %s specifier.
long %s
long double
double complex
float complex
%s complex
"%(escape)s"
_last
sizeof(%s)
sizeof...(%s)
L"%s"
'%(escape)s'
L'%s'
L'\0'
%s+%s
%s-%s
%s*%s
%s/%s
%s%%%s
%s&%s
%s|%s
%s^%s
%s << %s
%s >> %s
%s&&%s
%s||%s
%s==%s
%s!=%s
%s >= %s
%s <= %s
%s?%s:%s
class...
typename...
true
::%s%s
::~%s
__dummy_%d__
feature:onlychildren
enumforward
enumkey
scopedenum
Syntax error in input(2).
nested:unnamed
The 'nestedworkaround' feature is deprecated.
Identifier '%s' redefined (ignored)
Redundant redeclaration of '%s'
'%s' is not defined as a valid scope.
Nested %s not currently supported (%s ignored)
Nested %s not currently supported (ignored).
Deprecated %%extend name used - the %s name '%s' should be used instead of the typedef name '%s'.
Unsupported constant value (ignored)
Bad constant value (ignored).
%%except is deprecated.  Use %%exception instead.
%%inline directive inside a namespace is disallowed.
Directors are not supported for C code and require the -c++ option
%%name is deprecated.  Use %%rename instead.
Missing argument to %%name directive.
%%native declaration '%s' is not a function.
Argument count in %%varargs must be positive.
Specifying the language name in %%typemap is deprecated - use #ifdef SWIG<LANG> instead.
Too many template parameters. Maximum of %d.
Not enough template parameters specified. %d required.
Only the first variadic template argument is currently supported.
Unrecognized extern type "%s".
Lambda expressions and closures are not fully supported yet.
The 'using' keyword in type aliasing is not fully supported yet.
The 'using' keyword in template aliasing is not fully supported yet.
Syntax error - possibly a missing semicolon.
Specialization of non-template '%s'.
Inconsistent argument count in template partial specialization. %d %d
Explicit template instantiation ignored.
Nothing known about namespace '%s'
Namespace alias '%s' not allowed here. Assuming '%s'
%%extend can only be used in a public section
Can't set default argument (ignored)
Type error. Expecting an integral type
No access specifier given for base class '%s' (ignored).
%s inheritance from base '%s' (ignored).
typemap,typemapitem,typemapcopy,typedef,types,fragment
Named nested template instantiations not supported. Processing as if no name was given to %%template().
resolve_create_node_scope
update_defaultargs
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
../../Source/CParse/templ.c
dvalue
    matched partials: NONE
    chosen partial: '%s'
      '%s'
%5d 
      priority flags matrix:
  instantiation '%s' used,
ignored_node
    chosen template:'%s'
Equal(nodeType, "template")
Templated function found: %p
Template '%s' undefined.
ParmList_len(ptargs) == ParmList_len(tparms)
template_debug: Searching for match to: '%s'
    searching for : '%s' (explicit specialization)
    searching for : '%s' (explicit specialization with typedef reduction)
    explicit specialization found: '%s'
    previous instantiation found: '%s'
'%s' is not defined as a template. (%s)
    checking match: '%s' (partial specialization)
    possibly matched partials:
      parameter priorities matrix (%d parms):
Instantiation of template '%s' is ambiguous,
  instantiation '%s' ignored.
    chosen primary template: '%s'
    primary template not found
    Not a templated class, seeking most appropriate templated function
template_locate
Swig_cparse_template_locate
Swig_cparse_template_expand
God A red nugget A fat egg under a dog
Bad $descriptor() macro.
$descriptor(
feature:smartptr
f().
f(void).
Invalid type (%s) in 'smartptr' feature for class %s.
../../Source/DOH/base.c
b->refcount > 0
<Object '%s' at %p>
%0.17f
DohCopy
DohDelete
Unable to open file %s: %s
DohFile
../../Source/DOH/fio.c
pos != -1
dioxXucsSfeEgGpn
encode
Hash(%p)
Hash(%p) {
Hash(%p) {
'%s' : %s, 
Hash
../../Source/DOH/list.c
List(%p)
List[ 
l->items
List
!((n < 0) || (n >= l->nitems))
!((pos < 0) || (pos >= l->nitems))
List_get
List_set
List_remove
more
../../Source/DOH/memory.c
p->ptr
Memory statistics:
Pools:
Object types
    Strings   : %d
    Lists     : %d
    Hashes    : %d
    Pool %8p: size = %10d. used = %10d. free = %10d
    Total:          size = %10d, used = %10d, free = %10d
CreatePool
../../Source/DOH/string.c
str->sp >= 0
s->sp >= 0
s->str
String
String_delitem
DohString_append
String_insert
String_delslice
String_write
String_putc
replace_simple
String_chop
VoidObj
sym:overname
%s_%s__%s%s
SWIGALLEGROCL 1
allegrocl.swg
-identifier-converter
identifier-convert-lispify
identifier-convert-null
-cwrap
-nocwrap
-isolate
tmap:ctype
tmap:lin
tmap:lin:next
ACL_ENUM
EXPORT %s;
sym:overloaded
wrap:parms
tmap:in:numinputs
tmap:in:next
tmap:typecheck:precedence
tmap:typecheck:SWIGTYPE
as it is shadowed by %s.
overload:ignore
("%s")
(swig-defpackage %s)
allegrocl:last_linked_type
allegrocl:next_linked_type
allegrocl:prev_linked_type
allegrocl:synonym-of
forward-reference
union 
templateInst
real-name
allegrocl:namespace
allegrocl:package
allegrocl:synonym:is-primary
allegrocl:synonym
#.(swig-insert-id "%s" %s)
allegrocl:name
ffitype
(swig-in-package %s)
(lognot %s)
#\%s
#%c%s
(:function 
(:array %s
 #| %s |#)
(* %s)
allegrocl:typedef:in-class
%s__%s
allegrocl:in-class
__SWIGACL_FwdReference
ACLppc_%s
static %s = %s;
allegrocl:kind
allegrocl:old-sym:name
(swig-defconstant "%s" %s)
;; class template stub.
(swig-def-foreign-stub "%s")
Unknown
ff:foreign-pointer
feature:aclmixins
 ;; %s member
enumvalueex
;; forward referenced stub.
%d: (%p) node '%s' name '%s'
     synonym-of %s(%p)
lisptype
tmap:lin:numinputs
(:* %s)
(:member "%s" %s)
(:& %s)
(:array %s "%s")
(:function (
(:qualified (
%s) %s)
(:template "%s")
                           
allegrocl:id-converter-args
%ster
member 
allegrocl:lisp-wrap
@@OTHERS-ARGS-GO-HERE@@
lispclass
 :type :%s
 :class "%s"
allegrocl:dispatcher:name
allocate:smartpointeraccess
 :arity %s
(swig-defun ("%s" "%s"%s)
(swig-defun ("%s" "%s")
:void
PARM%d_%s
SWIG_arg%d
$in_fftype
$out
$*in_fftype
$body
(%s %s %s %s %s)
tmap:lout
$owner
$lclass
$out_fftype
$*out_fftype
(swig-ff-call%s)
cl::identity
:type :destructor
:type :class
$ldestructor
  (:returning (%s %s)
  %s)
feature:ffargs:
   %s %s
lresult
%s (
tmap:in
$input
emit:input
$result
    return lresult;
  } catch (...) {
    return (%s)0;
EXPORT %s {
(swig-in-package ())
anontype
swig.%s
%s%s.cl
lisphead
(cl::in-package :%s)
   (swig-do-export))
:constant
:variable
EXPORT %s %s;
%s %s = %s%s;
(swig-defvar "%s" :type %s)
member function
member variable
Allegro CL Options (available with -allegrocl)
     -identifier-converter <type or funcname> - 
                       Specifies the type of conversion to do on C identifiers to convert
                       them to symbols. There are two built-in converters: 'null' and
                       'lispify'. The default is 'null'. If you supply a name other
                       than one of the built-ins, then a function by that name will be
                       called to convert identifiers to symbols.
     -[no]cwrap      - Turn on or turn off generation of an intermediate C file when
                       creating a C interface. By default this is only done for C++ code.
     -isolate        - Define all SWIG helper functions in a package unique to this
                       module. Avoids redefinition warnings when loading multiple
                       SWIGged modules into the same running Allegro CL image.
Overloaded method %s not supported (incomplete type checking rule - no precedence level in typecheck typemap for '%s').
Overloaded method %s ignored,
using non-const method %s instead.
Overloaded method %s effectively ignored,
#.(swig-insert-id "%s" %s :type :class)
#.(swig-insert-id "%s" %s :type :type)
Hey-4 * - '%s' is a synonym of iteself!
Hey-7 * setting synonym of %p to %p
 (match = %p)
Attempting to store a foreign type that exists: %s (%s)
#.(swig-insert-id "%s" %s :type :constant)
Weird!! number %s looks invalid.
Unable to parse constant value '%s'. Setting to NIL
(swig-defconstant "%s" nil #| %s |#)
allegrocl:synonym:already-been-stubbed
(swig-def-synonym-type %s
   %s
   %s)
(swig-def-foreign-class "%s"
  (:%s
%s))
(#.(swig-insert-id "%s" %s :type :slot :class "%s") %s)
(swig-def-foreign-type "%s"
  %s)
(swig-def-foreign-type "%s" %s)
Unable to parse enum value '%s'. Setting to NIL
(swig-defvar "%s" "%s" :type :constant :ftype :signed-long)
(swig-def-foreign-class "%s" (ff:foreign-pointer) (:class ))
Don't know how to emit node type '%s' named '%s'
allegrocl:dispatcher:include-class
(swig-dispatcher ("%s" %s :arities (
(cl::let ((ACL_ffresult %s:*void*)
        ACL_result)
  $body
  (cl::if (cl::eq ACL_ffresult %s:*void*)
    (cl::values-list ACL_result)
   (cl::values-list (cl::cons ACL_ffresult ACL_result))))
(swig-defmethod ("%s" "%s"%s)
Unable to use return type %s in function %s.
Unable to open %s for writing
#ifndef SWIGALLEGROCL
#define SWIGALLEGROCL
#endif
(defpackage :%s
  (:use :common-lisp :ff :excl)
  (:export #:*swig-identifier-converter* #:*swig-module-name*
           #:*void* #:*swig-export-list*))
(in-package :%s)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *swig-identifier-converter* '%s)
  (defparameter *swig-module-name* :%s))
(defpackage :%s
  (:use :common-lisp :%s :ff :excl))
(macrolet ((swig-do-export ()
                 `(dolist (s ',*swig-export-list*)
                    (apply #'export s))))
(setq *swig-export-list* nil)
(swig-defvar "%s" "%s" :type %s)
9ALLEGROCL
allocate:has_destructor
allocate:default_destructor
allocate:private_destructor
csym:nextSibling
feature:catches
catchlist
feature:exceptionclass
allocate:default_constructor
allocate:has_constructor
allocate:public_constructor
r.%s
allocate:has_copy_constructor
allocate:copy_constructor
r.q(const).%s
privatebases
protectedbases
hides
covariant
allbases
abstracts:firstnode
allocate:visit
feature:nodefault
allocate:has_assign
allocate:has_new
allocate:noassign
allocate:smartpointer
allocate:nonew
operator ->
feature:notabstract
extendsmartclassname
cplus:staticbase
operator =
operator new
allocate:smartpointermutable
allocate:smartpointerconst
allocate:default_base_destructor
allocate:default_base_constructor
allocate:copy_base_constructor
Class '%s' might be abstract, no constructors generated,
Method %s might not be implemented.
Declaration of '%s' shadows declaration accessible via operator->(),
previous declaration of '%s'.
allocate:smartpointerpointeeclassname
8Allocate
SWIGCFFI 1
cffi.swg
-generate-typedef
-swig-lisp
-noswig-lisp
tmap:check
tmap:check:next
tmap:argout
tmap:argout:next
tmap:freearg
tmap:freearg:next
$source
$cleanup
$symname
feature:export
feature:export:package
(cl:export '%s%s%s)
feature:inline
(cl:declaim (cl:inline %s))
 :keyword
feature:intern_function
swig-lispify
#.(%s "%s" %s%s)
'function
(cffi:defcfun ("%s" %s)
:pointer
cout
&rest
  %s
  (%s %s)
t_arg%d
'variable
t_var
'classname
(cffi:defcunion %s
(cffi:defcstruct %s
'slotname
 (name: %s)
	(%s %s)
	(%s %s :count %s)
Malloc failed
cl:logior
cl:logand
cl:logxor
cl:*
cl:/
cl:+
cl:-
#\%c
%d >> %d
(cl:ash %d -%d)
%d << %d
(cl:ash %d %d)
'constant
(cl:defconstant %s %s)
(cffi:defbitfield %s
(cffi:defcenum %s
'enumvalue
(defanonenum %s
'enumname
feature:bitfield
	(%s #.%s)
(cl:shadow "%s")
'method
t-arg%d
 (ff-pointer %s)
'class
lresult = (%s)0
cffi:memberfunction
cffi:membervariable
memberget
memberset
cffi:constructorfunction
(cl:defclass %s%s
%s%s.lisp
%s%s-clos.lisp
swiglisp
'typename
(cffi:defctype %s %s)
CFFI Options (available with -cffi)
     -generate-typedef - Use defctype to generate shortcuts according to the
                         typedefs in the input.
     -[no]cwrap        - Turn on or turn off generation of an intermediate C
                         file when creating a C interface. By default this is
                         only done for C++ code.
     -[no]swig-lisp    - Turn on or off generation of code for helper lisp
                         macro, functions, etc. which SWIG uses while
                         generating wrappers. These macros, functions may still
                         be used by generated wrapper code.
(cffi:defcvar ("%s" %s)
 %s)
Don't know how to deal with %s kind of class yet.
feature:bitfield:ignore_values
(cl:defmethod %s (%s)
  (%s%s))
(cl:defmethod initialize-instance :after ((obj %s) &key%s)
  (setf (slot-value obj 'ff-pointer) (%s%s)))
(cl:defmethod (cl:setf %s) (arg0 (obj %s))
  (%s (ff-pointer obj) arg0))
(cl:defmethod %s ((obj %s))
  (%s (ff-pointer obj)))
  ((ff-pointer :reader ff-pointer)))
#ifndef SWIGCFFI
#define SWIGCFFI
#endif
4CFFI
swigchickenrun.h
-proxy
-closprefix
-useclassprefix
-unhideprimitive
-nounit
-noclosuses
-nocollection
SWIGCHICKEN 1
chicken.swg
^^##optional$$
chickenrun.swg
 (arg%i %s)
arg%i
primitive:
  *(a++)=(C_word)
  *(a++)=C_CLOSURE_TYPE|1;
  C_word *p0 = a;
+C_SIZEOF_INTERNED_SYMBOL(%d)
argv[0]
static void 
C_word resultobj
if (argc > 2) {
$target
$varname
C_word func;
tmap:varin:closcode
feature:constasvar
(car lst)
 . lst) (if (null? lst) (
(define (
(define 
(set! 
swig_const_%s
$value
Unsupported constant value.
Beeb
static void real_
int argc
C_word argv[%d]
int ii
C_word t = args
a = C_alloc((c-2)*3);
C_save_rest (t1, c2, 2);
C_word *a, c2 = c;
va_list v;
C_word t2;
 (3, t0, t1, t2);
%s@SWIG@new@dispatch
(declare (hide %s))
<top>
(define %s %s)
(C_word,C_word,C_word
, C_word scm%d
tmap:in:parse
wrap:disown
tmap:in:disown
if (argc-2>%i && (%s)) {
tmap:in:closcode
SWIG_Chicken_SetupArgout
$arg
 C_noret;
SWIG_POINTER_DISOWN
$disown
#define SWIG_name "%s"
extern "C" {
%s%s.scm
(declare (unit 
(declare 
_init"))
(require-extension tinyclos)
$module
$nummethods
$symsize
$veclength
  (make <swig-metaclass-
> 'name "
    'direct-supers (list 
SWIG_TypeClientData(SWIGTYPE
) initargs)
%s@@SWIG@initmethod
_swig_chicken_setclosclass
->clientdata;
  C_trace("
(cons (make 
 (lambda (x lst) (if lst 
 'swig-this x))))
 'swig-this x) lst) 
 ':swig-virtual ':swig-get 
        (list '
 ':swig-set (lambda (x y) (
 ':swig-set 
delete-%s
(declare (uses %s))
CHICKEN Options (available with -chicken)
     -closprefix <prefix>   - Prepend <prefix> to all clos identifiers
     -noclosuses            - Do not (declare (uses ...)) in scheme file
     -nocollection          - Do not register pointers with chicken garbage
                              collector and export destructors
     -nounit                - Do not (declare (unit ...)) in scheme file
     -proxy                 - Export TinyCLOS class definitions
     -unhideprimitive       - Unhide the primitive: symbols
     -useclassprefix        - Prepend the class name to all clos identifiers
*** Unable to open 'chickenrun.swg'
(define-method (%s %s . args) (apply %s %s args))
(define-method (%s %s) (%s %s))
  C_mutate(return_vec++, (C_word)p0);
sym = C_intern (&a, %d, "%s");
, tmp=(C_word)a, a+=2, tmp));
C_mutate ((C_word*)sym+1, (*a=C_CLOSURE_TYPE|1, a[1]=(C_word)
(vector-ref swig-init-return %i)
Internal Error: attempting to reference non-existant primitive name %s
(C_word, C_word, C_word, C_word) C_noret;
(C_word argc, C_word closure, C_word continuation, C_word value) {
if (argc!=2 && argc!=3) C_bad_argc(argc,2);
Unable to set variable of type %s.
Unable to read variable of type %s
  ((C_proc4)(void *)C_block_item(func, 0))(4,func,continuation,resultobj,C_SCHEME_FALSE);
if (C_swig_is_closurep(func))
SWIG_Chicken_FindCreateProxy(func, resultobj)
  C_kontinue(continuation, resultobj);
(C_word, C_word, C_word) C_noret;
(C_word argc, C_word closure, C_word continuation) {
if (argc!=2) C_bad_argc(argc,2);
%s (2+$numargs,closure,continuation$commaargs);
(C_word oldargc, C_word closure, C_word continuation, C_word args) {
if (!C_swig_is_list (args)) {
  swig_barf (SWIG_BARF1_BAD_ARGUMENT_TYPE, "Argument #1 must be a list of overloaded arguments");
argc = C_unfix (C_i_length (args));
for (ii = 0; (ii < argc) && (ii < %d); ii++, t = C_block_item (t, 1)) {
argv[ii] = C_block_item (t, 0);
swig_barf (SWIG_BARF1_BAD_ARGUMENT_TYPE,"No matching function for overloaded '%s'");
(C_word, C_word, C_word, ...) C_noret;
(C_word c, C_word t0, C_word t1, ...) {
t2 = C_restore_rest (a, C_rest_count (0));
 (C_word argc, C_word closure, C_word continuation
Unable to use type %s as a function argument.
if (argc-2<%i || argc-2>%i) C_bad_argc(argc,%i);
SWIG_APPEND_VALUE(resultobj);
C_kontinue(continuation,C_SCHEME_END_OF_LIST);
C_kontinue(continuation,resultobj);
((swig_chicken_clientdata *)(SWIGTYPE%s->clientdata))->destroy = (swig_chicken_destructor) %s;
if (argc!=%i) C_bad_argc(argc,%i);
#ifndef SWIGCHICKEN
#define SWIGCHICKEN
#endif
#define SWIG_CHICKEN_NO_COLLECTION 1
#define SWIG_init swig_%s_init
C_kontinue (continuation, ret);
(foreign-declare "C_extern void swig_
(hide swig-init swig-init-return)
_init(C_word,C_word,C_word) C_noret;"))
(define swig-init (##core#primitive "swig_
(define swig-init-return (swig-init))
    'direct-supers (list <object>)
    'direct-slots (list 'swig-this
static swig_chicken_clientdata _swig_chicken_clientdata%s = { 0 };
, (void *) &_swig_chicken_clientdata
  (swig-initialize obj initargs 
(define-method (initialize (obj 
  (swig-initialize obj initargs (lambda x #f)))
(C_word,C_word,C_word,C_word) C_noret;
  C_kontinue(continuation, C_SCHEME_UNDEFINED);
  CHICKEN_gc_root_set(cdata->gc_proxy_create, cl);
  cdata->gc_proxy_create = CHICKEN_new_gc_root();
  swig_chicken_clientdata *cdata = (swig_chicken_clientdata *) SWIGTYPE
  if (argc!=3) C_bad_argc(argc,3);
(C_word argc, C_word closure, C_word continuation, C_word cl) {
 x (slot-ref y 'swig-this))))
7CHICKEN
SWIGCLISP 1
clisp.swg
-extern-all
(ffi:def-c-enum %s 
(defconstant %s %s)
(ffi:c-array %s %s)
(ffi:c-ptr %s)
(ffi:c-pointer %s)
(ffi:def-c-struct %s
make-%s
	(:library +library-name+))
	(:arguments 
	(:return-type %s)
Unable to determine outfile
  (:export
	:%s
(in-package :%s)
(ffi:def-c-type %s %s)
CLISP Options (available with -clisp)
     -extern-all       - Create clisp definitions for all the functions and
                         global variables otherwise only definitions for
                         externed functions and variables are created.
     -generate-typedef - Use def-c-type to generate shortcuts according to the
                         typedefs in the input.
(ffi:c-ptr (ffi:c-array %s %s))
(ffi:c-function %s 				(:return-type %s))
Structure %s has a slot that we can't deal with.
nodeType: %s, name: %s, type: %s
(ffi:def-c-var %s
 (:name "%s")
 (:type %s)
(ffi:def-call-out %s
	(:name "%s")
(defpackage :%s
  (:use :common-lisp :ffi)
(default-foreign-language :stdc)
5CLISP
require:
feature:contract
ensure:
) %s (%s)
 %s [%s from %s]
contract:rules
contract:messages
arg1
$self
contract:preassert
contract:postassert
SWIG_contract_assert(%s, "Contract violation: require: %s");
SWIG_contract_assert(%s, "Contract violation: ensure: %s");
9Contracts
    virtual ~%s() throw ();
%s::~%s() throw () {
    virtual ~%s();
%s::~%s() {
SWIGCSHARP 1
csharp.swg
-dllimport
-namespace
-noproxy
-oldvarnames
-outfile
nativeWrapper
proxyname
sym:nspace
$*csclassname
$&csclassname
// <auto-generated />
%s%s.cs
SwigDirector_%s
c_result
tmap:imtype:out
  private %s SwigDirector%s(
  public delegate %s
%s jresult
if (!swig_callback%s) {
tmap:directorin:numinputs
tmap:directorin:next
tmap:ctype:out
tmap:directorin
emit:directorinput
tmap:imtype
tmap:csdirectorin
$imclassname
$iminput
tmap:csdirectorin:pre
tmap:csdirectorin:post
tmap:csdirectorin:terminator
%s%s %s
tmap:cstype
ref 
typeof(%s).MakeByRefType()
out 
typeof(%s)
classDirectorMethods:type
    virtual %s
tmap:throws
csdirectorout
$cscall
    %s;
jresult = (%s) 
swig_callback%s(%s);
tmap:directorargout
tmap:%s:canthrow
csharp:canthrow
tmap:directorargout:next
return %s;
    }
$null
upcalldata
 SwigDelegate%s_%s(%s);
SwigDirector%s%s delegate%s
= SwigValueInit< %s >()
q(const).
= &result_default
%sSwigPublic
      
 throw(
No %s typemap defined for %s
csinterfaces_derived
csinterfaces
classtypeobj
csbase
tmap:csbase:replace
tmap:csbase:notderived
csimports
csattributes
csbody_derived
csbody
csclassmodifiers
 $csclassname
csdestruct_derived
csdestruct
tmap:csdestruct:methodname
csfinalize
$imcall
director_connect
    %s.%s(swigCPtr
, swigDelegate%s
    return hasDerivedMethod;
cscode
SWIGSmartPtrUpcast
", EntryPoint="
 * SWIGSTDCALL 
(*jarg1) : 0;
    return jarg1 ? new 
 *jarg1) {
SWIGUpcast
 *)jarg1;
    return (
tmap:%s:excode
$excode
tmap:cstype:out
tmap:cstype:outattributes
feature:cs:attributes
feature:cs:methodmodifiers
  %s static %s %s(
tmap:cstype:inattributes
tmap:csin
$csinput
tmap:csin:pre
tmap:csin:post
tmap:csin:terminator
csout
    try 
    }
  %s static %s %s {
tmap:csvarin
csvarout
proxyfuncname
explicitcall
override 
.$imfuncname(
varargs:ignore
explicitcallnode
$imfuncname
directorNode
last_parm
  %s %s%s %s {
tmap:imtype:outattributes
 SWIGEXPORT 
  public static extern %s %s(
tmap:imtype:inattributes
tmap:out:null
    return jresult;
SWIG_contract_assert($null, 
SWIG_contract_assert(
feature:except:canthrow
SWIG_exception
director:ctor
%s::%s() : %s {
    %s();
classtype
%s::%s : %s, %s {
  swig_init_callbacks();
SWIG_Callback%s_t callback%s
private:
swig_callback%s = 0;
$director_new
Swig::Director()
director:decl
feature:cs:const
(%s)%s.%s();
new %s(%s.%s(), false);
wrappedasconstant
enumtype
  %s %s %s %s = 
feature:cs:constvalue
static readonly
$csclazzname
$dllimport
feature:csdowncast
SWIGDowncast
  %s *obj = (%s *)objarg;
  if (director) {
(swigCPtr)
  %s %s(
csconstruct
tmap:csin:cshin
$directorconnect
    try {
      return 
    } finally {
%s.SwigConstruct%s(%s)
%s.%s()
feature:cs:enum
simple
typesafe
proper
firstenumitem
  %s %s %s %s = %s;
?value
*name
enumvalueDeclaration
!full_imclass_name
$enumvalues
  // %s 
imclassbase
imclassclassmodifiers
imclasscode
imclassimports
imclassinterfaces
modulebase
moduleclassmodifiers
moduleinterfaces
Unrecognized pragma.
outfile_h
director_h
%sPINVOKE
%sModule
#define SWIG_DIRECTORS
#ifndef SWIG_%s_WRAP_H_
#define SWIG_%s_WRAP_H_
CSharp_%f
set_%n%v
get_%n%v
#ifdef __cplusplus
director_common.swg
director.swg
: %s 
No return type for %%native method %s.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
tmap:imtype:directoroutattributes
No imtype typemap defined for %s
No ctype typemap defined for %s for use in %s::%s (skipping director method)
 throw Swig::DirectorPureVirtualException("%s::%s");
tmap:imtype:directorinattributes
No cstype typemap defined for %s
No csdirectorin typemap defined for %s for use in %s::%s (skipping director method)
No imtype typemap defined for %s for use in %s::%s (skipping director method)
No or improper directorin typemap defined for argument %s for use in %s::%s (skipping director method)
    try {
      %s;
    } finally {
    }
    try {
      %s;
    } finally {
    }
Unable to use return type %s used in %s::%s (skipping director method)
    typedef %s (SWIGSTDCALL* SWIG_Callback%s_t)(
    SWIG_Callback%s_t swig_callback%s;
Do nine men interpret Nine men I nod
  private SwigDelegate%s_%s swigDelegate%s;
  private static global::System.Type[] swigMethodTypes%s = new global::System.Type[] { %s };
Warning for %s proxy: Base %s ignored. Multiple inheritance is not supported in C#.
The csbase typemap for proxy %s must contain just one of the 'replace' or 'notderived' attributes.
tmap:csdestruct_derived:methodname
tmap:csdestruct_derived:methodmodifiers
tmap:csdestruct:methodmodifiers
No methodname attribute defined in csdestruct%s typemap for %s
No methodmodifiers attribute defined in csdestruct%s typemap for %s.
throw new global::System.MethodAccessException("C++ destructor does not have public access")
  private void SwigDirectorConnect() {
    if (SwigDerivedClassHasMethod("%s", swigMethodTypes%s))
      swigDelegate%s = new SwigDelegate%s_%s(SwigDirector%s);
  private bool SwigDerivedClassHasMethod(string methodName, global::System.Type[] methodTypes) {
    global::System.Reflection.MethodInfo methodInfo = this.GetType().GetMethod(methodName, global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.NonPublic | global::System.Reflection.BindingFlags.Instance, null, methodTypes, null);
    bool hasDerivedMethod = methodInfo.DeclaringType.IsSubclassOf(typeof(%s));
Warning for %s proxy: Base %s ignored. Multiple inheritance is not supported in C#. Perhaps you need one of the 'replace' or 'notderived' attributes in the csbase typemap?
  [global::System.Runtime.InteropServices.DllImport("
  public static extern global::System.IntPtr %s(global::System.IntPtr jarg1);
C# exception may not be thrown - no $excode or excode attribute in '%s' typemap.
No csin typemap defined for %s
No csout typemap defined for %s
No csvarin typemap defined for %s
No csvarout typemap defined for %s
if (SwigDerivedClassHasMethod("%s", swigMethodTypes%s)) %s; else %s
(SwigDerivedClassHasMethod("%s", swigMethodTypes%s) ? %s : %s)
../../Source/Modules/csharp.cxx
Covariant return types not supported in C#. Proxy method will return %s.
No ctype typemap defined for %s
Unmanaged code contains a call to SWIG_exception and C# code does not handle pending exceptions via the canthrow attribute.
SWIG_CSharpSetPendingException
Unmanaged code contains a call to a SWIG_CSharpSetPendingException method and C# code does not handle pending exceptions via the canthrow attribute.
    void swig_connect_director(
void %s::swig_connect_director(
swig_callback%s = callback%s;
    void swig_init_callbacks();
void %s::swig_init_callbacks() {
 : public %s, public Swig::Director
staticmembervariableHandler:value
Class name cannot be equal to intermediary class name: %s
Class name cannot be equal to module class name: %s
  public final static native %s %s(long cPtrBase, boolean cMemoryOwn);
SWIGEXPORT jobject SWIGSTDCALL %s(JNIEnv *jenv, jclass jcls, jlong jCPtrBase, jboolean cMemoryOwn) {
  Swig::Director *director = (Swig::Director *) 0;
  jobject jresult = (jobject) 0;
  %s *obj = *((%s **)&jCPtrBase);
  if (obj) director = dynamic_cast<Swig::Director *>(obj);
  if (director) jresult = director->swig_get_self(jenv);
  public static extern void %s(global::System.Runtime.InteropServices.HandleRef jarg1
SWIGEXPORT void SWIGSTDCALL %s(void *objarg
  // Keep a local instance of the smart pointer around while we are using the raw pointer
  // Avoids using smart pointer specific API.
  %s *director = dynamic_cast<%s *>(obj->operator->());
  %s *director = dynamic_cast<%s *>(obj);
    director->swig_connect_director(
%s::SWIG_Callback%s_t callback%s
, %s.SwigDelegate%s_%s delegate%s
  static private %s SwigConstruct%s(
tmap:csconstruct:directorconnect
"directorconnect" attribute missing in %s "csconstruct" typemap.
  %s static readonly %s %s = new %s("%s", %s);
  %s static readonly %s %s = new %s("%s");
Unable to determine outfile_h
#ifndef SWIGCSHARP
#define SWIGCSHARP
#endif
/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */
Portability warning: File %s will be overwritten by %s on case insensitive filesystems such as Windows' FAT32 and NTFS unless the class/module name is renamed
C# Options (available with -csharp)
     -dllimport <dl> - Override DllImport attribute name to <dl>
     -namespace <nm> - Generate wrappers into C# namespace <nm>
     -noproxy        - Generate the low-level functional interface instead
                       of proxy classes
     -oldvarnames    - Old intermediary method names for variable wrappers
     -outfile <file> - Write all C# into a single <file> located in the output directory
virtual int CSHARP::enumDeclaration(Node*)
void CSHARP::proxyClassFunctionHandler(Node*)
6CSHARP
SWIGD 1
SWIG_D_VERSION %u
-wrapperlibrary
-package
-splitproxy
feature:d:constvalue
nonempty
static import %s%s;
%s%s.%s.%s
%s%s.%s
$*dclassname
$&dclassname
tmap:dtype:cprimitive
tmap:%s
tmap:%s:nativepointer
$dtype
$importtype(
Syntax error in: %s
<error in $importtype macro>
dinterfaces_derived
dinterfaces
 override
const 
dbase
tmap:dbase:replace
tmap:dbase:notderived
$cclass
$cbaseclass
dimports
dclassmodifiers
 $dclassname
dbody_derived
ddispose_derived
dbody
ddispose
tmap:ddispose:methodname
tmap:ddispose:methodmodifiers
ddestructor
return_type
param_list
, callback%s
  DelegateType dg = &fn;
  return cast(Function) &fn;
$dbaseclass
(void* objectRef)
void*
$function
$symbol
(*objectRef) : 0;
    return objectRef ? new 
 *objectRef) {
 *)objectRef;
tmap:dtype:out
tmap:dtype:outattributes
feature:d:methodmodifiers
%s%s %s(
tmap:dtype:inattributes
$dinput
tmap:din:pre
tmap:din:post
tmap:din:terminator
@property 
dout
d:canthrow
  try 
ddirectorin
if (!swig_callback_%s) {
, %s
$winput
(cast(%s)dObject).%s(%s)
ddirectorout
$dcall
(void *dobj%s);
%s_Callback%s
 static
cast(void*)swigCPtr
SWIG_DSetPendingException
d_object = dobj;
private:
    void *d_object;
swig_callback_%s = 0;
%s%s.d
module %s%s.%s;
module %s%s;
static import %s;
, %s_Callback%s callback%s
$dclazzname
$imdmodule
(cast(void*)swigCPtr)
%s this(
dconstructor
tmap:din:parmtype
feature:d:manifestconst
%s const %s %s = 
%s enum %s %s = 
alias $dbaseclass.%s %s;
enum {
alias int %s;
imdmodulecode
imdmoduleimports
proxydmodulecode
globalproxyimports
wrapperloadercode
wrapperloaderbindcommand
imdmodulename
%s_im
%s_wrap
D_%f
module %s;
$wraplibrary
$wrapperloaderbindcode
Class name cannot be equal to intermediary D module name: %s
Class name cannot be the same as the root package it is in: %s
Class name cannot be the same as the outermost namespace it is in: %s
Class name cannot be the same as the innermost namespace it is in: %s
Class name cannot be equal to proxy D module name: %s
%s.SwigExternC!(%s function(%s))
Base %s of class %s ignored: multiple inheritance is not supported in D.
The dbase typemap for proxy %s must contain just one of the 'replace' or 'notderived' attributes.
tmap:ddispose_derived:methodname
tmap:ddispose_derived:methodmodifiers
No methodname attribute defined in the ddispose%s typemap for %s
No methodmodifiers attribute defined in ddispose%s typemap for %s.
throw new object.Exception("C++ destructor does not have public access")
private void swigDirectorConnect() {
  %s.%s(cast(void*)swigCPtr, cast(void*)this
  %s.%s_Callback%s callback%s;
  if (swigIsMethodOverridden!(%s delegate(%s), %s function(%s), %s)()) {
    callback%s = &swigDirectorCallback_%s_%s;
private bool swigIsMethodOverridden(DelegateType, FunctionType, alias fn)() %s{
  return dg.funcptr != SwigNonVirtualAddressOf!(FunctionType, fn);
private static Function SwigNonVirtualAddressOf(Function, alias fn)() {
Warning for %s proxy: Base class %s ignored. Multiple inheritance is not supported in D. Perhaps you need one of the 'replace' or 'notderived' attributes in the dbase typemap?
SwigExternC!(%s function%s) %s;
No dtype typemap defined for %s
No din typemap defined for %s
D exception may not be thrown 
 no $excode or excode attribute in '%s' typemap.
No dout typemap defined for %s
private extern(C) %s swigDirectorCallback_%s_%s(void* dObject
No ddirectorin typemap defined for %s for use in %s::%s (skipping director method)
swig_callback_%s(d_object%s);
    typedef %s (* SWIG_Callback%s_t)
    SWIG_Callback%s_t swig_callback_%s;
alias extern(C) %s function(void*%s) %s;
if (swigIsMethodOverridden!(%s delegate(%s), %s function(%s), %s)()) %s; else %s
((swigIsMethodOverridden!(%s delegate(%s), %s function(%s), %s)()) ? %s : %s)
C code contains a call to SWIG_exception and D code does not handle pending exceptions via the canthrow attribute.
C code contains a call to a SWIG_DSetPendingException method and D code does not handle pending exceptions via the canthrow attribute.
    void swig_connect_director(void* dobj
void %s::swig_connect_director(void* dobj
, SWIG_Callback%s_t callback%s
, SWIG_Callback%s_t callback_%s
swig_callback_%s = callback_%s;
%s : public %s, public Swig::Director {
/* ----------------------------------------------------------------------------
 * ----------------------------------------------------------------------------- */
extern(C) void function(void* cObject, void* dObject
SWIGEXPORT void D_%s(void *objarg, void *dobj
    director->swig_connect_director(dobj
, %s::SWIG_Callback%s_t callback%s
static private %s SwigConstruct%s(
"directorconnect" attribute missing in %s "dconstructor" typemap.
tmap:dconstructor:directorconnect
%s::%s might collide with the package name, consider using %%rename to resolve the ambiguity.
#ifndef SWIGD
#define SWIGD
#endif
D Options (available with -d)
     -d2                  - Generate code for D2/Phobos (default: D1/Tango)
     -package <pkg>       - Write generated D modules into package <pkg>
     -splitproxy          - Write each D type to a dedicated file instead of
                            generating a single proxy D module.
     -wrapperlibrary <wl> - Set the name of the wrapper library to <wl>
%s::
%s *darg = 0
darg
 : public %s, public Swig::Director {
staticmemberfunctionHandler:storage
darg = dynamic_cast<%s *>(arg1);
tmap:out:optimal
tmap:arginit
tmap:arginit:next
tmap:default
tmap:default:next
emit:varargs
../../Source/Modules/emit.cxx
Getattr(n, "wrap:name")
feature:except
$action
feature:fragment
wrap:code
wrap:code:done
feature:action
wrap:action
action != 0
wrap:preaction
wrap:postaction
catch(...) {
catch(%s) {
catch(...) { throw; }
Variable length arguments discarded.
Non-optional argument '%s' follows an optional argument.
No 'throws' typemap defined for exception type '%s'
String* emit_action(Node*)
int emit_action_code(Node*, String*, String*)
 private:
  Swig_memory *swig_mem;
-cgo
-gccgo
-go-prefix
-go-pkgpath
-use-shlib
-soname
-longsize
-intgosize
-intgosize not 32 or 64
SWIGGO 1
SWIGGO_CGO 1
SWIGGO_GCCGO 1
SWIGGO_INTGO_SIZE 32
SWIGGO_INTGO_SIZE 64
SWIGGO_INTGO_SIZE 0
go.swg
#pragma dynimport 
#pragma cgo_import_static 
(void*);
extern void 
 = (uintptr)
uintptr 
  %s *swig_b%d = (%s *)%s;
swig_b%d
tmap:out
emitGoAction
Unable to use return type %s
_swig_go_result
char *swig_stktop
	swig_a->
../../Source/Modules/go.cxx
test
$gotypename
go:conflict
.Swigcptr
$nondirector_new
!class_name
!class_receiver
_swig_Director
	v interface{}
) Swigcptr() uintptr {
func (p *
.Swigcptr()
	return p.
) SwigIs
	return p.v
 : public 
 public:
) SwigGet
func (p 
.SwigGet
	return p
	SwigGet
go:enumname
*p == ':'
tmap:gotype
_swig_memberptr
[]interface{}
No Go typemap defined for %s
goType
_swig_fnptr
goImType
complex64
complex128
uint
uint8
byte
uint16
uint32
uint64
float32
float64
_gostring_
_goslice_
_Complex float 
_Complex double 
intgo 
long long 
bool 
char 
short 
cgoGccWrapper
intgo _swig_optargc
_swig_go_%d
	if (_swig_optargc > %d) {
	return _swig_go_result;
gccFunctionWrapper
(void *swig_v)
	struct swigargs {
		intgo _swig_optargc;
		long : 0;
 = swig_a->
gccgoFunctionWrapper
  if (_swig_optargc > %d) {
  return _swig_go_result;
extern "C" 
(int
(go_val
(void*, int);
extern "C" void 
  struct {
    intgo go_val;
    long : 0;
  } swig_a;
  swig_a.go_val = go_val;
swig_a.
swig_a.%s
#pragma dynexport 
#pragma cgo_export_static 
#pragma textflag 7
extern void 
(void *a, int32 n)
, a, n);
	runtime
cgocallback(
  crosscall2(
swig_voidp
map[
chan 
emit:cgotype
emit:cgotypestruct
swig_type_%d
_Bool
swig_intgo
typedef 
tmap:goargout
swig_r
emit:goinput
tmap:goargout:next
		Swig_escape_val = 
SwigType_issimple(ty)
	SwigIs
(p.Swigcptr())
	return 
func 
_swig_args ...interface{}
	var swig_r 
C.swig_intgo(len(_swig_args))
C.uintptr_t(_swig_base)
_swig_i_%d
tmap:goin
)(unsafe.Pointer(&
*(*C.
)(unsafe.Pointer(&swig_r_p))
	swig_r = *(*
goout
	return swig_r
	var 
	if len(_swig_args) > %d {
		%s = _swig_args[%d].(%s)
swig_r_p := 
swig_r = (
.Swigcptr()
	var swig_r_1 
swig_r_1
	return swig_r_1
!base
 unsafe.Pointer
_swig_wrap_
//extern 
 uintptr
	var _swig_p uintptr
, _swig_p)
	_cgo_runtime_cgocall(
_swig_ret
	func() {
	defer SwigCgocallDone()
	SwigCgocall()
swig_r = 
len(_swig_args)
	}()
makeCgoWrappers
intgo _swig_args
uintptr_t _swig_base
DeleteDirector
Swiggo_DeleteDirector_
  virtual ~SwigDirector_
::~SwigDirector_
//export 
(c int) {
	swigDirectorLookup(c).(*
	swigDirectorDelete(c)
(intgo);
(go_val);
	SwigCgocallBack()
	defer SwigCgocallBackDone()
_swiggo_wrap_DeleteDirector_
(intgo) __asm__("
  struct { intgo p; } a;
  a.p = go_val;
, &a, (int) sizeof a);
  delete swig_mem;
_swig_get
*sym:name
goBaseMethod
goBaseVariableSet
tmap:
goBaseVariable
addExtraBaseInterface
_SwigGet
!is_upcall
go:type
abi interface{}, 
!add_to_interface
(a ...interface{})
	argc := len(a)
	if argc >= %d {
	if argc == %d {
		if argc > %d {
			goto check_%d
num_required > 0
a[0].(
a[%d].(%s)
		switch argc {
		case %d:
a[%d]
check_%d:
Strncmp(name, "new_", 4) == 0
Delete
swiggoscope.
is_ignored
_swig_NewDirector
swig_p
extern uintptr_t 
(_swig_director int
) (_swig_ret 
, _ 
(v interface{}
{0, v}
	p := &
(C.int(swigDirectorAdd(p))
(swigDirectorAdd(p)
	return p
classDirectorConstructor
 = new SwigDirector_
    : 
_swig_DirectorInterface
_callback_
Swig
 interface {
(uintptr_t
(_swig_ptr 
func (swig_p *
); swig_ok {
swig_g.
		return
C.uintptr_t(
swig_p.
	}()
_swig_upcall_
classDirectorMethod
func Director
p.(*
(swig_c int
(swig_result 
godirectorout
tmap:godirectorin
.Swigcptr())
  virtual 
is_pure_virtual
feature:director
feature:nodirector
 uintptr
	return (uintptr)(p)
	return nil
	Swigcptr() uintptr
!making_variable_wrappers
!is_static_member_function
generated
go_imports
import "
%s%s.go
%s%s_gc.c
_%s_%08x%08x
go_begin
go_runtime
go_header
go_wrapper
go_director
cgo_comment
cgo_comment_typedefs
gc_begin
gc_runtime
gc_header
gc_wrapper
// source: %s
/* source: %s */
#define SWIGMODULE %s
#define SWIGGO_PREFIX %s
class Swig_memory;
// source: %s
#define intgo swig_intgo
typedef void *swig_voidp;
#pragma dynimport _ _ "%s"
package %s
func SwigCgocall()
func SwigCgocallDone()
func SwigCgocallBack()
func SwigCgocallBackDone()
	Swigcptr() uintptr;
	return uintptr(p)
#undef intgo
import "C"
Go Options (available with -go)
     -cgo                - Generate cgo input files
     -gccgo              - Generate code for gccgo rather than 6g/8g
     -go-pkgpath <p>     - Like gccgo -fgo-pkgpath option
     -go-prefix <p>      - Like gccgo -fgo-prefix option
     -intgosize <s>      - Set size of Go int type--32 or 64 bits
     -package <name>     - Set name of the Go package to <name>
     -use-shlib          - Force use of a shared library
     -soname <name>      - Set shared library holding C/C++ code to <name>
SWIG -go: -intgosize option required but not specified
	swig_stktop = _swig_topofstack();
	swig_a = (struct swigargs*)((char*)swig_a + (_swig_topofstack() - swig_stktop));
Ignoring '%s' due to Go name ('%s') conflict with '%s'
Ignoring '%s' (Go name '%s') due to Go name conflict for parameter or result type '%s'
) DirectorInterface() interface{} {
unable to use type %s as a function argument
	} *swig_a = (struct swigargs *) swig_v;
Unable to use type %s as a function argument
	if (swig_a->_swig_optargc > %d) {
Unable to use type %s as director method argument
Unable to use type %s as director method result
, &swig_a, (int) sizeof swig_a);
	if Swig_escape_always_false {
	_swig_p := uintptr(unsafe.Pointer(&base))
	_swig_p := uintptr(unsafe.Pointer(&
	panic("No match for overloaded function call")
	if argc >= %d && argc <= %d {
		if _, ok := a[%d].(%s); !ok {
is_set || Strcmp(Char(name) + Len(name) - 4, "_get") == 0
Strncmp(name, "delete_", 7) == 0
	_swig_p := uintptr(unsafe.Pointer(&_swig_director))
      go_val(swig_p), swig_mem(0)
	_swig_p := uintptr(unsafe.Pointer(&_swig_ptr))
	if swig_g, swig_ok := swig_p.v.(
	panic("call to pure virtual method")
	swig_p := swigDirectorLookup(swig_c).(*
  _swig_gopanic("call to pure virtual function 
_swig_gopanic("accessing abstract class or protected constructor");
	DirectorInterface() interface{}
// C++ director class methods.
/* This file should be compiled with 6c/8c.  */
virtual int GO::staticmemberfunctionHandler(Node*)
virtual int GO::variableHandler(Node*)
virtual int GO::functionWrapper(Node*)
virtual int GO::classDirectorInit(Node*)
bool GO::checkNameConflict(String*, Node*, const_String_or_char_ptr)
virtual int GO::classDirectorConstructor(Node*)
int GO::makeDispatchFunction(Node*, String*, String*, bool, SwigType*, bool)
int GO::oneClassDirectorMethod(Node*, Node*, String*)
virtual int GO::classDirectorMethod(Node*, Node*, String*)
int GO::goFunctionWrapper(Node*, String*, String*, String*, String*, List*, ParmList*, SwigType*, bool)
String* GO::goEnumName(Node*)
String* GO::goWrapperType(Node*, SwigType*, bool)
int GO::makeCgoWrappers(Node*, String*, String*, String*, List*, ParmList*, SwigType*, bool)
int GO::makeWrappers(Node*, String*, String*, String*, String*, List*, ParmList*, SwigType*, bool)
swigguilerun.h
guile_scm_run.swg
guile:goopsclassname
%sconst_%s
static %s = (%s)(%s);
-Linkage
-linkage
ltdlmod
hobbit
passive
-procdoc
-procdocformat
guile-1.4
plain
-emit-setters
-emitsetters
-only-setters
-onlysetters
-emit-slot-accessors
-emitslotaccessors
-scmstub
-shadow
-scm
-primsuffix
-goopsprefix
-exportprimitive
SWIGGUILE 1
guile_scm.swg
SCM s_%d
 #:optional
tmap:in:arglist
$name
$type
@var{%s}
$NAME
$PARMNAME
tmap:in:doc
$NAME is of type <$type>
Unable to handle type %s.
tmap:argout:doc
$NAME (of type $type)
#define FUNC_NAME "
tmap:out:doc
#undef FUNC_NAME
_rest (SCM rest)
static SCM
SCM arg[%d];
arg[0]
, arg[%d]
SCM setter = 
SCM getter = 
scm_c_define
("%s", getter);
"%s", 
return %s(argc,argv);
(SCM rest)
#define FUNC_NAME "%s"
SCM argv[%d];
(define-method (
 . %args)
 %args))
  (apply 
$num_values
$values
@deffn primitive 
@end deffn
%%arg%d
SCM gswig_result
gswig_list_p
int argc, SCM *argv
static SCM
%s(SCM s_0)
if (s_0 != SCM_UNDEFINED) {
return gswig_result;
(set! %s (%s))
Is constant 
Returns constant 
tmap:varout:doc
set! (
tmap:varin:arglist
new-value
which is of type 
$1_type
 #:optional 
tmap:varin:doc
new-value <%s>
Returns variable value 
@deffnx primitive 
extern "C" {
/* Linkage: simple */
/* Linkage: passive */
scm_init_
%s (void)
/* Linkage: ltdlmod */
    return SCM_UNSPECIFIED;
/* Linkage: module */
    SWIG_init();
    scm_c_export(%sNULL);
/* Linkage: hobbit */
_slash_
(define-module (%s))
(define-module (%s))
(export %s)
        
(export %s)
gswig_
(define-class 
(<swig>)
new-
  #:new-function 
_swig_guile_setgoopsclass
(SCM cl) 
static SCM 
#define FUNC_NAME %s
#undef FUNC_NAME
(%s%s %s)
 #:allocation #:virtual
 obj))
-get
 obj value))
-set
   #:getter 
   #:accessor 
beforereturn
return_nothing_doc
return_one_doc
return_multi_doc
goops
three
four
five
seven
eight
nine
eleven
twelve
*** Unable to open 'guile_scm_run.swg
Guile Options (available with -guile)
     -emitsetters            - Emit procedures-with-setters for variables
                               and structure slots.
     -emitslotaccessors      - Emit accessor methods for all GOOPS slots
     -exportprimitive        - Add the (export ...) code from scmstub into the
                               GOOPS file.
     -goopsprefix <prefix>   - Prepend <prefix> to all goops identifiers
     -Linkage <lstyle>       - Use linkage protocol <lstyle> (default `simple')
                               Use `module' for native Guile module linking
                               (requires Guile >= 1.5.0).  Use `passive' for
                               passive linking (no C-level module-handling code),
                               `ltdlmod' for Guile's old dynamic module
                               convention (Guile <= 1.4), or `hobbit' for hobbit
                               modules.
     -onlysetters            - Don't emit traditional getter and setter
                               procedures for structure slots,
                               only emit procedures-with-setters.
     -package <name>         - Set the path of the module to <name>
                               (default NULL)
     -prefix <name>          - Use <name> as prefix [default "gswig_"]
     -procdoc <file>         - Output procedure documentation to <file>
     -procdocformat <format> - Output procedure documentation in <format>;
                               one of `guile-1.4', `plain', `texinfo'
     -proxy                  - Export GOOPS class definitions
     -primsuffix <suffix>    - Name appended to primitive module when exporting
                               GOOPS classes. (default = "primitive")
     -scmstub                - Output Scheme file with module declaration and
                               exports; only with `passive' and `simple' linkage
     -useclassprefix         - Prepend the class name to all goops identifiers
Deprecated command line option: -gh. Wrappers are always generated for the SCM interface. See documentation for more information regarding the deprecated GH interface.
Deprecated command line option: -scm. Wrappers are always generated for the SCM interface. See documentation for more information regarding the deprecated GH interface.
guile: GOOPS support requires passive or module linkage
guile: Warning: -exportprimitive only makes sense with passive linkage without a scmstub.
    if (%s != SCM_UNDEFINED) {
SWIG_Guile_MarkPointerDestroyed($input);
SWIG_Guile_GetArgs (arg, rest, %d, %d, "%s");
scm_c_define_gsubr("%s", 0, 0, 1, (swig_guile_proc) %s_rest);
scm_c_make_gsubr("%s", %d, %d, 0, (swig_guile_proc) %s);
scm_c_define_gsubr("%s", %d, %d, 0, (swig_guile_proc) %s);
("%s", scm_make_procedure_with_setter(getter, setter));
((swig_guile_clientdata *)(SWIGTYPE%s->clientdata))->destroy = (guile_destructor) %s;
int argc = SWIG_Guile_GetArgs (argv, rest, %d, %d, "%s");
scm_misc_error("%s", "No matching method for generic function `%s'", SCM_EOL);
scm_c_define_gsubr("%s", 0, 0, 1, (swig_guile_proc) %s);
SWIGUNUSED int gswig_list_p = 0
scm_c_define_gsubr("%s", 0, %d, 0, (swig_guile_proc) %s);
scm_c_define("%s", %s(SCM_UNDEFINED));
Get or set the value of the C variable, 
If NEW-VALUE is provided, set C variable to this value.
{ SCM p = scm_c_define_gsubr("%s", 0, 1, 0, (swig_guile_proc) %s);
("%s", scm_make_procedure_with_setter(p, p)); }
    scm_register_module_xxx ("%s", (void *) SWIG_init);
static void SWIG_init_helper(void *data)
    scm_c_define_module("%s",
      SWIG_init_helper, NULL);
(use-modules (oop goops) (Swig common))
(use-modules ((%s-%s) :renamer (symbol-prefix-proc 'primitive:)))
static swig_guile_clientdata _swig_guile_clientdata%s = { NULL, SCM_EOL };
, (void *) &_swig_guile_clientdata
  #:metaclass <swig-metaclass>
->clientdata))->goops_class = cl;
  ((swig_guile_clientdata *)(SWIGTYPE
scm_c_define_gsubr("%s", 1, 0, 0, (swig_guile_proc) %s);
   #:slot-ref (lambda (obj) (
   #:slot-set! (lambda (obj value) (
   #:slot-set! (lambda (obj value) (error "Immutable slot"))
#ifndef SWIGGUILE
#define SWIGGUILE
#endif
#define SWIG_GUILE_INIT_STATIC extern
#define SWIG_GUILE_INIT_STATIC static
SWIG_GUILE_INIT_STATIC void
SWIG_init (void);
#ifdef __cplusplus
extern "C" {
#endif
5GUILE
SWIGJAVA 1
java.swg
-nopgcpp
-jnic
-nofinalize
-jnicpp
java:throwslist
 throws %s
directordisconnect
$*javaclassname
$&javaclassname
%s:throws
feature:java:methodmodifiers
tmap:jstype
tmap:javain
$javainput
tmap:javain:pre
tmap:javain:post
tmap:jtype
tmap:jtype:nopgcpp
tmap:javain:pgcppname
tmap:javaout
$jnicall
jself
qualifier
, this
jresult = 0
(JNIEnv *jenv, jclass jcls
    (void)jenv;
    (void)jcls;
tmap:jni
, %s %s_
, jobject %s_
    (void)%s_;
tmap:newfree
tmap:ret
swig_module_init
imclass_fdesc
imclass_method
  { "%s", "%s" }
namespace Swig {
  namespace {
    jclass jclass_%s = NULL;
static struct {
  const char *method;
  const char *signature;
} methods[%d] = {
int i
change_ownership
tmap:%s:%s
$methodname
No %s typemap for %s
 implements 
 extends 
javabase
tmap:javabase:replace
tmap:javabase:notderived
javainterfaces
javaimports
javabody_derived
javabody
javaclassmodifiers
 $javaclassname
javadestruct_derived
javadestruct
tmap:javadestruct:methodname
javafinalize
%s.%s(this, swigCPtr, false)
%s.%s(this, swigCPtr, true)
directorowner_release
directorowner_take
javacode
    jlong baseptr = 0;
    
SWIGEXPORT jlong JNICALL 
 **)&baseptr = argp1 ? new 
 **)&jarg1;
    *(
 **)&baseptr = *(
javapackage
$packagepath
$packagepath/
swigjobj
tmap:directorin:descriptor
jenv
swigjnienv(this)
JNIEnvWrapper
swigjnienv
= swigjnienv.getJNIEnv()
JNIEnv *
= (jobject) NULL
jobject
if (!swig_override[%d]) {
tmap:javadirectorin
$jniinput
, %s %s
jself.%s(%s)
tmap:javadirectorout
$javacall
    return %s;
imclass_methodidx
feature:director:except
if ($error) {
$directorthrowshandlers
tmap:directorthrows
swigerror
$error
tmap:directorout
tmap:directorin:nouse
%s::%s(JNIEnv *jenv) : %s {
    %s(JNIEnv *jenv);
JNIEnv
arg:byname
director:prefix_args
static jclass baseclass
const char *mname;
const char *mdesc;
jmethodID base_methid;
} methods[] = {
{ "%s", "%s", NULL }
if (!baseclass) {
if (!baseclass) return;
protected:
  swig_override[i] = false;
  if (derived) {
    jenv->ExceptionClear();
      return false;
Swig::Director(jenv)
feature:java:const
  %s final static %s %s = 
feature:java:constvalue
%s.swigToEnum(%s.%s());
%s.%s.%s.%s
%s%s.java
$javaclazzname
feature:javadowncast
javaconstruct
feature:java:enum
../../Source/Modules/java.cxx
$static 
jniclassbase
jniclasspackage
Java_%s%s_%%f
jniclassclassmodifiers
jniclasscode
jniclassimports
jniclassinterfaces
moduleimport
moduleinterface
modulemethodmodifiers
allshadowimport
allshadowcode
allshadowbase
allshadowinterface
allshadowclassmodifiers
jniclassname
%sJNI
%sConstants
package %s.%s;
package %s;
package %s;
  static {
    swig_module_init();
public interface %s {
extends %s 
CallStaticByteMethod
CallStaticCharMethod
CallStaticDoubleMethod
CallStaticFloatMethod
CallStaticIntMethod
CallStaticLongMethod
CallStaticObjectMethod
CallStaticShortMethod
CallStaticVoidMethod
CallStaticBooleanMethod
Deprecated command line option: %s. Proxy classes are now generated by default.
Deprecated command line option: -jnic. C JNI calling convention now used when -c++ not specified.
Deprecated command line option: -nofinalize. Use the new javafinalize typemap instead.
Deprecated command line option: -jnicpp. C++ JNI calling convention now used when -c++ specified.
tmap:directordisconnect:methodname
  swig_disconnect_director_self("
The nspace feature is used on '%s' without -package. The generated code may not compile as Java does not support types declared in a named package accessing types declared in an unnamed package.
No jstype typemap defined for %s
No javain typemap defined for %s
No javaout typemap defined for %s
if (getClass() == %s.class) %s; else %s
(getClass() == %s.class) ? %s : %s
Covariant return types not supported in Java. Proxy method will return %s.
No jni typemap defined for %s
No jtype typemap defined for %s
  public final static native %s %s(
    jmethodID director_method_ids[%d];
SWIGEXPORT void JNICALL Java_%s%s_%s(JNIEnv *jenv, jclass jcls) {
Swig::jclass_%s = (jclass) jenv->NewGlobalRef(jcls);
if (!Swig::jclass_%s) return;
for (i = 0; i < (int) (sizeof(methods)/sizeof(methods[0])); ++i) {
  Swig::director_method_ids[i] = jenv->GetStaticMethodID(jcls, methods[i].method, methods[i].signature);
  if (!Swig::director_method_ids[i]) return;
  public final static native void %s(%s obj, long cptr, boolean mem_own, boolean weak_global);
SWIGEXPORT void JNICALL Java_%s%s_%s(JNIEnv *jenv, jclass jcls, jobject jself, jlong objarg, jboolean jswig_mem_own, jboolean jweak_global) {
  %s *obj = *((%s **)&objarg);
    director->swig_connect_director(jenv, jself, jenv->GetObjectClass(jself), (jswig_mem_own == JNI_TRUE), (jweak_global == JNI_TRUE));
  public final static native void %s(%s obj, long cptr, boolean take_or_release);
SWIGEXPORT void JNICALL Java_%s%s_%s(JNIEnv *jenv, jclass jcls, jobject jself, jlong objarg, jboolean jtake_or_release) {
    director->swig_java_change_ownership(jenv, jself, jtake_or_release ? true : false);
No %s method name attribute for %s
Warning for %s proxy: Base %s ignored. Multiple inheritance is not supported in Java.
The javabase typemap for proxy %s must contain just one of the 'replace' or 'notderived' attributes.
tmap:javadestruct_derived:methodname
tmap:javadestruct_derived:methodmodifiers
tmap:javadestruct:methodmodifiers
No methodname attribute defined in javadestruct%s typemap for %s
No methodmodifiers attribute defined in javadestruct%s typemap for %s.
throw new UnsupportedOperationException("C++ destructor does not have public access")
Warning for %s proxy: Base %s ignored. Multiple inheritance is not supported in Java. Perhaps you need one of the 'replace' or 'notderived' attributes in the javabase typemap?
  public final static native long %s(long jarg1);
(JNIEnv *jenv, jclass jcls, jlong jarg1) {
(*argp1) : 0;
    return baseptr;
 *argp1;
    (void)jenv;
    (void)jcls;
    argp1 = *(
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(
 **)&jarg1;
    return baseptr;
  public static %s %s(%s jself
No jni typemap defined for %s for use in %s::%s (skipping director method)
SWIG_JavaThrowException(JNIEnvWrapper(this).getJNIEnv(), SWIG_JavaDirectorPureVirtual, 
"Attempted to invoke pure virtual method %s::%s.");
swigjobj = swig_get_self(jenv);
if (swigjobj && jenv->IsSameObject(swigjobj, NULL) == JNI_FALSE) {
No javadirectorin typemap defined for %s for use in %s::%s (skipping director method)
No jtype typemap defined for %s for use in %s::%s (skipping director method)
jenv->%s(Swig::jclass_%s, Swig::director_method_ids[%s], %s);
jthrowable $error = jenv->ExceptionOccurred();
  jenv->ExceptionClear();$directorthrowshandlers
  throw Swig::DirectorException(jenv, $error);
No directorthrows typemap defined for %s
SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null upcall object in %s::%s ");
if (swigjobj) jenv->DeleteLocalRef(swigjobj);
No or improper directorin typemap defined for %s for use in %s::%s (skipping director method)
No or improper directorin typemap for type %s  for use in %s::%s (skipping director method)
Missing JNI descriptor in directorin typemap defined for %s for use in %s::%s (skipping director method)
void %s::swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global) {
if (swig_set_self(jenv, jself, swig_mem_own, weak_global)) {
baseclass = jenv->FindClass("%s");
baseclass = (jclass) jenv->NewGlobalRef(baseclass);
    bool swig_overrides(int n) {
      return (n < %d ? swig_override[n] : false);
    Swig::BoolArray<%d> swig_override;
bool derived = (jenv->IsSameObject(baseclass, jcls) ? false : true);
for (int i = 0; i < %d; ++i) {
  if (!methods[i].base_methid) {
    methods[i].base_methid = jenv->GetMethodID(baseclass, methods[i].mname, methods[i].mdesc);
    if (!methods[i].base_methid) return;
feature:director:assumeoverride
  swig_override[i] = derived;
    jmethodID methid = jenv->GetMethodID(jcls, methods[i].mname, methods[i].mdesc);
    swig_override[i] = (methid != methods[i].base_methid);
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
SWIGEXPORT jobject JNICALL %s(JNIEnv *jenv, jclass jcls, jlong jCPtrBase, jboolean cMemoryOwn) {
tmap:javaconstruct:directorconnect
"directorconnect" attribute missing in %s "javaconstruct" typemap.
  %s final static %s %s = new %s("%s", %s);
  %s final static %s %s = new %s("%s");
  %s final static %s %s = %s;
Deprecated pragma. Please use the moduleimports pragma.
Deprecated pragma. Please use the moduleinterfaces pragma.
Deprecated pragma. Please use %%javamethodmodifiers.
Deprecated pragma. Please use %%typemap(javaimports).
Deprecated pragma. Please use %%typemap(javacode).
Deprecated pragma. Please use %%typemap(javabase).
Deprecated pragma. Please use %%typemap(javainterfaces).
Deprecated pragma. Please use %%typemap(javaclassmodifiers).
#ifndef SWIGJAVA
#define SWIGJAVA
#endif
  private final static native void swig_module_init();
Java Options (available with -java)
     -nopgcpp        - Suppress premature garbage collection prevention parameter
     -noproxy        - Generate the low-level functional interface instead
                       of proxy classes
     -oldvarnames    - Old intermediary method names for variable wrappers
     -package <name> - Set name of the Java package to <name>
virtual int JAVA::enumDeclaration(Node*)
4JAVA
exports
$objecttype
SWIG_POINTER_OWN
jsresult
parent_namespace != 0
name_mangled
wrap:argc
thisObject
Illegal state.
info.Holder()
args.Holder()
feature:nspace
JS_veto_set_variable
-jsc
-node
-debug-codetemplates
SWIG_JAVASCRIPT_V8 1
javascript/v8
SWIG_JAVASCRIPT_JSC 1
javascript/jsc
BUILDING_NODE_EXTENSION 1
SWIGJAVASCRIPT 1
javascript.swg
globalfunctionHandler
is_static
destructorHandler
create_namespaces
register_namespaces
post-init
force_cpp
type_mangled
_wrap_new_veto_
ctor_dispatchers
is_abstract
is_immutable
a().char
has_templates
Could not find template %s
/* begin fragment("%s") */
/* end fragment("%s") */
delete [] (%s)
delete (%s)
js_dtoroverride
${classname_mangled}
$jswrapper
$jsfree
$jstype
${destructor_action}
js_dtor
$jsmangledname
js_getter
$jslocals
$jscode
js_setter
cppvalue
_wrapConstant_%s
js_function_dispatch_case
$jsargcount
js_function_dispatcher
$jsname
js_initializer_define
js_initializer
$jsregisterclasses
$jscreatenamespaces
$jsregisternamespaces
jsc_function_declaration
static_functions
member_functions
jsc_variable_declaration
$jsgetter
$jssetter
member_variables
static_variables
jsc_class_declaration
jsc_class_tables
$jsclassvariables
$jsclassfunctions
$jsstaticclassfunctions
$jsstaticclassvariables
js_veto_ctor
jsc_class_definition
jsc_class_inherit
$jsbaseclassmangled
jsc_class_noinherit
$jsmangledtype
$jsclass_inheritance
$jsctor
$jsdtor
jsc_class_registration
$jsnspace
jsc_nspace_declaration
$jsglobalvariables
$jsglobalfunctions
jsc_nspace_definition
jsc_nspace_registration
$jsparent
$jsv8nspaces
$jsv8classtemplates
$jsv8wrappers
$jsv8inheritance
$jsv8classinstances
$jsv8staticwrappers
$jsv8registerclasses
$jsv8registernspaces
jsv8_declare_class_template
&%s_clientData
jsv8_define_class_template
jsv8_create_class_instance
jsv8_inherit
$jsbaseclass
jsv8_register_class
jsv8_register_static_variable
jsv8_register_member_variable
jsv8_register_static_function
jsv8_register_member_function
jsv8_register_namespace
jsv8_create_namespace
js_ctor
js_overloaded_ctor
%sresult;
js_ctor_dispatch_case
js_ctor_dispatcher
$jsdispatchcases
js_function
js_overloaded_function
isextension
../../Source/Modules/javascript.cxx
Only one engine can be specified at a time.
Javascript Options (available with -javascript)
     -jsc                   - creates a JavascriptCore extension 
     -v8                    - creates a v8 extension 
     -node                  - creates a node.js extension 
     -debug-codetemplates   - generates information about the origin of code templates
SWIG Javascript: Unknown engine. Please specify one of '-jsc', '-v8' or '-node'.
Warning: unsupported wrapper function type
Warning: unsupported wrapper function type
memberconstantHandler:sym:name
Template code was null. Illegal input for template.
memberpointer:constant:wrap:name
virtual int JSEmitter::createNamespace(String*)
9JSEmitter
10JAVASCRIPT
10JSCEmitter
9V8Emitter
feature:emitonlychildren
Previous declaration of '%s'
../../Source/Modules/lang.cxx
Getattr(n, "sym:name")
Getattr(n, "name")
%s::~%s() throw () {
%s::~%s() {
constantWrapper   : %s = %s
feature:allowexcept
feature:exceptvar
?parms
feature:callback
feature:callback:name
callbackfunctionHandler
(%s (*)(%s))(%s)
%s -
?name
functionWrapper   : %s
           action : %s
r.p.
r.q(const
enumMissing
staticmemberfunctionHandler
feature:callback:staticname
staticmembervariableHandler
enumvalueDeclaration:sym:name
?type
handled_as_constructor
sym:scope
vmid
feature:unref
destructorDeclaration
constantDirective
rawvalue
%(escape)s
methodNode
fqdname
classDirectorMethods
returntype
Getattr(method, "returntype")
feature:del
feature:self:disown
SwigExplicit
&%s::%s
wrap:directormap
    using %s::%s;
copyconstructorHandler
$arg != 0
  $nondirector_new 
  $director_new 
!this_
SwigDirector_%s_%s
director:classname
has_default_constructor
feature:copyctor
other
copy_constructor_decl
feature:nodefaultdtor
allocate:destructor
f(%s).
feature:nodefaultctor
noattributefunction
feature:naturalvar
variableWrapper
?varget
?varset
globalin
(*%s)->%s
%s->%s
memberin
sym:cleanconstructor
constructorDeclaration
Previous declaration is %s
~destructor
__dummy_
nonpublic_%s%s
cDeclaration
extern "C" %s;
Unrecognized parse tree node type '%s'
'%s' is multiply defined in the generated target language module in scope '%s'.
'%s' is multiply defined in the generated target language module.
Can't apply (%s) to (%s).  Number of arguments don't match.
Can't apply (%s). No typemaps are defined.
The use of $source and $target in a typemap declaration is deprecated.
For typemaps related to argument input (in,ignore,default,arginit,check), replace
$source by $input and $target by $1.   For typemaps related to return values (out,
argout,ret,except), replace $source by $1 and $target by $result.  See the file
Doc/Manual/Typemaps.html for complete details.
%%typemap(except) is deprecated. Use the %%exception directive.
%%typemap(ignore) has been replaced by %%typemap(in,numinputs=0).
Deprecated typemap feature ($source/$target).
Multiple-input typemaps (numinputs > 1) not supported by this target language module.
Can't copy typemap. Number of types differ.
Can't copy typemap (%s) %s = %s
LANGUAGE SYMBOLS start  =======================================
LANGUAGE SYMBOLS finish =======================================
===================================================
if (director) director->swig_disown();
Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
Unknown target '%s' for %%insert directive.
Director class '%s' is abstract, abstract method '%s' is not accesible, maybe due to multiple inheritance or 'nodirector' feature
Director class '%s' is abstract, abstract method '%s' is private
Use of an illegal destructor name '%s' in %%extend is deprecated, the destructor name should be '%s'.
Illegal destructor name %s. Ignored.
Director base class %s has no virtual destructor.
if ( $comparison ) { /* subclassed */
Can't generate wrappers for unnamed struct/class.
Can't wrap class %s unless renamed to a valid identifier.
dangerous, use %%nodefaultctor, %%nodefaultdtor instead.
Bad value for attributefunction. Expected "fmtget:fmtset".
Director class '%s' can't be constructed
Overloaded constructor ignored.  %s
Use of an illegal constructor name '%s' in %%extend is deprecated, the constructor name should be '%s'.
Function %s must have a return type. Ignored.
%%template() contains no name. Template method ignored: %s
Overloaded declaration ignored.  %s
Can't wrap '%s' unless renamed to a valid identifier.
virtual int Language::classDirectorMethods(Node*)
virtual int Language::enumDeclaration(Node*)
Language::Language()
10Dispatcher
8Language
swigluarun.h
-nomoduleglobal
-elua
-eluac
-no-old-metatable-bindings
-squash-bases
-elua-emulate
SWIGLUA 1
lua.swg
luarun.swg
/*This is only emulation!*/
*** Unable to open '%s'
../../Source/Modules/lua.cxx
lua_name
int SWIG_arg = 0
SWIG_arg
(lua_State* L) {
static int 
lua:ignore_args
tmap:in:checkfn
if(!%s(L,%s))
if(lua_gettop(L)>=%s){%s}
return SWIG_arg;
if(0) SWIG_fail;
fail:
lua_error(L);
return %s(L);
argc = lua_gettop(L);
self,args
$args
"    %s\n"
lua_error(L);return 0;
int argv[%d]={1
  %s = %s
  %s = <mapping>
  %s = <sequence>
  %s = <unknown>
lua:cdata
swig_%s
swig_%s_attributes
static swig_lua_attribute 
attributes:name
attributes:decl
swig_%s_methods
const LUA_REG_TYPE 
static swig_lua_method 
methods:name
methods:decl
swig_%s_constants
static swig_lua_const_info 
constants:name
constants:decl
swig_%s_classes
static swig_lua_class* 
classes:name
classes:decl
swig_%s_namespaces
static swig_lua_namespace* 
namespaces:name
namespaces:decl
swig_%s_get
get:name
get:decl
swig_%s_set
set:decl
swig_%s_meta
metatable
metatable:name
metatable:decl
rawGetCArraysHash(nspace)
lua:no_reg
{LSTRKEY("
SwigModule
consttab
$nsname
s_const_tab
    %s,
lua_constantMember
class_static_nspace == 0
full_proxy_class_name == 0
instance_cls
lua:no_namespaces
lua:no_classes
lua:class_instance
%s%sSwigStatic
static_cls
lua:class_static
wrap_class
class_hash
cls_methods
swig_delete_%s
(void *obj) {
) obj;
    delete (
    free((char *) obj);
constructor_name
_proxy_%s
(lua_State *L) {
lua_pushcfunction(L,
assert(lua_istable(L,1));
assert(!lua_isnil(L,-1));
static_cls_metatable_tab
ns_methods_tab
, LFUNCVAL(
free_
carrays_hash
lua:closed
    {0,0,0}
{LNILKEY, LNILVAL}
    {0,0,0,0,0,0}
{LSTRKEY("const"), LROVAL(
{LNILKEY, LNILVAL}
    {0,0}
    0
{LSTRKEY(".get"), LROVAL(
{LSTRKEY(".set"), LROVAL(
{LSTRKEY(".fn"), LROVAL(
static_cls_cname
{LSTRKEY(".static"), LROVAL(
instance_cls_metatable_name
static swig_lua_namespace 
mangled_full_proxy_class_name
base_class
base_class_names
_bases[] = {
static swig_lua_class *swig_
_base_names[] = {
static const char *swig_
", "
 = { "
", &SWIGTYPE
, %s, %s, &%s
"%s *",
!current[NO_CPP]
SWIG_Lua_set_immutable
%s{ "%s", %s, %s },
*lua:name
__unm
initbeforefunc
luacode
#define SWIG_name      "%s"
top_scope
ki.item
Lua Options (available with -lua)
     -elua           - Generates LTR compatible wrappers for smaller devices running elua
     -eluac          - LTR compatible wrappers in "crass compress" mode for elua
     -elua-emulate   - Emulates behaviour of eLua. Useful only for testing.
                       Incompatible with -elua/-eluac options.
     -nomoduleglobal - Do not register the module name as a global variable 
                       but return the module table from calls to require.
     -no-old-metatable-bindings
                     - Disable support for old-style bindings name generation, some
                       old-style members scheme etc.
     -squash-bases   - Squashes symbols from all inheritance tree of a given class
                       into itself. Emulates pre-SWIG3.0 inheritance. Insignificantly
                       speeds things up, but increases memory consumption.
Cannot have -elua-emulate with either -eluac or -elua
#define SWIG_LUA_TARGET SWIG_LUA_FLAVOR_ELUA
#define SWIG_LUA_ELUA_EMULATE
#define SWIG_LUA_TARGET SWIG_LUA_FLAVOR_ELUAC
#define SWIG_LUA_TARGET SWIG_LUA_FLAVOR_LUA
addSymbol(%s to scope %s) failed
SWIG_check_num_args("%s",%d,%d)
if(lua_gettop(L)>=%s && !%s(L,%s))
 SWIG_fail_arg("%s",%s,"%s");
SWIG_Lua_pusherrstring(L,"Wrong arguments for overloaded function '%s'\n"
"  Possible C/C++ prototypes are:\n"%s);
lua:class_instance:static_hash
lua:class_static:instance_hash
lua_call(L,lua_gettop(L)-1,1);
lua_replace(L,1); /* replace our table with real constructor */
    {LSTRKEY("__call"), LFUNCVAL(%s)},
GetFlag(carrays_hash, "lua:closed") == 0
{LSTRKEY("__metatable"), LROVAL(
{LSTRKEY("__disown"), LFUNCVAL(SWIG_Lua_class_disown)},
{LSTRKEY("__index"), LFUNCVAL(SWIG_Lua_class_get)},
{LSTRKEY("__newindex"), LFUNCVAL(SWIG_Lua_class_set)},
{LSTRKEY("__index"), LFUNCVAL(SWIG_Lua_namespace_get)},
{LSTRKEY("__newindex"), LFUNCVAL(SWIG_Lua_namespace_set)},
{LSTRKEY("__gc"), LFUNCVAL(SWIG_Lua_class_destruct)},
{LSTRKEY(".instance"), LROVAL(
static swig_lua_class _wrap_class_
, swig_%s_bases, swig_%s_base_names };
%s{LSTRKEY("%s"), LFUNCVAL(%s)},
lua_staticmembervariableHandler
lua_staticmemberfunctionHandler
#ifndef SWIGLUA
#define SWIGLUA
#endif
#define SWIG_LUA_NO_MODULE_GLOBAL
#define SWIG_LUA_MODULE_GLOBAL
#define SWIG_LUA_SQUASH_BASES
#define SWIG_init      luaopen_%s
#define SWIG_init_user luaopen_%s_user
#define SWIG_LUACODE   luaopen_%s_luacode
void SWIG_init_user(lua_State* L)
/* exec Lua code if applicable */
SWIG_Lua_dostring(L,SWIG_LUACODE);
const char* SWIG_LUACODE=
  "%s";
void LUA::closeNamespaces(File*)
void LUA::registerMethod(Node*, String*, String*)
void LUA::registerMethod(Node*, bool, String*)
void LUA::registerVariable(Node*, bool, String*)
void LUA::printCArraysDefinition(String*, String*, File*)
void LUA::closeCArraysHash(String*, File*)
void LUA::registerClass(String*, String*)
virtual int LUA::classHandler(Node*)
void LUA::registerConstant(String*, String*)
virtual int LUA::constantWrapper(Node*)
virtual int LUA::variableWrapper(Node*)
int LUA::dispatchFunction(Node*)
virtual int LUA::functionWrapper(Node*)
Hash* LUA::getCArraysHash(String*, bool)
String* LUA::luaCurrentSymbolNSpace()
3LUA
../../Source/Modules/main.cxx
all_output_files
feature:
-nopreprocess
-verbose
-c++
__cplusplus __cplusplus
-c++out
-fcompact
-fvirtual
-fastdispatch
-nofastdispatch
-naturalvar
-directors
-dirprot
-nodirprot
-pcreversion
-small
-noruntime
-external-runtime
-make_default
-makedefault
-no_default
-nodefault
-nodefaultctor
-nodefaultdtor
-copyctor
-noexcept
-noextern
-addextern
-debug-template
-debug_template
-show_templates
-templatereduce
-notemplatereduce
-macroerrors
-swiglib
-fakeversion
-version
SWIG Version %s
x86_64-pc-linux-gnu
Compiled with %s [%s]
Configured options: %cpcre
http://www.swig.org
-copyright
Copyright (c) 1995-1998
Copyright (c) 1998-2005
University of Chicago
Copyright (c) 2005-2006
-features
-freeze
-includeall
-importall
-ignoremissing
-cpperraswarn
-nocpperraswarn
-cppext
-debug-typemap
-debug_typemap
-tm_debug
-debug-tmsearch
-debug-tmused
-MMD
-outdir
-outcurrentdir
-Wall
-Wallkw
-Werror
-Wextra
202,309,403,512,321,322
-debug-symtabs
-debug-symbols
-debug-csymbols
-debug-lsymbols
-debug-tags
-dump_tags
-debug-top
-debug-module
-dump_tree
-dump_top
-dump_module
-dump_parse_module
-dump_parse_top
-dump_xml
-xmlout
-nocontract
-browse
-debug-typedef
-dump_typedef
-debug-classes
-dump_classes
-debug-memory
-dump_memory
-Fstandard
-Fmicrosoft
SWIG 1
__STDC__
3.0.8
SWIG_VERSION 0x
len == 1 || len == 2
count == 3
SWIG_LIB
/usr/share/swig3.0
.%sswig_lib%s%s
./swig_lib
SWIGOPT%(upper)s
Language subdirectory: %s
Search paths:
swiglabels.swg
swigerrors.swg
swigrun.swg
runtime.swg
Handling checkout...
Preprocessing...
Unable to find file '%s'.
%%include <swig.swg>
%%include <allkw.swg>
%%include <%s>
%%include "%s"
%s_wrap.%s
  %s 
debug-top stage 1
debug-module stage 1
Processing types...
debug-top stage 2
debug-module stage 2
C++ analysis...
Processing nested classes...
debug-top stage 3
debug-module stage 3
Classes
------------
inputfile
.c++
.cpp
debug-top stage 4
debug-module stage 4
CCACHE_OUTFILES
%s_wrap.c
Generating wrappers...
-runtime, -noruntime command line options are deprecated.
dangerous, use -nodefaultctor, -nodefaultdtor instead.
-noextern command line option is deprecated; extern is no longer generated by default.
Please see %s for reporting bugs and further information
University of Utah and the Regents of the University of California
Arizona Board of Regents (University of Arizona)
General Options
     -addextern      - Add extra extern declarations
     -c++            - Enable C++ processing
     -co <file>      - Check <file> out of the SWIG library
     -copyctor       - Automatically generate copy constructors wherever possible
     -cpperraswarn   - Treat the preprocessor #error statement as #warning (default)
     -cppext <ext>   - Change file extension of generated C++ files to <ext>
                       (default is cxx, except for PHP which uses cpp)
     -copyright      - Display copyright notices
     -debug-classes  - Display information about the classes found in the interface
     -debug-module <n>- Display module parse tree at stages 1-4, <n> is a csv list of stages
     -debug-symtabs  - Display symbol tables information
     -debug-symbols  - Display target language symbols in the symbol tables
     -debug-csymbols - Display C symbols in the symbol tables
     -debug-lsymbols - Display target language layer symbols
     -debug-tags     - Display information about the tags found in the interface
     -debug-template - Display information for debugging templates
     -debug-top <n>  - Display entire parse tree at stages 1-4, <n> is a csv list of stages
     -debug-typedef  - Display information about the types and typedefs in the interface
     -debug-typemap  - Display typemap debugging information
     -debug-tmsearch - Display typemap search debugging information
     -debug-tmused   - Display typemaps used debugging information
     -directors      - Turn on director mode for all the classes, mainly for testing
     -dirprot        - Turn on wrapping of protected members for director classes (default)
     -D<symbol>      - Define a symbol <symbol> (for conditional compilation)
     -E              - Preprocess only, does not generate wrapper code
     -external-runtime [file] - Export the SWIG runtime stack
     -fakeversion <v>- Make SWIG fake the program version number to <v>
     -fcompact       - Compile in compact mode
     -features <list>- Set global features, where <list> is a comma separated list of
                       features, eg -features directors,autodoc=1
                       If no explicit value is given to the feature, a default of 1 is used
     -fastdispatch   - Enable fast dispatch mode to produce faster overload dispatcher code
     -Fmicrosoft     - Display error/warning messages in Microsoft format
     -Fstandard      - Display error/warning messages in commonly used format
     -fvirtual       - Compile in virtual elimination mode
     -help           - This output
     -I-             - Don't search the current directory
     -I<dir>         - Look for SWIG files in directory <dir>
     -ignoremissing  - Ignore missing include files
     -importall      - Follow all #include statements as imports
     -includeall     - Follow all #include statements
     -l<ifile>       - Include SWIG library file <ifile>
     -macroerrors    - Report errors inside macros
     -makedefault    - Create default constructors/destructors (the default)
     -M              - List all dependencies
     -MD             - Is equivalent to `-M -MF <file>', except `-E' is not implied
     -MF <file>      - Generate dependencies into <file> and continue generating wrappers
     -MM             - List dependencies, but omit files in SWIG library
     -MMD            - Like `-MD', but omit files in SWIG library
     -module <name>  - Set module name to <name>
     -MP             - Generate phony targets for all dependencies
     -MT <target>    - Set the target of the rule emitted by dependency generation
     -nocontract     - Turn off contract checking
     -nocpperraswarn - Do not treat the preprocessor #error statement as #warning
     -nodefault      - Do not generate default constructors nor default destructors
     -nodefaultctor  - Do not generate implicit default constructors
     -nodefaultdtor  - Do not generate implicit default destructors
     -nodirprot      - Do not wrap director protected members
     -noexcept       - Do not wrap exception specifiers
     -nofastdispatch - Disable fast dispatch mode (default)
     -nopreprocess   - Skip the preprocessor step
     -notemplatereduce - Disable reduction of the typedefs in templates
     -O              - Enable the optimization options: 
                        -fastdispatch -fvirtual 
     -o <outfile>    - Set name of C/C++ output file to <outfile>
     -oh <headfile>  - Set name of C++ output header file for directors to <headfile>
     -outcurrentdir  - Set default output dir to current dir instead of input file's path
     -outdir <dir>   - Set language specific files output directory to <dir>
     -pcreversion    - Display PCRE version information
     -small          - Compile in virtual elimination & compact mode
     -swiglib        - Report location of SWIG library and exit
     -templatereduce - Reduce all the typedefs in templates
     -v              - Run in verbose mode
     -version        - Display SWIG version number
     -Wall           - Remove all warning suppression, also implies -Wextra
     -Wallkw         - Enable keyword warnings for all the supported languages
     -Werror         - Treat warnings as errors
     -Wextra         - Adds the following additional warnings: 202,309,403,512,321,322
     -w<list>        - Suppress/add warning messages, eg -w401,+321 - see Warnings.html
     -xmlout <file>  - Write XML version of the parse tree to <file> after normal processing
Options can also be defined using the SWIG_FEATURES environment variable, for example:
  $ SWIG_FEATURES="-Wall"
  $ export SWIG_FEATURES
  $ swig -python interface.i
is equivalent to: 
  $ swig -Wall -python interface.i 
Note: 'swig -<lang> -help' displays options for a specific target language.
The -c++out option is for C input but C++ input has been requested via -c++
*** Please provide a filename for the external runtime
*** Unable to open 'swiglabels.swg'
*** Unable to open 'swigerrors.swg'
*** Unable to open 'swigrun.swg'
*** Unable to open 'runtime.swg'
Unable to locate '%s' in the SWIG library.
File '%s' already exists. Checkout aborted.
'%s' checked out from the SWIG library.
Unable to find option or file '%s', 
use 'swig -help' for more information.
Use of the include path to find the input file is deprecated and will not work with ccache. Please include the path when specifying the input file.
%%include(maininput="%s") "%s"
Cannot generate dependencies with -nopreprocess
Starting language-specific parse...
Processing unnamed structs...
No module name specified using %%module or -module.
Missing input file in preprocessed output.
Failed to write list of output files to the filename '%s' specified in CCACHE_OUTFILES environment variable - 
int SWIG_main(int, char**, Language*)
List* SWIG_output_files()
const String* SWIG_output_directory()
SWIGMODULA3 1
modula3.swg
-generateconst
-generaterename
-generatetypemap
tmap:%s:numinputs
tmap:%s:next
constnumeric
%s, 
:= %s
%%rename("%s") %s;
modula3:enumitem:name
modula3:constset:name
modula3:constint:name
 = %s{
int:int
int:set
CARDINAL
set:int
modula3:constset:type
modula3:constset:set
modula3:constset:base
modula3:constset:conv
modula3:constint:type
modula3:constint:conv
16_%s
8_%s
modula3:enumitem:enum
modula3:enumitem:conv
srcstyle
underscore
%s:int
constint
constset
%s:set
$&m3classname
m3wraptype
m3rawtype
<* EXTERNAL *> VAR %s: %s;
Argument '%s' twice.
m3base
m3classmodifiers
m3imports
 class $m3classname
    swigCPtr = cPtr;
  private IntPtr swigCPtr;
m3destruct_derived
m3destruct
tmap:m3destruct:methodname
m3finalize
  public 
m3code
m3getcptr
$baseclass
", EntryPoint="Modula3_
  [DllImport("
(long objectRef) {
$imbaseclass
$imclazzname
m3interfaces_derived
m3ptrconstructormodifiers
m3interfaces
 RAISES {%s
%s:import
m3rawintype
m3rawrettype
modula3:rawname
tmap:rawinname
tmap:m3rawinmode
tmap:m3rawintype:next
cresult = 0
cresult
m3arg%d
c:wrapname
tmap:name
    return cresult;
m3in
m3out
m3varin
m3varout
m3wrapintype
tmap:m3wrapinmode
tmap:m3wrapindefault
autoname
inout
tmap:m3wrapintype:next
tmap:m3wrapargdir
feature:modula3:multiretval
m3wrapretraw
m3wrapretname
m3wraprettype
m3wrapretvar
m3wrapretconv
m3wrapretcheck
tmap:m3wrapinname
tmap:m3wrapoutname
tmap:m3wrapouttype
tmap:m3wrapouttype:next
%sResult
%s =
RECORD
%sEND;
tmap:m3wrapargconst
tmap:m3wrapargconst:next
tmap:m3wrapargvar
tmap:m3wrapargvar:next
tmap:m3wrapinconv
tmap:m3wrapinconv:next
tmap:m3wrapincheck
tmap:m3wrapincheck:next
m3outarg
tmap:m3wrapargraw
$output
tmap:m3wrapargraw:next
tmap:m3wrapoutcheck
tmap:m3wrapoutcheck:next
tmap:m3wrapoutconv
tmap:m3wrapoutconv:next
tmap:m3wrapfreearg
tmap:m3wrapfreearg:next
PROCEDURE %s (%s)
%s%s%s%s%s
%sFINALLY
%sEND;
$rawcall
$vartype
$var
RETURN %s;
modula3:functype
modula3:funcname
accessor
modula3:setname
modula3:getname
IMPORT %s
 AS %s
%s%s.m3
modula3:method:%s
%s <: ADDRESS;
%s <: %s;
%s =
%s BRANDED OBJECT
Tacocat
cxxObj:%s.%s;
modula3:override
OVERRIDES
Unknown type constructor %s
%sPublic
ROOT
METHODS
 : this(
), true)
  public static %s %s {
  public %s %s {
modula3:method:public
set%s(%s val:%s);
set%s := %s;
get%s():%s;
get%s := %s;
  (* base method *)
%s(%s)%s%s;%s
unsafe
makesetofenum
%sSet = SET OF %s;
Unrecognized pragma <%s>.
m3rawintf
m3rawimpl
m3wrapintf
m3wrapimpl
m3rawname
%sRaw
Modula3_%f
%sm3makefile
import("libm3")
module("%s")
module("%s")
library("%s")
library("m3%s")
%s%s.i3
INTERFACE %s;
MODULE %s;
INTERFACE %s;
%s = {
Dummy%d
UNSAFE 
BEGIN
END %s.
    swigCPtr = IntPtr.Zero;
  protected $m3classname() {
#include <cstdio>
#include <stdio.h>
#include "%s"
  return 0;
%s.c
%s.i
Protected
Private
CONST
TYPE
REVEAL
No '%s' typemap defined for type '%s'
Feature 'constnumeric' is necessary to obtain value of %s.
The feature 'constnumeric' of %s specifies value <%s> which is not an integer constant.
  printf("%%%%constnumeric(%%Lg) %s;\n", (long double)%s);
%%typemap("m3wrapintype") %s %%{%s%%}
%%typemap("m3rawintype") %s %%{%s%%}
Unknown integer conversion method <%s>.
There is no enumeration <%s> as needed for the set.
Enumeration <%s> has no value <%s>.
Feature <%s> of %s did already exist.
The string <%s> does not denote a numeric value.
The value <%s> is already assigned to <%s>.
Unknown name conversion tag <%s> with value <%s>.
Expected <enumeration>, got <%s>.
Expected <ordinal type>, got <%s>.
Expected <set type,base type>, got <%s>.
Unknown C identifier style <%s>.
Unknown identification tag <%s> with value <%s>.
  protected bool swigCMemOwn;
    swigCMemOwn = cMemoryOwn;
: base($imclassname.$m3classnameTo$baseclass(cPtr), cMemoryOwn) {
 $m3classname(IntPtr cPtr, bool cMemoryOwn) 
  protected $m3classname() : this(IntPtr.Zero, false) {
tmap:m3destruct_derived:methodname
No methodname attribute defined in m3destruct%s typemap for %s
throw new MethodAccessException("C++ destructor does not have public access")
$m3classnameTo$baseclass(IntPtr objectRef);
  public static extern IntPtr 
    long baseptr = 0;
    *($cbaseclass **)&baseptr = *($cclass **)&objectRef;
    return baseptr;
SWIGEXPORT long Modula3_$imclazznameTo$imbaseclass
Warning for %s proxy: Base %s ignored. Multiple inheritance is not supported in Modula 3.
Malformed import '%s' for typemap '%s' defined for type '%s'
<* EXTERNAL %s *>
PROCEDURE %s (
feature:modula3:methodmodifiers
m3wrapargdir typemap expect values: in, out, inout
Typemap m3wrapargdir set to 'out' for %s implies a RETURN value, but the routine %s has already one.
Use %%multiretval feature.
%s%s%s%sBEGIN
%s%sEND %s;
(*******************************************************************************
*******************************************************************************)
%s = UNTRACED BRANDED REF RECORD (*Dummy*) END;
#ifndef SWIGMODULA3
#define SWIGMODULA3
#endif
%% automatically generated quake file for %s
 $m3classname(IntPtr cPtr, bool bFutureUse) {
int main (int argc, char *argv[]) {
/*This progam must work for floating point numbers and integers.
  Thus all numbers are converted to double precision floating point format.*/
/* This file was generated from %s
   by SWIG with option -generaterename. */
/* This file was generated from %s
   by SWIG with option -generatetypemap. */
Modula 3 Options (available with -modula3)
     -generateconst <file>   - Generate code for computing numeric values of constants
     -generaterename <file>  - Generate suggestions for %rename
     -generatetypemap <file> - Generate templates for some basic typemaps
     -oldvarnames            - Old intermediary method names for variable wrappers
7MODULA3
swigmzrun.h
mzrun.swg
-declaremodule
-noinit
-dynamic-load
SWIGMZSCHEME 1
mzscheme.swg
caller
static Scheme_Object *
_function_loaded
_the_function
(*caller)(%s)
int lenv = 1
lenv
caller=_the_function;
values[0]
static Scheme_Object *
if (argc) {
return swig_result;
", scheme_make_prim_w_arity(
scheme_add_global("
), menv);
Scheme_Object *swig_result
_wrap_const_%s
static %s = 
_field_names[] = { 
Scheme_Object *obj;
int i = 0;
_field_names_cnt];
, i, fields);
_swig_struct_type_
return obj;
_field_names)/sizeof(char*))
#define  _swig_struct_
_field_names);
(char**) _swig_struct_
_field_names_cnt,
fields[i++]
fields[i++] = 
)&((ptr)->
_swig_convert_struct_
	return scheme_void;
	return scheme_reload(env);
*** Unable to open 'mzrun.swg'
Mzscheme Options (available with -mzscheme)
     -declaremodule                         - Create extension that declares a module
     -dynamic-load <library>,[library,...]  - Do not link with these libraries, dynamic load
                                              them
     -noinit                                - Do not emit scheme_initialize, scheme_reload,
                                              scheme_module_name functions
     -prefix <name>                         - Set a prefix <name> to be prepended to all names
int argc, Scheme_Object **argv
static int _function_loaded=(1==0)
static void *_the_function=NULL
Scheme_Object *values[MAXVALUES]
if (!_function_loaded) { _the_function=mz_load_function("%s");_function_loaded=(1==1); }
if (!_the_function) { scheme_signal_error("Cannot load C function '%s'"); }
return SWIG_MzScheme_PackageValues(lenv, values);
SWIG_TypeClientData(SWIGTYPE%s, (void *) %s);
scheme_add_global("%s", scheme_make_prim_w_arity(%s,"%s",%d,%d),menv);
(int argc, Scheme_Object **argv) {
scheme_signal_error("No matching function for overloaded '%s'");
static Scheme_Object *%s(int argc, Scheme_Object** argv) {
Unsupported variable type %s (ignored).
static const char *_swig_struct_
static Scheme_Object *_swig_convert_struct_
Scheme_Object *fields[_swig_struct_
obj = scheme_make_struct_instance(
static Scheme_Object *_swig_struct_type_
_field_names_cnt (sizeof(_swig_struct_
 = SWIG_MzScheme_new_scheme_struct(menv, "
Unsupported member variable type %s (ignored).
#ifndef SWIGMZSCHEME
#define SWIGMZSCHEME
#endif
#define SWIG_MZSCHEME_CREATE_MENV(env) scheme_primitive_module(scheme_intern_symbol("%s"), env)
#define SWIG_MZSCHEME_CREATE_MENV(env) (env)
	scheme_finish_primitive_module(menv);
Scheme_Object *scheme_initialize(Scheme_Env *env) {
mz_set_dlopen_libraries("%s");
Scheme_Object *scheme_module_name(void) {
   return scheme_intern_symbol((char*)"%s");
   return scheme_make_symbol((char*)"%s");
8MZSCHEME
swigocamlrun.h
ocaml.swg
    virtual %s;
tmap:ignore
tmap:ignore:next
nc_tmp_%s
= const_cast< %s >(%s)
director_%s
Swig::Director *
= Val_unit
CAML_VALUE
if (!%s) {
%s = %s->swig_get_self();
swig_result = Val_unit;
args = Val_unit;
CAMLreturn_type(*c_result);
obj%d
-where
-suffix
SWIGOCAML 1
ocaml.i
feature:symname
feature:enumvname
_xx_plus
_xx_minus
_xx_ldbrace
_xx_rdbrace
_xx_not
_xx_mod
_xx_xor
_xx_star
_xx_amp
_xx_or
_xx_lparen
_xx_rparen
_xx_lbrace
_xx_rbrace
_xx_bnot
_xx_equals
_xx_slash
_xx_dot
SWIG_Field(args,0)
if (args != Val_int(0)) {
varin/in
varout/out
 | `%s -> _%s C_void
CAML_VALUE swig_result
let %s clst = _%s clst
val %s : c_obj -> c_obj
    "~", %s ;
    "%s", %s ;
SWIGEXT CAML_VALUE 
CAML_VALUE args
CAMLparam1(args)
int _v = 0
CAML_VALUE *argv
caml_list_nth(args,%d)
$ntype
free(argv);
CAMLreturn(swig_result);
Swig::Director *director = 0
bool upcall = false
upcall = (director);
qualified:name
public:
_sizeof ())) ;
(create_class "
 args) ;
", (fun args -> 
   "::
$classname
$normalized
$realname
$baselist
$classbody
(*Stream:
ocaml:ctor
feature:enumvalue
SWIG_ENUM_
| `%s
| `%s -> (match y with
| `%s -> C_enum (
`Int y)
mlitail
A Santa lives evil at NASA
mltail
classtemplate
class_ctors
%n%v__set__
%n%v__get__
#define SWIG_MODULE "%s"
let module_name = "%s"
val module_name : string
.mli
*** Unable to open 'ocaml.swg'
let _ = Callback.register "%s_marker" (`%s)
CAMLparam0();
SWIG_CAMLlocal2(swig_result,args)
Swig::DirectorPureVirtualException::raise("Attempted to invoke pure virtual method %s::%s");
Target language argument '%s' discards const in director method %s::%s.
%s = dynamic_cast<Swig::Director *>(%s);
%s = SWIG_NewPointerObj(%s, SWIGTYPE%s, 0);
swig_result = caml_swig_alloc(1,C_list);
SWIG_Store_field(swig_result,0,args);
args = swig_result;
swig_result = Val_unit;
swig_result = callback3(*caml_named_value("swig_runmethod"),swig_get_self(),copy_string("%s"),args);
CAMLreturn_type((%s)c_result);
Unable to use type %s as a function argument in director method %s::%s (skipping method).
  CAML_VALUE error = *caml_named_value("director_except");
Ocaml Options (available with -ocaml)
     -oldvarnames    - Old intermediary method names for variable wrappers
     -prefix <name>  - Set a prefix <name> to be prepended to all names
     -suffix <name>  - Deprecated alias for general option -cppext
     -where          - Emit library location
swig: warning: -suffix option deprecated.  SWIG 3.0.4 and later provide a -cppext option which should be used instead.
Unable to handle type %s (%s).
external _%s : c_obj -> Swig.c_obj = "%s" 
val _%s : c_obj -> Swig.c_obj
 if y = (get_int (_%s C_void)) then `%s else
external _%s : c_obj -> c_obj = "%s"
SWIGEXT CAML_VALUE %s(CAML_VALUE args) {
Fatal error. SwigType_del_pointer applied to non-pointer.
memberfunctionHandler:sym:name
    "%s", (fun args -> if args = (C_list [ raw_ptr ]) then %s args else %s args) ;
    "%s", (fun args -> if args = (C_list [ raw_ptr ]) then %s args else C_void) ;
SWIG_CAMLlocal2(swig_result,rv)
int argc = caml_list_length(args)
argv = (CAML_VALUE *)malloc( argc * sizeof( CAML_VALUE ) );
for( i = 0; i < argc; i++ ) {
  argv[i] = caml_list_nth(args,i);
if (caml_list_length(args) > %d) {
swig_result = caml_list_append(swig_result,rv);
free(argv);
CAMLreturn(%s(args));
(CAML_VALUE args) {
  CAMLparam1(args);
  int i;
  int argc = caml_list_length(args);
failwith("No matching function for overloaded '%s'");
external %s_f : c_obj list -> c_obj list = "%s" ;;
let %s arg = match %s_f (fnhelper arg) with
  [] -> C_void
| [x] -> (if %s then Gc.finalise 
  (fun x -> ignore ((invoke x) "~" C_void)) x) ; x
| lst -> C_list lst ;;
director = dynamic_cast<Swig::Director *>(arg1);
  failwith("accessing abstract class or protected constructor"); 
SwigDirector_%s::SwigDirector_%s(CAML_VALUE self) : Swig::Director(self) { }
    SwigDirector_%s(CAML_VALUE self);
%s::%s: %s, Swig::Director(self) { }
SWIGEXT CAML_VALUE _wrap_%s_sizeof( CAML_VALUE args ) {
    CAMLparam1(args);
    CAMLreturn(Val_int(sizeof(%s)));
external __%s_sizeof : unit -> int = "_wrap_%s_sizeof"
"sizeof" , (fun args -> C_int (__
let _ = Callback.register "%s_marker" (`%s)
let _ = Callback.register "%s_marker" (`%s)
| `Int x -> Swig.C_int x
| _ -> raise (LabelNotFromThisEnum v))
caml_list_nth(args,0) != Val_unit
#ifndef SWIGOCAML
#define SWIGOCAML
#endif
let enum_to_int x (v : c_obj) =
   match v with
     C_enum _y ->
     (let y = _y in match (x : c_enum_type) with
       `unknown ->          (match y with
           `Int x -> (Swig.C_int x)
           | _ -> raise (LabelNotFromThisEnum v))
let int_to_enum x y =
    match (x : c_enum_type) with
      `unknown -> C_enum (`Int y)
open Swig
type c_enum_type = [ 
  `unknown
type c_enum_value = [ 
  `Int of int
) | _ -> (C_int (get_int v))
let _ = Callback.register "%s_enum_to_int" enum_to_int
val enum_to_int : c_enum_type -> c_obj -> Swig.c_obj
let _ = Callback.register "%s_int_to_enum" int_to_enum
val int_to_enum : c_enum_type -> int -> c_obj
#define SWIG_init f_%s_init
external f_init : unit -> unit = "f_%s_init" ;;
let _ = f_init ()
type c_obj = c_enum_value c_obj_t
5OCAML
swigoctaverun.h
octrun.swg
-globals
-opprefix
-cppcast
-nocppcast
cvar
SWIG_CPLUSPLUS_CAST
SWIGOCTAVE 1
octave.swg
SWIG_POINTER_IMPLICIT_CONV
octave_value tmpv
tmap:directorin:parse
args.append(tmpv);
octave_value_list args
octave_value_list out
idx.push_back(args);
if (out.length()<%d) {
out(%d)
tmap:directorout:implicitconv
feature:implicitconv
$implicitconv
return (%s) c_result;
return (%s) *c_result;
synopsis
cdecl_info
args_info
SWIG_DEFUN( %s, %s, %s ) {
args(0)
tmap:varin:implicitconv
return octave_value_list();
octave_value obj
  return obj;
{"%s",0,%s,%s,2,0},
std::string()
%s_texinfo
feature:docstring
feature:autodoc
tmap:doc
tmap:doc:name
tmap:doc:type
tmap:doc:value
@var{?}
nullptr
TRUE
%s is of type %s. 
@var{retval} = 
tmap:in:implicitconv
hidden
if (%d<args.length()) {
tmap:freearg:implicitconv
_outp
octave_value_list _out
octave_value _outv
return _out;
return %s(args, nargout);
int argc = args.length()
octave_value_ref argv[%d]={
%soctave_value_ref(args,%d)
{"%s",%s,0,0,2,%s},
args(%d)
  SWIG_fail;
!s_members_tab
_members[] = {
&_wrap_class_%s
%s_shadow
  if (args.length()!=1) {
  %s (args, nargout);
  return args;
{"__disown",%s,0,0,0,0},
_base[] = {
 = {"
%s,%s,
0,0,
self_obj
wrap:self
octave_set_immutable
{"%s",0,%s,%s,1,0},
{"%s",0,%s,%s,0,0},
{"%s",%s,0,0,1,%s},
{"%s",%s,0,0,0,%s},
#define SWIG_name        %s
"-*- texinfo -*-\n\
@end deftypefn
return true;
*** Unable to open 'octrun.swg'
Octave Options (available with -octave)
     -cppcast        - Enable C++ casting operators (default)
     -globals <name> - Set <name> used to access C global variables [default: 'cvar']
                       Use '.' to load C global variables into module namespace
     -nocppcast      - Disable C++ casting operators
     -opprefix <str> - Prefix <str> for global operator functions [default: 'op_']
std::list<octave_value_list> idx
idx.push_back(octave_value_list("%s"));
out=swig_get_self()->subsref(".(",idx,%d);
Swig::DirectorTypeMismatchException::raise("Octave method %s.%s failed to return the required number of arguments.");
Unable to use return type %s in director method %s::%s (skipping method).
if (!SWIG_check_num_args("%s_set",args.length(),1,1,0)) return octave_value_list();
return octave_set_immutable(args,nargout);
  return octave_value_list();
@deftypefn {Loadable Function} 
%s@var{retval} is of type %s. 
static octave_value_list %s (const octave_value_list& args, int nargout) {
if (!SWIG_check_num_args("%s",args.length(),%i,%i,%i)) {
 SWIG_fail;
if (SWIG_CheckImplicit(%s)) SWIG_fail;
octave_value_list *_outp=&_out
if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
error("No matching function for overload");
upcall = !!dynamic_cast<Swig::Director*>(arg1);
  error("accessing abstract class or protected constructor"); 
SwigDirector_%s::SwigDirector_%s(void* self) :
Swig::Director((octave_swig_type*)self,static_cast<%s*>(this)) { 
    SwigDirector_%s(octave_swig_type* self);
%s::%s: %s,
Swig::Director(static_cast<%s*>(this)) { 
../../Source/Modules/octave.cxx
static swig_octave_member swig_
    error("disown takes no arguments");
    return octave_value_list();
static const swig_type_info *swig_
static swig_octave_class _wrap_class_
swig_%s_members,swig_%s_base_names,swig_%s_base };
if (!SWIG_Octave_LoadModule("%s")) return false;
#ifndef SWIGOCTAVE
#define SWIGOCTAVE
#endif
#define SWIG_name_d      "%s"
#define SWIG_global_name      "%s"
#define SWIG_op_prefix        "%s"
static const struct swig_octave_member swig_globals[] = {
static bool SWIG_init_user(octave_swig_type* module_ns)
static const char* %s_texinfo = 
virtual int OCTAVE::memberfunctionHandler(Node*)
alula
virtual int OCTAVE::staticmemberfunctionHandler(Node*)
virtual int OCTAVE::membervariableHandler(Node*)
virtual int OCTAVE::staticmembervariableHandler(Node*)
virtual int OCTAVE::classHandler(Node*)
6OCTAVE
$numargs
$commaargs
nnodes < MAX_OVERLOAD
using %s instead.
implicitconvtypecheckoff
unsigned long _index = 0;
SWIG_TypeRank _rank = 0; 
dispatch:
switch(_index) {
if (%s == %d) {
SWIG_TypeRank _ranki = 0;
SWIG_TypeRank _rankm = 0;
SWIG_TypeRank _pi = 1;
tmap:typecheck
int _v = 0;
if (%s > %d) {
if (!_v) goto check_%d;
_ranki += _v*_pi;
_rankm += _pi;
_pi *= SWIG_MAXCASTRANK;
tmap:in:SWIGTYPE
check_%d:
feature:fastdispatch
wrap:this
int _v;
if (%s <= %d) {
if (_v) {
../../Source/Modules/overload.cxx
if ((%s >= %d) && (%s <= %d)) {
if (!_index || (_ranki < _rank)) {
 _rank = _ranki; _index = %d;
 if (_rank == _rankm) goto dispatch;
Overloaded method %s with no explicit typecheck typemap for arg %d of type '%s'
List* Swig_overload_rank(Node*, bool)
swigperlrun.h
perlhead.swg
perlerrors.swg
perlrun.swg
{"%s::%s", %s},
dSP;
LEAVE;
FREETMPS;
PUTBACK;
XPUSHs(&PL_sv_yes);
XPUSHs(self);
PUSHMARK(SP);
SAVETMPS;
ENTER;
, SWIG_SHADOW);
%s::~%s() throw () {%s}
%s::~%s() {%s}
SV *%s
SV *swigself
XPUSHs(swigself);
$shadow
SV *
XPUSHs(
%s = SWIG_DIRECTOR_CAST(%s);
SvREFCNT_inc((SV *)%s);
XPUSHs(sv_2mortal(%s));
if (SvTRUE(ERRSV)) {
SV *output
if (count != %d) {
SPAGAIN;
%s = POPs;
output = POPs;
$argnum
swig_set_inner("%s", true);
swig_set_inner("%s", false);
ERRSV
-interface
-exportall
-static
-const
-nopm
-compat
SWIGPERL 1
SWIGPERL5 1
perl5.swg
int argvi = 0
argvi
    if (items < %d) {
ST(%d)
    if (items > %d) {
ST(argvi)
perl5:proxy
SWIG_SHADOW
_saved[%d]
_saved[%d] = %s;
_saved
SWIG_croak_null();
XSRETURN(argvi);
dXSARGS
XSRETURN(0);
if (items >= %d) {
tie %__
_hash;
my %__
bless $
= \%__
", $
_hash,"
 () { $
sub 
$%s 
MAGIC_PPERL
    return 1;
    return 1;
tmap:varout:type
", MAGIC_CLASS 
perl5:directordisown
, (void*) "
package 
 ##############
############# Class : 
use overload
"fallback" => 1;
__eq__
__ne__
__str__
__plusplus__
__minmin__
__add__
__sub__
__mul__
__div__
__mod__
__gt__
__ge__
__not__
__lt__
__le__
__pluseq__
__mineq__
__neg__
Unknown operator: %s
@ISA = qw(
%%OWNER = ();
%%ITERATORS = ();
%s%s($self);
my $self = shift;
sub DISOWN {
$OWNER{$ptr} = 1;
my $ptr = tied(%$self);
sub ACQUIRE {
delete $OWNER{$ptr};
swig_get_attr
my ($self,$field) = @_;
sub FETCH {
my $h = 
sub STORE {
return $self->$member_func;
return $h->{$field} if $h;
feature:shadow
my $self = tied(%{$_[0]});
sub DESTROY {
delete $OWNER{$self};
if (exists $OWNER{$self}) {
delete $ITERATORS{$self};
return unless defined $self;
$_[0]
perl5:constructorHandler
sub new {
my $pkg = 
(@_);
my $self = 
_get = *
_set = *
__assign__
__and__
__or__
Unable to locate file %s
require %s;
#define SWIG_CASTRANK_MODE
#include <map>
#include <string>
top: using module: %s
top: Found package: %s
top: No package found
%s.pm
boot_%s
#define SWIG_init    %s
#define SWIG_name   "%s::%s"
#define SWIG_prefix "%s::"
use base qw(DynaLoader);
use base qw(Exporter);
_var::
#define MAGIC_CLASS _wrap_
#define MAGIC_CLASS
#else
_var : public CPerlObj {
class _wrap_
#ifdef PERL_OBJECT
#ifdef __cplusplus
#endif
	 ST(0) = &PL_sv_yes;
	 XSRETURN(1);
{0,0,0,0}
bootstrap %s;
boot_%s();
@EXPORT = qw(%s);
my ($classname,$obj) = @_;
sub TIEHASH {
sub CLEAR { }
sub FIRSTKEY { }
sub NEXTKEY { }
$self->$member_func();
return tied(%$ptr);
my $ptr = shift;
sub this {
package %s;
*** Unable to open 'perlhead.swg'
*** Unable to open 'perlerrors.swg'
*** Unable to open 'perlrun.swg'
SV *self = SWIG_NewPointerObj(SWIG_as_voidptr(this), SWIGTYPE
call_method("DESTROY", G_EVAL | G_VOID);
sv_bless(self, gv_stashpv(swig_get_class(), 0));
swigself = SWIG_NewPointerObj(SWIG_as_voidptr(this), SWIGTYPE%s, SWIG_SHADOW);
sv_bless(swigself, gv_stashpv(swig_get_class(), 0));
call_method("%s", G_EVAL | G_SCALAR);
  PUTBACK;
  FREETMPS;
  LEAVE;
  Swig::DirectorTypeMismatchException::raise("Perl method %s.%sfailed to return a list.");
  Swig::DirectorMethodException::raise(ERRSV);
*** -package is no longer supported
*** use the directive '%module A::B::C' in your interface file instead
*** see the Perl section in the manual for details.
*** -interface is no longer supported
*** use the directive '%module A::B::C' in your interface file instead
*** see the Perl section in the manual for details.
Perl5 Options (available with -perl5)
     -compat         - Compatibility mode
     -const          - Wrap constants as constants and not variables (implies -proxy)
     -cppcast        - Enable C++ casting operators
     -nocppcast      - Disable C++ casting operators, useful for generating bugs
     -nopm           - Do not generate the .pm file
     -noproxy        - Don't create proxy classes
     -proxy          - Create proxy classes
     -static         - Omit code related to dynamic loading
    if ((items < %d) || (items > %d)) {
setclassname: Found sym:name: %s
setclassname: Found module: %s
setclassname: No package found
setclassname: Found actualpackage: %s
setclassname: setting proxy: %s
upcall = director && SvSTASH(SvRV(ST(0))) == gv_stashpv(director->swig_get_class(), 0);
} catch (Swig::DirectorException& swig_err) {
  sv_setsv(ERRSV, swig_err.getNative());
PUSHMARK(MARK); SWIG_CALLXS(%s); return;
croak("No matching function for overloaded '%s'");
if (!director || !(director->swig_get_inner("%s"))) {
SWIG_exception_fail(SWIG_RuntimeError, "accessing protected member %s");
        SWIG_croak("Usage: %s");
SWIGCLASS_STATIC int %s(pTHX_ SV* sv, MAGIC * SWIGUNUSEDPARM(mg)) {
SWIGCLASS_STATIC int %s(pTHX_ SV *sv, MAGIC *SWIGUNUSEDPARM(mg)) {
", MAGIC_CLASS swig_magic_readonly, MAGIC_CLASS 
%s::%s: %s, Swig::Director(self) { 
   SWIG_DIRECTOR_RGTR((%s *)this, this); 
/* Internal director utilities */
    bool swig_get_inner(const char *swig_protected_method_name) const {
      std::map<std::string, bool>::const_iterator iv = swig_inner.find(swig_protected_method_name);
      return (iv != swig_inner.end() ? iv->second : false);
    void swig_set_inner(const char *swig_protected_method_name, bool swig_val) const {
      swig_inner[swig_protected_method_name] = swig_val;
    mutable std::map<std::string, bool> swig_inner;
"=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
"==" => sub { $_[0]->__eq__($_[1])},
"!=" => sub { $_[0]->__ne__($_[1])},
'""' => sub { $_[0]->__str__()},
"++" => sub { $_[0]->__plusplus__()},
"--" => sub { $_[0]->__minmin__()},
"+" => sub { $_[0]->__add__($_[1])},
"-" => sub {  if( not $_[2] ) { $_[0]->__sub__($_[1]) }
elsif( $_[0]->can('__rsub__') ) { $_[0]->__rsub__($_[1]) }
else { die("reverse subtraction not supported") }
"*" => sub { $_[0]->__mul__($_[1])},
"/" => sub { $_[0]->__div__($_[1])},
"%" => sub { $_[0]->__mod__($_[1])},
">" => sub { $_[0]->__gt__($_[1])},
">=" => sub { $_[0]->__ge__($_[1])},
"!" => sub { $_[0]->__not__()},
"<" => sub { $_[0]->__lt__($_[1])},
"<=" => sub { $_[0]->__le__($_[1])},
"+=" => sub { $_[0]->__pluseq__($_[1])},
"-=" => sub { $_[0]->__mineq__($_[1])},
"neg" => sub { $_[0]->__neg__()},
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
  result = sv_newmortal();
  if (director) sv_setsv(result, director->swig_get_self());
  Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
my $member_func = "swig_${field}_get";
return $self->$member_func($newval);
return $h->{$field} = $newval if $h;
if (not $self->can($member_func)) {
my $member_func = "swig_${field}_set";
my ($self,$field,$newval) = @_;
return unless $_[0]->isa('HASH');
strcmp(SvPV_nolen(ST(0)), "%s::%s") != 0
if ($comparison) { /* subclassed */
  $director_new
} else {
SWIG_exception_fail(SWIG_RuntimeError, "accessing abstract class or protected constructor");
bless $self, $pkg if defined($self);
*** directors are not supported with -exportall
*** directors are not supported with -static
*** directors are not supported with -noproxy
*** directors are not supported with -nopm
*** directors are not supported with -compat
static swig_command_info swig_commands[] = {
static swig_constant_info swig_constants[] = {
static swig_variable_info swig_variables[] = {
#ifndef SWIGPERL
#define SWIGPERL
#endif
top: using namespace_module: %s
#ifdef __cplusplus
extern "C" {
#endif
croak("Value is read-only.");
SWIGCLASS_STATIC int swig_magic_readonly(pTHX_ SV *SWIGUNUSEDPARM(sv), MAGIC *SWIGUNUSEDPARM(mg)) {
# ---------- BASE METHODS -------------
return bless $obj, $classname;
$self->$member_func($newval);
# ------- FUNCTION WRAPPERS --------
# ------- CONSTANT STUBS -------
# ------- VARIABLE STUBS --------
5PERL5
zval 
args[%d] = &%s;
INIT_ZVAL(
int error;
zval **args = NULL;
zval *args[%d];
zval *%s, funcname;
if (!swig_self) {
MAKE_STD_ZVAL(%s);
 %s, %d, args TSRMLS_CC);
FREE_ZVAL(%s);
SWIG_FAIL(TSRMLS_C);
	const %s = %s;
SWIGPHP 1
SWIGPHP5 1
php.swg
-noshadow
-make
-withc
-withcxx
-phpfull
-withlibs
-withincs
-dlname
__construct
void *ptr=value->ptr
newobject
  efree(value);
 TSRMLS_CC
ZEND_NAMED_FUNCTION(
ZEND_END_ARG_INFO()
tmap:in:byref
 ZEND_ARG_PASS_INFO(%d)
zval *arg0
zval **args[%d]
int arg_count
arg_count = ZEND_NUM_ARGS();
	WRONG_PARAM_COUNT;
if(ZEND_NUM_ARGS() != 0) {
WRONG_PARAM_COUNT;
arg0 = *args[0];
	if(arg_count > %d) {
return_value
ZEND_NAMED_FUNCTION(%s);
zval **argv[%d]
argc = ZEND_NUM_ARGS();
SWIG_ErrorCode() = E_ERROR;
constructorHandler:sym:name
../../Source/Modules/php.cxx
Malloc failed!
_cPtr
$this->%s
$%s=%s
		switch (func_num_args()) {
case %d: 
%s($_this%s); break;
%s($_this, %s); break;
default: 
$res=null
	%sfunction %s(%s) {
			$this->%s=$%s;
			return;
	static function %s() {
		if (func_num_args()) {
			%s(func_get_arg(0));
	static function %s(%s) {
		$this->%s=%s;
		return new %s%s(%s);
		$this->%s=%s($_this, %s);
		$this->%s=%s($_this);
		%s;
php:proxy
		$r=%s;
		if (is_resource($r)) {
			return new %s%s($r);
			$c = new stdClass();
			$c->_cPtr = $r;
			return $c;
		return $r;
		$this->%s = $r;
		return $this;
case '%s': 
		%s
		return %s;
 or_%s
$this->%s=
%s(%s); break;
			$_this = null;
		} else {
			$_this = $this;
Not a class
zval
ParmList_len(parms) > 0
 TSRMLS_DC
class %s%s 
extends %s%s 
extends Exception 
phpinterfaces
implements %s 
	public $%s=null;
_pData
	protected $%s=array();
		$func = '%s_'.$var.'_set';
		%s%s::__set($var,$value);
		$this->%s[$var] = $value;
	function __get($var) {
') return new 
		if ($var === '
_get($this->
		$func = '%s_'.$var.'_get';
		return %s%s::__get($var);
	function __isset($var) {
		return $this->%s[$var];
	function __construct($h) {
		$this->%s=$h;
abstract 
') return 
  %s = (%s *)new %s(%s);
varinit
Unable to link with type %s
include '%s';
phpinfo
$arg->type != IS_NULL
/* init section */
/* rinit section */
/* shutdown section */
/* rshutdown section */
/* header section */
/* wrapper section */
/* vinit subsection */
/* vdecl subsection */
/* cinit subsection */
/* oinit subsection */
/* PHP Proxy Classes */
rshutdown
#define SWIG_PREFIX "%s"
#define SWIG_PREFIX_LEN %lu
#include "%s"
.php
<?php
    } else {
const char *error_msg;
int error_code;
ZEND_END_MODULE_GLOBALS(%s)
#ifdef ZTS
#ifdef __GNUC__
    abort();
  zval **args[2];
  int type;
  SWIG_ResetError(TSRMLS_C);
    WRONG_PARAM_COUNT;
  zval **args[1];
#define SWIG_name  "%s"
#include "php.h"
#include "php_ini.h"
#include "php_%s.h"
php_
#ifndef PHP_%s_H
#define PHP_%s_H
#ifdef PHP_WIN32
# define PHP_%s_API
#include "TSRM.h"
PHP_MINIT_FUNCTION(%s);
PHP_MSHUTDOWN_FUNCTION(%s);
PHP_RINIT_FUNCTION(%s);
PHP_RSHUTDOWN_FUNCTION(%s);
PHP_MINFO_FUNCTION(%s);
/* arginfo subsection */
/* entry subsection */
/* class entry subsection */
#undef ZEND_MODULE_BUILD_ID
_module_entry = {
zend_module_entry 
    STANDARD_MODULE_HEADER,
    (char*)"%s",
    %s_functions,
    PHP_MINIT(%s),
    PHP_MSHUTDOWN(%s),
    PHP_RINIT(%s),
    PHP_RSHUTDOWN(%s),
    PHP_MINFO(%s),
    NO_VERSION_YET,
  efree(rsrc->ptr);
/* end oinit subsection */
/* end cinit subsection */
    return SUCCESS;
PHP_RINIT_FUNCTION(%s)
/* end vinit subsection */
#ifdef ZTS
    ts_free_id(
PHP_MSHUTDOWN_FUNCTION(
PHP_RSHUTDOWN_FUNCTION(%s)
PHP_MINFO_FUNCTION(%s)
/* end init section */
#endif /* PHP_%s_H */
/* end header section */
/* end wrapper section */
/* end vdecl subsection */
_get_newobject,_wrap_swig_
_alter_newobject,_wrap_swig_
 SWIG_ZEND_NAMED_FE(swig_
abstract class %s {
TSRMLS_FETCH_FROM_CTX(swig_zts_ctx);
Swig::DirectorPureVirtualException::raise("Attempted to invoke pure virtual method %s::%s" TSRMLS_CC);
  SWIG_PHP_Error(E_ERROR, "this pointer is NULL");
ZVAL_STRINGL(&funcname, (char *)"%s", %d, 0);
call_user_function(EG(function_table), (zval**)&swig_self, &funcname,
PHP Options (available with -php)
     -noproxy         - Don't generate proxy classes.
     -prefix <prefix> - Prepend <prefix> to all class names in PHP wrappers
*** %s is no longer supported.
*** %s is no longer supported.
*** We recommend building as a dynamically loadable module.
*** -dlname is no longer supported.
*** If you want to change the module name, use -module instead.
/* This function is designed to be called by the zend list destructors */
/* to typecast and do the actual destruction */
static void %s(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr
int newobject=value->newobject
  if (! newobject) return; /* can't delete it! */
  arg1 = (%s)SWIG_ZTS_ConvertResourceData(ptr,type_name,SWIGTYPE%s TSRMLS_CC);
  if (! arg1) zend_error(E_ERROR, "%s resource already free'd");
Swig::DirectorPureVirtualException::raise("
 SWIG_ZEND_NAMED_FE(%(lower)s,%s,swig_arginfo_%(lower)s)
ZEND_BEGIN_ARG_INFO_EX(swig_arginfo_%(lower)s, 0, 0, 0)
if(arg_count<%d || arg_count>%d ||
   zend_get_parameters_array_ex(arg_count,args)!=SUCCESS)
if(ZEND_NUM_ARGS() != %d || zend_get_parameters_array_ex(%d, args) != SUCCESS) {
upcall = !Swig::Director::swig_is_overridden_method((char *)"%s%s", (char *)"%s" TSRMLS_CC);
%s(INTERNAL_FUNCTION_PARAM_PASSTHRU); return;
zend_get_parameters_array_ex(argc,argv);
SWIG_ErrorMsg() = "No matching function for overloaded '%s'";
membervariableHandler:sym:name
staticmemberfunctionHandler:sym:name
staticmembervariableHandler:sym:name
0 <= argno && argno < max_num_of_arguments
		if (is_resource($%s) && get_resource_type($%s) === '%s') {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			$c='%s'.substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
		if (!is_resource($r)) return $r;
		switch (get_resource_type($r)) {
	if(!arg1) SWIG_PHP_Error(E_ERROR, "this pointer is NULL");
Modifying the access of '%s::%s' to public, as the base '%s' has it as public as well.
		if (get_class($this) === '%s%s') {
*** -php4 is no longer supported.
*** Either upgrade to PHP5 or use SWIG 1.3.36 or earlier.
php Typetrace vector already saved!
%s::%s: %s, Swig::Director(self TSRMLS_CC) {
Warning for %s proxy: Base %s ignored. Multiple inheritance is not supported in PHP.
	function __set($var,$value) {
		if ($var === '%s') return %s($this->%s,$value);
		if (function_exists($func)) return call_user_func($func,$this->%s,$value);
		if ($var === 'thisown') return swig_%s_alter_newobject($this->%s,$value);
		if (function_exists($func)) return call_user_func($func,$this->%s);
		if ($var === 'thisown') return swig_%s_get_newobject($this->%s);
		if (function_exists('%s_'.$var.'_get')) return true;
		if ($var === 'thisown') return true;
		return %s%s::__isset($var);
		return array_key_exists($var, $this->%s);
if ( arg0->type == IS_NULL ) { /* not subclassed */
  SWIG_PHP_Error(E_ERROR, "accessing abstract class or protected constructor");
} else {
  %s = (%s *)new SwigDirector_%s(arg0 TSRMLS_CC%s);
#ifndef SWIGPHP
#define SWIGPHP
#endif
// Try to load our extension if it's not already loaded.
if (!extension_loaded('%s')) {
  if (strtolower(substr(PHP_OS, 0, 3)) === 'win') {
    if (!dl('php_%s.dll')) return;
    // PHP_SHLIB_SUFFIX gives 'dylib' on MacOS X but modules are 'so'.
    if (PHP_SHLIB_SUFFIX === 'dylib') {
      if (!dl('%s.so')) return;
      if (!dl('%s.'.PHP_SHLIB_SUFFIX)) return;
ZEND_INIT_MODULE_GLOBALS(%s, %s_init_globals, %s_destroy_globals);
ZEND_BEGIN_MODULE_GLOBALS(%s)
ZEND_DECLARE_MODULE_GLOBALS(%s)
#define SWIG_ErrorMsg() TSRMG(%s_globals_id, zend_%s_globals *, error_msg )
#define SWIG_ErrorCode() TSRMG(%s_globals_id, zend_%s_globals *, error_code )
#define SWIG_ErrorMsg() (%s_globals.error_msg)
#define SWIG_ErrorCode() (%s_globals.error_code)
static void SWIG_FAIL(TSRMLS_D) __attribute__ ((__noreturn__));
static void SWIG_FAIL(TSRMLS_D) {
    zend_error(SWIG_ErrorCode(), "%s", SWIG_ErrorMsg());
static void %s_init_globals(zend_%s_globals *globals ) {
  globals->error_msg = default_error_msg;
  globals->error_code = default_error_code;
static void %s_destroy_globals(zend_%s_globals * globals) { (void)globals; }
static void SWIG_ResetError(TSRMLS_D) {
  SWIG_ErrorMsg() = default_error_msg;
  SWIG_ErrorCode() = default_error_code;
ZEND_NAMED_FUNCTION(_wrap_swig_%s_alter_newobject) {
  swig_object_wrapper *value;
  if(ZEND_NUM_ARGS() != 2 || zend_get_parameters_array_ex(2, args) != SUCCESS) {
  value = (swig_object_wrapper *) zend_list_find((*args[0])->value.lval, &type);
  value->newobject = zval_is_true(*args[1]);
ZEND_NAMED_FUNCTION(_wrap_swig_%s_get_newobject) {
  if(ZEND_NUM_ARGS() != 1 || zend_get_parameters_array_ex(1, args) != SUCCESS) {
  RETVAL_LONG(value->newobject);
#include "ext/standard/info.h"
extern zend_module_entry %s_module_entry;
#define phpext_%s_ptr &%s_module_entry
# define PHP_%s_API __declspec(dllexport)
/* Every non-class user visible function must have an entry here */
static zend_function_entry %s_functions[] = {
#if ZEND_MODULE_API_NO <= 20090626
#define ZEND_MODULE_BUILD_ID (char*)"API" ZEND_TOSTR(ZEND_MODULE_API_NO) ZEND_BUILD_TS ZEND_BUILD_DEBUG ZEND_BUILD_SYSTEM ZEND_BUILD_EXTRA
    STANDARD_MODULE_PROPERTIES
zend_module_entry* SWIG_module_entry = &%s_module_entry;
SWIGEXPORT zend_module_entry *get_module(void) { return &%s_module_entry; }
#define SWIG_php_minit PHP_MINIT_FUNCTION(%s)
/* Register resource destructors for pointer types */
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy%s) {
  %s(rsrc, SWIGTYPE%s->name TSRMLS_CC);
  /* No destructor for class %s */
  /* No destructor for simple type %s */
static int le_swig_%s=0; /* handle for %s */
le_swig_%s=zend_register_list_destructors_ex(_wrap_destroy%s,NULL,(char *)(SWIGTYPE%s->name),module_number);
SWIG_TypeClientData(SWIGTYPE%s,&le_swig_%s);
CG(active_class_entry) = NULL;
_globals_id);
#endif
    return SUCCESS;
_get_newobject,NULL)
 ZEND_FE_END
_alter_newobject,NULL)
 SWIG_ZEND_NAMED_FE(swig_
virtual int PHP::functionWrapper(Node*)
virtual int PHP::classDirectorConstructor(Node*)
Language* new_swig_php()
3PHP
SWIGPIKE 1
pike.swg
%s = (%s) THIS;
Pike_sp[%d-args]
tmap:in:pikedesc
pop_n_elems(args);
THIS = (void *) 
, tVoid
tmap:out:pikedesc
../../Source/Modules/pike.cxx
%s(args); return;
static void %s(INT32 args) {
INT32 argc
struct svalue argv[%d]
INT32 ii
argc = args;
argv[ii] = Pike_sp[ii-args];
self, args
tAny,
start_new_program();
membervariables
pike_require("%s");
classInit
#define SWIG_name    "%s"
%n%c_create
%n%c_destroy
Unsupported constant value %s = %s
Pike Options (available with -pike)
     [no additional options]
ADD_FUNCTION("%s", %s, tFunc(%s), 0);
for (ii = 0; (ii < argc) && (ii < %d); ii++) {
Pike_error("No matching function for overloaded '%s'.");
low_inherit((struct program *) SWIGTYPE%s->clientdata, 0, 0, 0, 0, 0);
add_program_constant("%s", pr = end_program(), 0);
SWIG_TypeClientData(SWIGTYPE%s, (void *) pr);
ADD_STORAGE(swig_object_wrapper);
#ifndef SWIGPIKE
#define SWIGPIKE
#endif
#define SWIG_init    pike_module_init
void PIKE::add_method(DOHconst_String_or_char_ptr, DOHconst_String_or_char_ptr, DOHconst_String_or_char_ptr)
4PIKE
swigpyrun.h
    %s, %*s/* %s */
pyhead.swg
pyerrors.swg
pythreads.swg
pyapi.swg
pyrun.swg
-new_repr
-newrepr
-old_repr
-oldrepr
-classptr
-noproxyimport
-keyword
-classic
-outputtuple
-nooutputtuple
-nortti
-threads
-nothreads
-safecstrings
-nosafecstrings
-buildnone
-nobuildnone
-dirvtable
-nodirvtable
-fastunpack
-nofastunpack
-fastproxy
-nofastproxy
-fastquery
-nofastquery
-fastinit
-nofastinit
-olddefs
-noolddefs
-castmode
-nocastmode
-extranative
-noextranative
-modernargs
-nomodernargs
-aliasobj0
-noaliasobj0
-proxydel
-noproxydel
-modern
-nomodern
-noh
-new_vwm
-newvwm
-py3
-builtin
SWIGPYTHON_BUILTIN
-relativeimport
SWIGPYTHON 1
python.swg
feature:nothreadblock
feature:threadbeginblock
feature:threadendblock
feature:nothreadallow
feature:threadendallow
SWIG_PYTHON_THREAD_END_ALLOW;
feature:threadbeginallow
feature:pythonprepend
feature:pythonappend
feature:addtofunc
PyObject *self = NULL;
swig::SwigVar_PyObject 
(PyObject *)
swig::SwigVar_PyObject
Py_INCREF((PyObject *)%s);
feature:nothread
if (!swig_get_self()) {
PyObject *output
if (!PyTuple_Check(%s)) {
  if (error) {
%s = %s.%s
Swig_var_%s
pybuiltin:setter
 is read-only.");
pybuiltin:getter
PyObject *pyobj = 0
pyobj
PyObject *self = 0
  (void)self;
  return pyobj;
pybuiltin:symname
feature:python:callback
  if (!d) return NULL;
  return SWIG_Py_Void();
%s_swigconstant
_swigconstant(
builtin_constantWrapper
  PyObject *module;
  PyObject *d;
initial
True
False
xXnN
tmap:argout:match_type
 -> "%s"
SwigPyBuiltin_BadInit
SwigPyBuiltin_SetterClosure
SwigPyBuiltin_GetterClosure
SwigPyBuiltin_%s
  builtin_base_count = 0;
feature:python:tp_dealloc
%s_closure
SwigPyBuiltin_BadDealloc
python:richcompare
%s_richcompare
Py_DECREF(static_getset);
SWIGINTERN PyObject *
  PyObject *result = NULL;
  assert(tuple);
  Py_XINCREF(other);
  switch (op) {
    default : break;
  if (!result) {
      Py_INCREF(result);
  Py_DECREF(tuple);
  return result;
feature:python:nondynamic
SWIG_Python_NonDynamicSetAttr
feature:python:tp_setattro
"%s.%s.%s"
"%s.%s"
feature:python:tp_doc
    PyObject_HEAD_INIT(NULL)
ob_size
tp_name
tp_basicsize
sizeof(SwigPyObject)
feature:python:tp_itemsize
feature:python:tp_print
printfunc
feature:python:tp_getattr
getattrfunc
feature:python:tp_setattr
setattrfunc
feature:python:tp_compare
feature:python:tp_repr
reprfunc
feature:python:tp_hash
hashfunc
feature:python:tp_call
ternaryfunc
feature:python:tp_str
feature:python:tp_getattro
getattrofunc
setattrofunc
tp_flags
feature:python:tp_traverse
traverseproc
feature:python:tp_clear
inquiry
richcmpfunc
feature:python:tp_richcompare
tp_weaklistoffset
feature:python:tp_iter
getiterfunc
feature:python:tp_iternext
iternextfunc
tp_methods
feature:python:tp_members
tp_getset
feature:python:tp_base
feature:python:tp_dict
feature:python:tp_descr_get
descrgetfunc
feature:python:tp_descr_set
descrsetfunc
initproc
tp_init
feature:python:tp_alloc
allocfunc
newfunc
tp_new
feature:python:tp_free
tp_is_gc
PyObject*
tp_bases
tp_mro
tp_cache
tp_subclasses
tp_weaklist
tp_del
feature:python:tp_version_tag
feature:python:tp_finalize
#ifdef COUNT_ALLOCS
Py_ssize_t
tp_allocs
tp_frees
tp_maxalloc
struct _typeobject*
tp_prev
tp_next
  },
feature:python:am_await
unaryfunc
feature:python:am_aiter
feature:python:am_anext
feature:python:nb_add
binaryfunc
feature:python:nb_subtract
feature:python:nb_multiply
feature:python:nb_divide
feature:python:nb_remainder
feature:python:nb_divmod
feature:python:nb_power
feature:python:nb_negative
feature:python:nb_positive
feature:python:nb_absolute
feature:python:nb_nonzero
feature:python:nb_invert
feature:python:nb_lshift
feature:python:nb_rshift
feature:python:nb_and
feature:python:nb_xor
feature:python:nb_or
feature:python:nb_coerce
coercion
feature:python:nb_int
feature:python:nb_reserved
feature:python:nb_long
feature:python:nb_float
feature:python:nb_oct
feature:python:nb_hex
feature:python:nb_inplace_add
nb_inplace_subtract
nb_inplace_multiply
nb_inplace_divide
nb_inplace_remainder
nb_inplace_power
nb_inplace_lshift
nb_inplace_rshift
feature:python:nb_inplace_and
feature:python:nb_inplace_xor
feature:python:nb_inplace_or
nb_floor_divide
feature:python:nb_true_divide
nb_inplace_floor_divide
nb_inplace_true_divide
feature:python:nb_index
nb_matrix_multiply
nb_inplace_matrix_multiply
feature:python:mp_length
lenfunc
feature:python:mp_subscript
objobjargproc
mp_ass_subscript
feature:python:sq_length
feature:python:sq_concat
feature:python:sq_repeat
feature:python:sq_item
feature:was_sq_slice
feature:python:sq_slice
ssizessizeargfunc
feature:python:sq_ass_item
feature:was_sq_ass_slice
feature:python:sq_ass_slice
ssizessizeobjargproc
feature:python:sq_contains
objobjproc
sq_inplace_concat
sq_inplace_repeat
readbufferproc
bf_getreadbuffer
writebufferproc
bf_getwritebuffer
feature:python:bf_getsegcount
segcountproc
charbufferproc
bf_getcharbuffer
feature:python:bf_getbuffer
getbufferproc
releasebufferproc
bf_releasebuffer
feature:python:ht_name
feature:python:ht_slots
feature:python:ht_qualname
feature:python:ht_cached_keys
struct _dictkeysobject*
&%s_clientdata
(PyObject*) &%s_type
      return NULL;
      return;
    d = md;
%s_%s_getset
Parameters
----------
: '%s'
feature:pdocs
feature:python:cdefaultargs
*args
, **kwargs
feature:noautodoc
extended
Proxy of C++ %s class.
Proxy of C %s struct.
self, %s) -> %s
self) -> %s
%s(%s) -> %s
__del__(%s self)
__del__(self)
self, %s)
python:docstring
python:autodoc
(char *)"%s"
(char *)"swig_ptr: %s"
def 
    return val
    val = 
return %s(self, argc, argv);
return %s(self, args);
Py_ssize_t argc
PyObject *argv[%d] = {0}
Py_ssize_t ii
argv[0] = self;
argc++;
feature:python:maybecall
return Py_NotImplemented;
--argc;
SWIGUNUSEDPARM(self)
swig_obj[0]
SWIGINTERN 
PyObject *resultobj = 0
(PyObject *
, PyObject *args) {
__varargs__
,kwnames
python:overvarargs
#define obj0 (swig_obj[0])
PyObject *swig_obj[%d]
swig_obj
(char *) "%s",
if (
  char *  kwnames[] = 
:%s"
)) SWIG_fail;
if (!args) SWIG_fail;
swig_obj[0] = args;
SWIG_BUILTIN_INIT
SWIG_POINTER_NEW
directorfree
  return -1;
    return resultobj;
#if defined(obj0)
#undef obj0
newargs = PyTuple_New(%d);
for (i = 0; i < %d; ++i) {
  Py_XINCREF(swig_obj[i]);
Py_XDECREF(newargs);
Py_XDECREF(varargs);
SwigPyObject_get___dict__
feature:python:slot
feature:python:slot:functype
feature:python:%s
feature:python:compare
python:argcount
if (!(%s)) {
  Py_INCREF(resultobj);
int resultobj
PyObject *varargs
PyObject *newargs
PyObject *resultobj
def __disown__(self):
self.this.disown()
return weakref_proxy(self)
/* VTable implementation */
        if (!method) {
        }
      return method;
(object)
(_object)
 - class is abstract
feature:classic
feature:modern
python:proxy
feature:python:abc
(Exception)
__swig_setmethods__ = {}
for _s in [
__swig_getmethods__ = {}
, name)
class __metaclass__(type):
/* type '%s' */
SWIGINTERN PyObject *
  PyObject *obj;
, SWIG_NewClientData(obj));
%s_swigregister
raise AttributeError("
No constructor defined
%s_swiginit
__repr__ = _swig_repr
return "<C 
def __repr__(self):
Ptr(
class 
def __init__(self, this):
self.this.append(this)
self.__class__ = 
self.this.own(0)
self.this = this
except Exception:
shadow_methods
%s_swigregister(%s)
)->clientdata)->pytype
$arg != Py_None
%feature("shadow")
__swig_destroy__ = 
__del__ = lambda self: None
pass
def __del__(self):
python:constructorHandler
rclassname
_self, 
if self.__class__ == %s:
else:
_self = None
_self = self
def __init__(
_swiginit(self, 
this = 
builtin_memberconstantHandler
builtin_symname
res = %s(%s);
"] = 
__swig_setmethods__["
__swig_getmethods__["
if _newclass:
 = _swig_property(
%s.%s = %s.%s.%s
int res
PyObject *value
METH_STATIC|
METH_NOARGS
METH_O
METH_VARARGS
return val
 = staticmethod(
"] = lambda x: 
builtin_memberfunc
__repr__
%s_cb_ptr
%s.%s.
pythonbegin
import %s%s%s%s
from . import %.*s
from .%s import %s%s
import %s.%s%s
delete $self;
#define SWIG_PYTHON_THREADS
#ifndef SWIG_DIRECTOR_NORTTI
#define SWIG_DIRECTOR_NORTTI
#define SWIG_PYTHON_CLASSIC
#define SWIGPYTHON_BUILTIN
# endif
#ifndef METH_O
#ifdef SWIG_TypeQuery
# undef SWIG_TypeQuery
%s%s.py
def swig_import_helper():
from os.path import dirname
import imp
fp = None
        except ImportError:
            import %s
            return %s
        if fp is not None:
            try:
finally:
fp.close()
return _mod
del swig_import_helper
del version_info
from %s import *
except NameError:
_swig_property = property
if (name == "thisown"):
if (not static):
return method(self, value)
if method:
self.__dict__[name] = value
if (name == "this"):
return self.this.own(value)
raise AttributeError(name)
return method(self)
return self.this.own()
def _swig_repr(self):
strthis = ""
_newclass = 1
_object = object
_newclass = 0
class _object:
except AttributeError:
return set_attr
set(self, name, value)
import weakref
weakref_proxy = lambda x: x
#define SWIG_name    "%s"
SWIG_PyInstanceMethod_New
SwigPyObject
	 { NULL, NULL, 0, NULL }
{0, 0, 0, 0.0, 0, 0}};
/* Initialize threading */
  return m;
SWIGPY_UNARYFUNC_CLOSURE
SWIGPY_DESTRUCTOR_CLOSURE
SWIGPY_INQUIRY_CLOSURE
SWIGPY_BINARYFUNC_CLOSURE
SWIGPY_TERNARYFUNC_CLOSURE
ternarycallfunc
SWIGPY_LENFUNC_CLOSURE
SWIGPY_SSIZEARGFUNC_CLOSURE
SWIGPY_OBJOBJARGPROC_CLOSURE
SWIGPY_REPRFUNC_CLOSURE
SWIGPY_HASHFUNC_CLOSURE
SWIGPY_ITERNEXT_CLOSURE
*** Unable to open 'pyhead.swg'
*** Unable to open 'pyerrors.swg'
*** Unable to open 'pythreads.swg'
*** Unable to open 'pyapi.swg'
*** Unable to open 'pyrun.swg'
Python Options (available with -python)
     -aliasobj0      - Alias obj0 when using fastunpack, needed for some old typemaps 
     -buildnone      - Use Py_BuildValue() to obtain Py_None (default in Windows)
     -builtin        - Create new python built-in types, rather than proxy classes, for better performance
     -castmode       - Enable the casting mode, which allows implicit cast between types in python
     -classic        - Use classic classes only
     -classptr       - Generate shadow 'ClassPtr' as in older swig versions
     -cppcast        - Enable C++ casting operators (default) 
     -dirvtable      - Generate a pseudo virtual table for directors for faster dispatch 
     -extranative    - Return extra native C++ wraps for std containers when possible 
     -fastinit       - Use fast init mechanism for classes (default)
     -fastunpack     - Use fast unpack mechanism to parse the argument functions 
     -fastproxy      - Use fast proxy mechanism for member methods 
     -fastquery      - Use fast query mechanism for types 
     -globals <name> - Set <name> used to access C global variable [default: 'cvar']
     -interface <lib>- Set the lib name to <lib>
     -keyword        - Use keyword arguments
     -modern         - Use modern python features only, without compatibility code
     -modernargs     - Use "modern" args mechanism to pack/unpack the function arguments
     -newrepr        - Use more informative version of __repr__ in proxy classes (default) 
     -newvwm         - New value wrapper mode, use only when everything else fails 
     -noaliasobj0    - Don't generate an obj0 alias when using fastunpack (default) 
     -nobuildnone    - Access Py_None directly (default in non-Windows systems)
     -nocastmode     - Disable the casting mode (default)
     -nocppcast      - Disable C++ casting operators, useful for generating bugs
     -nodirvtable    - Don't use the virtual table feature, resolve the python method each time (default)
     -noexcept       - No automatic exception handling
     -noextranative  - Don't use extra native C++ wraps for std containers when possible (default) 
     -nofastinit     - Use traditional init mechanism for classes 
     -nofastunpack   - Use traditional UnpackTuple method to parse the argument functions (default) 
     -nofastproxy    - Use traditional proxy mechanism for member methods (default) 
     -nofastquery    - Use traditional query mechanism for types (default) 
     -noh            - Don't generate the output header file
     -nomodern       - Don't use modern python features which are not backwards compatible 
     -nomodernargs   - Use classic ParseTuple/CallFunction methods to pack/unpack the function arguments (default) 
     -noolddefs      - Don't emit the old method definitions even when using fastproxy (default) 
     -nooutputtuple  - Use a PyList for appending output values (default) 
     -noproxy        - Don't generate proxy classes 
     -noproxydel     - Don't generate the redundant __del__ method 
     -noproxyimport  - Don't insert proxy import statements derived from the %import directive 
     -nortti         - Disable the use of the native C++ RTTI with directors
     -nosafecstrings - Avoid extra strings copies when possible (default)
     -nothreads      - Disable thread support for the entire interface
     -olddefs        - Keep the old method definitions even when using fastproxy
     -oldrepr        - Use shorter and old version of __repr__ in proxy classes
     -outputtuple    - Use a PyTuple for outputs instead of a PyList (use carefully with legacy interfaces) 
     -proxydel       - Generate a __del__ method even though it is now redundant (default) 
     -relativeimport - Use relative python imports 
     -safecstrings   - Use safer (but slower) C string mapping, generating copies from Python -> C/C++
     -threads        - Add thread support for all the interface
     -O              - Enable the following optimization options: 
                         -modern -fastdispatch -nosafecstrings -fvirtual -noproxydel 
                         -fastproxy -fastinit -fastunpack -fastquery -modernargs -nobuildnone 
     -py3            - Generate code with Python 3 specific features:
                         Function annotation 
SWIG_PYTHON_THREAD_BEGIN_BLOCK;
SWIG_PYTHON_THREAD_END_BLOCK;
SWIG_PYTHON_THREAD_BEGIN_ALLOW;
%s = SWIG_InternalNewPointerObj(%s, SWIGTYPE%s, 0);
  Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call %s.__init__.");
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
const size_t swig_method_index = %d;
const char * const swig_method_name = "%s";
PyObject* method = swig_get_method(swig_method_index, swig_method_name);
swig::SwigVar_PyObject %s = PyObject_CallFunction(method, (char *)"(%s)" %s);
swig::SwigVar_PyObject %s = PyObject_CallFunctionObjArgs(method %s, NULL);
swig::SwigVar_PyObject args = PyTuple_New(0);
swig::SwigVar_PyObject %s = PyObject_Call(method, (PyObject*) args, NULL);
swig::SwigVar_PyObject %s = PyObject_CallFunction(method, NULL, NULL);
swig::SwigVar_PyObject %s = PyObject_CallMethod(swig_get_self(), (char *)"%s", (char *)"(%s)" %s);
swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar((char *)"%s");
swig::SwigVar_PyObject %s = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name %s, NULL);
swig::SwigVar_PyObject %s = PyObject_CallMethod(swig_get_self(), (char *) "%s", NULL);
swig::SwigVar_PyObject %s = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
  PyObject *error = PyErr_Occurred();
  Swig::DirectorTypeMismatchException::raise("Python method %s.%sfailed to return a tuple.");
output = PyTuple_GetItem(%s, %d);
    Swig::DirectorMethodException::raise("Error detected when calling '%s.%s'");
	 PyDict_SetItemString(md,(char*)"%s", SWIG_globals());
	 SwigPyBuiltin_AddPublicSymbol(public_interface, "%s");
SWIGINTERN int %s(PyObject *_val) {
SWIGINTERN int %s(PyObject *) {
SWIGINTERN int %s(PyObject *_val SWIGUNUSED) {
  SWIG_Error(SWIG_AttributeError,"Variable 
SWIGINTERN PyObject *%s(void) {
	 SWIG_addvarlink(SWIG_globals(),(char*)"%s",%s, %s);
	 PyDict_SetItemString(md, (char*)"%s", PyObject_GetAttrString(SWIG_globals(), "%s"));
	 { (char *)"%s", %s, METH_VARARGS, 
  if (!SWIG_Python_UnpackTuple(args,(char*)"swigconstant", 1, 1,&module)) return NULL;
  if (!PyArg_UnpackTuple(args,(char*)"swigconstant", 1, 1,&module)) return NULL;
  if (!PyArg_ParseTuple(args,(char*)"O:swigconstant", &module)) return NULL;
  d = PyModule_GetDict(module);
SWIGINTERN PyObject *%s_swigconstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
../../Source/Modules/python.cxx
Line indented less than expected (line %d of %s) as no line should be indented less than the indentation in line 1
Whitespace indentation is inconsistent compared to earlier lines (line %d of %s)
SwigPyBuiltin_FunpackSetterClosure
SwigPyBuiltin_FunpackGetterClosure
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
SWIGPY_DESTRUCTOR_CLOSURE(%s)
SWIGINTERN PyGetSetDef %s[] = {
PyDict_SetItemString(d, "this", this_descr);
PyDict_SetItemString(d, "thisown", thisown_descr);
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
static SwigPyGetSet %s = { %s, %s };
{ (char*) "%s", (getter) %s, (setter) %s, (char*)"%s.%s", (void*) &%s }
static PyGetSetDef %s_def = %s;
static_getset = SwigPyStaticVar_new_getset(metatype, &%s_def);
PyDict_SetItemString(d, static_getset->d_getset->name, (PyObject*) static_getset);
%s(PyObject *self, PyObject *other, int op) {
  PyObject *tuple = PyTuple_New(1);
  PyTuple_SET_ITEM(tuple, 0, other);
    case %s : result = %s(self, %s); break;
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
      result = Py_NotImplemented;
SWIGINTERN PyMethodDef %s_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES
Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE
static PyHeapTypeObject %s_type = {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
    &%s_type.as_number,      /* tp_as_number */
    &%s_type.as_sequence,    /* tp_as_sequence */
    &%s_type.as_mapping,     /* tp_as_mapping */
    &%s_type.as_buffer,      /* tp_as_buffer */
feature:python:tp_weaklistoffset
    (Py_ssize_t)offsetof(SwigPyObject, dict), /* tp_dictoffset */
#if PY_VERSION_HEX >= 0x02060000
#if PY_VERSION_HEX >= 0x03040000
#if PY_VERSION_HEX >= 0x02050000
#if PY_VERSION_HEX >= 0x03050000
#if PY_VERSION_HEX < 0x03000000
feature:python:nb_inplace_subtract
feature:python:nb_inplace_multiply
feature:python:nb_inplace_divide
feature:python:nb_inplace_remainder
feature:python:nb_inplace_power
feature:python:nb_inplace_lshift
feature:python:nb_inplace_rshift
feature:python:nb_floor_divide
feature:python:nb_inplace_floor_divide
feature:python:nb_inplace_true_divide
feature:python:nb_matrix_multiply
feature:python:nb_inplace_matrix_multiply
feature:python:mp_ass_subscript
feature:python:sq_inplace_concat
feature:python:sq_inplace_repeat
feature:python:bf_getreadbuffer
feature:python:bf_getwritebuffer
feature:python:bf_getcharbuffer
feature:python:bf_releasebuffer
#if PY_VERSION_HEX >= 0x03030000
SWIGINTERN SwigPyClientData %s_clientdata = {%s, 0, 0, 0, 0, 0, (PyTypeObject *)&%s_type};
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type '%s'.");
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "%s", (PyObject*) builtin_pytype);
    SwigPyBuiltin_AddPublicSymbol(public_interface, "%s");
  builtin_basetype = SWIG_MangledTypeQuery("%s");
  if (builtin_basetype && builtin_basetype->clientdata && ((SwigPyClientData*) builtin_basetype->clientdata)->pytype) {
    builtin_bases[builtin_base_count++] = ((SwigPyClientData*) builtin_basetype->clientdata)->pytype;
    PyErr_SetString(PyExc_TypeError, "Could not create type '%s' as base '%s' has not been initialized.\n");
  SWIG_SetErrorMsg(PyExc_RuntimeError,"accessing abstract class or protected constructor"); 
	 { (char *)"%s", (PyCFunction)%s, METH_NOARGS, 
	 { (char *)"%s", (PyCFunction)%s, METH_O, 
	 { (char *)"%s", (PyCFunction) %s, METH_VARARGS | METH_KEYWORDS, 
%pythonprepend or %feature("pythonprepend")
%pythonappend or %feature("pythonappend")
(PyObject *self, PyObject *args) {
if (!PyTuple_Check(args)) SWIG_fail;
argc = args ? PyObject_Length(args) : 0;
for (ii = 0; (ii < %d) && (ii < argc); ii++) {
argv[ii%s] = PyTuple_GET_ITEM(args,ii);
Py_INCREF(Py_NotImplemented);
SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function '%s'.\n"
"  Possible C/C++ prototypes are:\n"%s);
if (!(argc = SWIG_Python_UnpackTuple(args,"%s",0,%d,argv%s))) SWIG_fail;
, PyObject *args, PyObject *varargs) {
Can't use keyword arguments with overloaded functions (%s).
Can't wrap varargs with keyword arguments enabled
, PyObject *args, PyObject *kwargs) {
    if (!PyArg_ParseTuple(args,(char *)"
    if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"
    if (args && PyTuple_Check(args) && PyTuple_GET_SIZE(args) > 0) SWIG_exception_fail(SWIG_TypeError, "%s takes no arguments");
, int nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
, int nobjs, PyObject **swig_obj) {
if ((nobjs < %d) || (nobjs > %d)) SWIG_fail;
if (!SWIG_Python_UnpackTuple(args,"%s",%d,%d,swig_obj)) SWIG_fail;
if (!SWIG_Python_UnpackTuple(args,"%s",%d,%d,0)) SWIG_fail;
if(!PyArg_UnpackTuple(args,(char *)"%s",%d,%d
upcall = (director && (director->swig_get_self()==%s));
    return resultobj == Py_None ? -1 : 0;
  PyTuple_SET_ITEM(newargs, i, swig_obj[i]);
varargs = PyTuple_New(nobjs > %d ? nobjs - %d : 0);
for (i = 0; i < nobjs - %d; ++i) {
  PyTuple_SET_ITEM(newargs, i, swig_obj[i + %d]);
  Py_XINCREF(swig_obj[i + %d]);
newargs = PyTuple_GetSlice(args,0,%d);
varargs = PyTuple_GetSlice(args,%d,PyTuple_Size(args));
resultobj = %s__varargs__(%s,newargs,varargs);
  SWIG_SetErrorMsg(PyExc_RuntimeError, "accessing abstract class or protected constructor");
  SWIG_fail;
SWIG_SetErrorMsg(PyExc_RuntimeError,"accessing protected member %s");
} catch (Swig::DirectorException&) {
director = SWIG_DIRECTOR_CAST(%s);
  resultobj = director->swig_get_self();
  { "__disown__", (PyCFunction) Swig::Director::swig_pyobj_disown< %s >, METH_NOARGS, "" },
SwigDirector_%s::SwigDirector_%s(PyObject* self) : Swig::Director(self) { 
    SwigDirector_%s(PyObject* self);
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
        swig::SwigVar_PyObject name = SWIG_Python_str_FromChar(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
          std::string msg = "Method in class %s doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        vtable[method_index] = method;
    mutable swig::SwigVar_PyObject vtable[%d];
Base class '%s' ignored - unknown module name for base. Either import the appropriate module interface file or specify the name of the module in the %%import directive.
__swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
__setattr__ = lambda self, name, value: _swig_setattr(self, 
__setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, 
__swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
__getattr__ = lambda self, name: _swig_getattr(self, 
lambda x, v: x.this.own(v), doc='The membership flag')
thisown = _swig_property(lambda x: x.this.own(), 
__setattr__ = _swig_setattr_nondynamic_method(object.__setattr__)
__setattr__ = _swig_setattr_nondynamic_method(type.__setattr__)
    builtin_pytype = (PyTypeObject *)&SwigPyBuiltin_%s_type;
    builtin_pytype->tp_dict = d = PyDict_New();
_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  if (!SWIG_Python_UnpackTuple(args,(char*)"swigregister", 1, 1,&obj)) return NULL;
  if (!PyArg_UnpackTuple(args,(char*)"swigregister", 1, 1,&obj)) return NULL;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE
def __init__(self, *args, **kwargs):
_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
 instance at %p>" % (self.this,)
%s.%s = new_instancemethod(%s.%s, None, %s)
%s_swigregister = %s.%s_swigregister
self->ob_type != ((SwigPyClientData*) (
builtin_staticmembervariableHandler
return !res ? SWIG_Py_Void() : NULL;
(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(args)) {
(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
if (!PyArg_ParseTuple(args,(char *)"O:set",&value)) return NULL;
  { "%s", (PyCFunction) %s, %s, (char*) "%s" },
  { "%s", (PyCFunction) %s, %s, "" },
  { "%s", (PyCFunction) %s, METH_NOARGS, (char*) "%s" },
  { "%s", (PyCFunction) %s, METH_O, (char*) "%s" },
  { "%s", (PyCFunction) %s, METH_VARARGS, (char*) "%s" },
  { "%s", (PyCFunction) %s, METH_VARARGS|METH_KEYWORDS, (char*) "%s" },
%pythoncode or %insert("python") block
%pythonbegin or %insert("pythonbegin") block
#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif
#define SWIG_PYTHON_NO_THREADS
#define SWIG_PYTHON_SAFE_CSTRINGS
#define SWIG_PYTHON_BUILD_NONE
#define SWIG_PYTHON_NO_BUILD_NONE
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
#define SWIG_PYTHON_OUTPUT_TUPLE
#define SWIG_PYTHON_CAST_MODE
#define SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
#if (PY_VERSION_HEX <= 0x02000000)
# if !defined(SWIG_PYTHON_CLASSIC)
#  error "This python version requires swig to be run with the '-classic' option"
#if (PY_VERSION_HEX <= 0x02020000)
# error "This python version requires swig to be run with the '-nomodern' option"
# error "This python version requires swig to be run with the '-nomodernargs' option"
# error "This python version requires swig to be run with the '-nofastunpack' option"
#define SWIG_TypeQuery SWIG_Python_TypeQuery
from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: %s.SWIG_PyInstanceMethod_New(func)
from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
            fp, pathname, description = imp.find_module('%s', [dirname(__file__)])
                _mod = imp.load_module('%s', fp, pathname, description)
    %s = swig_import_helper()
pass  # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
method = class_type.__swig_setmethods__.get(name, None)
if type(value).__name__ == 'SwigPyObject':
object.__setattr__(self, name, value)
raise AttributeError("You cannot add attributes to %s" % self)
return _swig_setattr_nondynamic(self, class_type, name, value, 0)
def _swig_setattr(self, class_type, name, value):
def _swig_getattr_nondynamic(self, class_type, name, static=1):
return _swig_getattr_nondynamic(self, class_type, name, 0)
def _swig_getattr(self, class_type, name):
return object.__getattr__(self, name)
method = class_type.__swig_getmethods__.get(name, None)
return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
strthis = "proxy of " + self.this.__repr__()
def set_attr(self, name, value):
def _swig_setattr_nondynamic_method(set):
raise AttributeError("You cannot add attributes to %s" % self)
if hasattr(self, name) or (name == "this"):
weakref_proxy = weakref.proxy
/*-----------------------------------------------
              @(target):= %s.so
  ------------------------------------------------*/
#  define SWIG_init    PyInit_%s
#  define SWIG_init    init%s
static swig_const_info swig_const_table[] = {
static PyMethodDef SwigMethods[] = {
	 { (char *)"%s", (PyCFunction)%s, METH_O, NULL},
SWIG_PYTHON_INITIALIZE_THREADS;
# This file is compatible with both classic and new-style classes.
static PyTypeObject *builtin_bases[%d];
SWIGPY_TERNARYCALLFUNC_CLOSURE
SWIGPY_SSIZESSIZEARGFUNC_CLOSURE
SWIGPY_SSIZEOBJARGPROC_CLOSURE
SWIGPY_SSIZESSIZEOBJARGPROC_CLOSURE
SWIGPY_FUNPACK_SSIZEARGFUNC_CLOSURE
virtual int PYTHON::constructorHandler(Node*)
void PYTHON::builtin_post_decl(File*, Node*)
String* PYTHON::indent_pythoncode(const String*, const_String_or_char_ptr, String*, int, const char*)
virtual int PYTHON::functionWrapper(Node*)
6PYTHON
%s%s%s%s%s
_p%s
$R_class
$*R_class
$&R_class
p.struct 
rrun.swg
parms = %p
[addMethodInfo] %s
Type: %s
Return type: %s
%s is void ? %s  (%s)
scoerceout
r_swig_cb_data
SEXP r_tmp
r_nprotect
char * r_vmax= 0
r_vmax
int ecode = 0
R_SWIG_EXTERNAL
r_nprotect++;
 R_GlobalEnv,
r_swig_cb_data->expr,
)");
r_swig_cb_data->retValue
return *
SWIG_exception_noreturn
SWIG_exception_fail
setClass('
returnType = '
s_arg%d
SWIGR 1
-dll
-no-init-code
-debug
-copystruct
-nocopystruct
-memoryprof
-nomemoryprof
-aggressivegc
-noaggressivegc
%s%s.R
%sNAMESPACE
export(
exportMethods(
%d) %s
, value
function(x, i, j, ...%s)
%saccessorFuns = list(
operator ()
deref
operator +
operator -
'%s' = %s
'%s'%s
if(is.na(idx)) 
f = accessorFuns[[idx]];
function(...){f(x, ...)};
function(x, name%s)
f(x, value);
setMethod('$%s', '_p%s', 
name = i;
%svaccessors = c(
exportClasses(
"%s"%s
__getitem__
__setitem__
p1 = '%s', p2 = '%s'
t1 = '%s', t2 = '%s'
 && 
`%s` <- function(...) {
argc <- length(argtypes);
argv <- list(...);
# dispatch functions %d
} else 
if (argc == %d) {
rtypecheck
<rtypecheck>%s
%sis.numeric(argv[[%d]])
integer
character
%sis.character(argv[[%d]])
%sextends(argtypes[%d], '%s')
 && length(argv[[%d]]) == 1
) { f <- %s%s; }
f <- %s%s; 
f(...)
# Dispatch function
argv[[%d]]
argtype[%d]
$argtype
$rtype
{"%s", (DL_FUNC) &%s, %d}
#include <R_ext/Rdynload.h>
#ifdef __cplusplus
#endif
   {NULL, NULL, 0}
'_p%s'%s
'C++Reference'
'ExternalReference'
%sCopyToR
obj@%s = value$%s;
obj$%s = value@%s;
processType %s (tdname = %s)
ans = 
<functionWrapper> %s %s %s
R_swig
SWIGEXPORT SEXP
# Start of %s
` = function(
unsigned int r_nprotect = 0
r_ans = R_NilValue
SEXP
r_ans
r_vmax = vmaxget()
VMAXTYPE
tmap:scoercein
)) {
if(is.function(
)) >= 
)) || length(formals(
if(is.character(
@ref;
, "ExternalReference")) {
if(is(
$address
, "NativeSymbolInfo")) {
 = getNativeSymbolInfo(
tmap:scheck
if(TYPEOF(%s) != CLOSXP) {
SEXP 
%s%s='%s'
%sSEXP s_swig_copy
as.logical(.copy), 
R_SWIG_OWNER
SEXP R_OutputValues
Rf_protect(r_ans);
r_ans = R_OutputValues;
.Call('
PACKAGE='
R_ClearExternalPtr(self);
return r_ans;
# End of %s
`, 'returnType') = '
attr(`
`, "inputTypes") = c(
class(`
memory.profile()
gc()
%s'%s'
%s.copy = FALSE
snamespace
useDynLib(%s)
sinit
sinitroutine
sclasses
%s%s%s'%s' = %d%s
defineEnumeration('
.values = c(
.copy
_get(
if(missing(value)) {
_set(value)
%s = %s_get
, .copy = FALSE
%s = 
function(value%s)
feature:opaque
%s%s = "%s"
# End class %s
<typedefHandler> %s
*** Unable to open 'rrun.swg'
<createFunctionPointerHandler> Defining %s
RCallbackFunctionData *r_swig_cb_data = R_SWIG_getCallbackFunctionData()
Setting number of parameters to %d
SETCAR(r_swig_cb_data->el, %s);
r_swig_cb_data->el = CDR(r_swig_cb_data->el);
Rf_protect(%s->expr = Rf_allocVector(LANGSXP, %d));
r_swig_cb_data->el = r_swig_cb_data->expr;
SETCAR(r_swig_cb_data->el, r_swig_cb_data->fun);
 &r_swig_cb_data->errorOccurred
r_swig_cb_data->retValue = R_tryEval(
Rf_error("error in calling R function as a function pointer (
R_SWIG_popCallbackFunctionData(1);
if(r_swig_cb_data->errorOccurred) {
prototype = list(parameterTypes = c(
contains = 'CRoutinePointer')
vmaxset(r_vmax);
if(r_nprotect)  Rf_unprotect(r_nprotect);
R Options (available with -r)
     -copystruct      - Emit R code to copy C structs (on by default)
     -cppcast         - Enable C++ casting operators (default) 
     -debug           - Output debug
     -dll <name>      - Name of the DLL (without the .dll or .so suffix).
                        Default is the module name.
     -gc              - Aggressive garbage collection
     -memoryprof      - Add memory profile
     -namespace       - Output NAMESPACE file
     -no-init-code    - Turn off the generation of the R_init_<pkgname> code
                        (registration information still generated)
     -package <name>  - Package name for the PACKAGE argument of the R .Call()
                        invocations. Default is the module name.
setClass('C++Reference', contains = 'ExternalReference')
idx = pmatch(name, names(accessorFuns));
return(callNextMethod(x, name%s));
if (is.na(match(name, vaccessors))) function(...){f(x, ...)} else f(x);
# end of accessor method for %s
# Start of accessor method for %s
setMethod('[[<-', c('_p%s', 'character'),
# start of array methods for %s
# end of array methods for %s
setMethod('[', '_p%s', function(x, i, j, ..., drop =TRUE) 
  sapply(i, function (n)  %s(x, as.integer(n-1))))
setMethod('[<-', '_p%s', function(x, i, j, ..., value)
  sapply(1:length(i), function(n) %s(x, as.integer(i[n]-1), value[n])))
Adding accessor: %s (%s) => %s
argtypes <- mapply(class, list(...));
%s(is.integer(argv[[%d]]) || is.numeric(argv[[%d]]))
} else {
stop("cannot find overloaded function for %s with argtypes (",toString(argtypes),")");
SWIGINTERN R_CallMethodDef CallEntries[] = {
SWIGEXPORT void R_init_%s(DllInfo *dll) {
%sR_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
setClass('%s', contains = %s)
generateCopyRoutines:  name = %s, %s
CopyToR%s = function(value, obj = new("%s"))
CopyToC%s = function(value, obj)
# Start definition of copy functions & methods for %s
# Start definition of copy methods for %s
setMethod('copyToR', '_p_%s', CopyToR%s);
setMethod('copyToC', '%s', CopyToC%s);
# End definition of copy methods for %s
# End definition of copy functions & methods for %s
##   Generated via the command line invocation:
<processType> Defining class %s
setClass('%s', contains = 'ExternalReference')
<processType> Defining pointer handler %s
<functionWrapper> processing parameters
<functionWrapper> unresolved_return_type %s
<functionWrapper memberAccess> '%s' '%s' '%s' '%s'
Adding a .copy argument to %s for %s = %s
+++  parameter name with :: in it %s
assert('...' %in% names(formals(
} else {
%s = %s;
R_SWIG_pushCallbackFunctionData(%s, NULL);
Rf_protect(R_OutputValues = Rf_allocVector(VECSXP,%d));
r_nprotect += %d;
SET_VECTOR_ELT(R_OutputValues, 0, r_ans);
reg.finalizer(ans@ref, delete_%s)
`) = c("SWIGFunction", class('
#ifndef SWIGR
#define SWIGR
#endif
Typedef in the class declaration for %s
setMethod('delete', '_p%s', function(obj) {delete%s(obj)})
%scontains = "RSWIGStruct")
setClass("%s",
%srepresentation(
<typedefHandler> Defining S class %s
setClass('_p%s', contains = 'ExternalReference')
<membervariableHandler> name = %s, sym:name = %s
<membervariableHandler> %s %s
<memberfunctionHandler> %s %s
(9I"
>swigrubyrun.h
rubyhead.swg
rubyerrors.swg
rubytracking.swg
rubyapi.swg
rubyrun.swg
feature:numoutputs
feature:initstack
SWIG_INIT_STACK;
VALUE %s
%s_%s_body
%s_%s_rescue
%s_%s_call_depth
static int %s = 0;
VALUE %s(VALUE data) {
Swig::body_args *
%s++;
%s--;
if (%s == 0) 
rb_exc_raise(error);
Swig::body_args
status
args.recv = swig_get_self();
args.id = rb_intern("%s");
args.argc = %d;
args.argv = new VALUE[%d];
args.argv[%d] = obj%d;
args.argv = 0;
delete [] args.argv;
SWIG_RELEASE_STACK;
VALUE output
if (TYPE(%s) != T_ARRAY) {
if (status) {
-initname
-feature
-globalmodule
-minherit
-autorename
-noautorename
SWIG_RUBY_AUTORENAME
SWIGRUBY 1
ruby.swg
Wrong %s name %s
rb_cObject
Parameters:
    %s.
  Document-class: %s
 < %s
  Document-method: %s.new
  Document-method: %s.%s
  Document-method: %s.%s=
  call-seq:
    %s(%s)
    %s
    %s=(x)
  Proxy of C++ %s class
  Proxy of C %s struct
    %s.new(%s)
    %s.new
Class constructor.
A class method.
A module function.
An instance method.
Get value of attribute.
Set new value for attribute.
$class
ruby:docstring
ruby:autodoc
SWIGINTERN VALUE
VALUE self
VALUE _val
return _val;
  return Qnil;
(VALUE self, 
VALUE _val) {
VALUEFUNC(
rb_define_singleton_method(
, 0);
, 1);
=", 
../../Source/Modules/ruby.cxx
current == NO_CPP
rb_define_global_method("
rb_define_method
rb_define_protected_method
, -1);
rb_define_alloc_func(
$allocator
, "initialize", 
$initializer
rb_define_method(
rb_define_module_function(
rb_define_global_function("
feature:alias
rb_define_alias(
return %s(nargs, args, self);
SWIGINTERN VALUE 
nargs, args, self
"    
)\n"
return Qnil;
VALUE argv[%d]
argc = nargs + 1;
if (argc > %d) SWIG_fail;
argv[ii] = args[ii-1];
argc = nargs;
argv[ii] = args[ii];
feature:predicate
feature:bang
(VALUE self) {
if (argc < %d) 
    if (argc > %d) {
"arg%d",
const char *kwnames[] = 
vresult
DATA_PTR(self) = %s;
feature:trackobjects
 ? Qtrue : Qfalse);
vresult = (
vresult = rb_ary_new();
return vresult;
return self;
VALUE vresult = Qnil
smart
%s *%s = 0
%s = new %s(%s);
klass != 0
static swig_class SwigClass
 = rb_define_class_under(
", $super);
 = rb_define_class("
, "Impl");
 = rb_define_module_under(
feature:mixin
((swig_class *) SWIGTYPE
->clientdata)->mImpl
rb_include_module(
->clientdata)->klass
$super
feature:markfunc
SwigClass%s.mark = 0;
feature:freefunc
rb_undef_alloc_func(
rb_eRuntimeError
(void *self) {
SWIGINTERN void
 *)self;
SWIG_RubyRemoveTracking(%s);
delete %s;
free((char*) %s);
%n%c_allocate
ruby:constructorHandler
new_%n%c
SwigClass%s.klass
SwigClass%s.mImpl
rb_require("%s");
ruby_globalmodule
ruby_minherit
director_helpers
inspect
to_s
__cmp__
__hash__
nonzero?
__nonzero__
__call__
__len__
__pos__
__lshift__
__rshift__
__xor__
__invert__
__divmod__
__pow__
__abs__
to_i
__int__
to_f
__float__
__coerce__
  class Director;
#define SWIG_init    Init_%s
static VALUE %s;
SWIGEXPORT void Init_
extern "C"
size_t i;
(void) {
SWIG_InitRuntime();
 = rb_define_module("
SWIG_InitializeModule(0);
*** Unable to open 'rubyhead.swg'
*** Unable to open 'rubyerrors.swg'
*** Unable to open 'rubytracking.swg'
*** Unable to open 'rubyapi.swg'
*** Unable to open 'rubyrun.swg'
Adding native function %s not supported (ignored).
= reinterpret_cast<Swig::body_args *>(data)
 = rb_funcall2(args->recv, args->id, args->argc, args->argv);
VALUE %s(VALUE args, VALUE error) {
%s = rb_protect(PROTECTFUNC(%s), reinterpret_cast<VALUE>(&args), &status);
%s = rb_funcall(swig_get_self(), rb_intern("%s"), %d%s);
%s = rb_funcall(swig_get_self(), rb_intern("%s"), 0, NULL);
Ruby_DirectorTypeMismatchException("Ruby method failed to return an array.");
output = rb_ary_entry(%s, %d);
VALUE lastErr = rb_gv_get("$!");
%s(reinterpret_cast<VALUE>(&args), lastErr);
Warning: Ruby -feature option is deprecated, please use -initname instead.
Ruby Options (available with -ruby)
     -autorename     - Enable renaming of classes and methods to follow Ruby coding standards
     -cppcast        - Enable C++ casting operators (default)
     -globalmodule   - Wrap everything into the global module
     -initname <name>- Set entry function to Init_<name> (used by `require')
     -minherit       - Attempt to support multiple inheritance
     -noautorename   - Disable renaming of classes and methods (default)
     -nocppcast      - Disable C++ casting operators, useful for generating bugs
     -prefix <name>  - Set a prefix <name> to be prepended to all names
Wrong %s name (corrected to `%s')
Unable to set variable of type %s
(int nargs, VALUE *args, VALUE self) {
Ruby_Format_OverloadedError( argc, %d, "%s", %s);
for (ii = 1; (ii < argc); ++ii) {
for (ii = 0; (ii < argc); ++ii) {
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
(int argc, VALUE *argv, VALUE self) {
if ((argc < %d) || (argc > %d)) 
{rb_raise(rb_eArgError, "wrong # of arguments(%%d for %d)",argc); SWIG_fail;}
const char *classname SWIGUNUSED = "%s::%s"
SWIG_RubyAddTracking(%s, self);
} catch (Swig::DirectorException& e) {
  rb_exc_raise(e.getError());
Unable to use return type %s.
VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE%s);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
rb_obj_call_init(vresult, argc, argv);
if (vresult == Qnil) vresult = rb_ary_new();
else vresult = SWIG_Ruby_AppendOutput( rb_ary_new(), vresult);
upcall = (director && (director->swig_get_self() == self));
director = dynamic_cast<Swig::Director *>(%s);
  vresult = director->swig_get_self();
  rb_raise(rb_eRuntimeError,"accessing abstract class or protected constructor"); 
SwigDirector_%s::SwigDirector_%s(VALUE self) : Swig::Director(self) { }
    SwigDirector_%s(VALUE self);
SWIG_TypeClientData(SWIGTYPE%s, (void *) &SwigClass%s);
rb_include_module(%s, rb_eval_string("%s"));
Warning for %s proxy: Base %s ignored. Multiple inheritance is not supported in Ruby.
SwigClass%s.mark = (void (*)(void *)) %s;
SwigClass%s.destroy = (void (*)(void *)) %s;
SwigClass%s.destroy = (void (*)(void *)) free_%s;
SwigClass%s.trackObjects = 1;
SwigClass%s.trackObjects = 0;
  rb_raise(rb_eNameError,"accessing abstract class or protected constructor"); 
strcmp(rb_obj_classname(self), classname) != 0
#ifndef SWIGRUBY
#define SWIGRUBY
#endif
 * C++ director class helpers
SWIG_define_class(swig_module.types[i]);
for (i = 0; i < swig_module.size; i++) {
SWIG_RubyInitializeTrackings();
virtual int RUBY::classHandler(Node*)
virtual int RUBY::variableWrapper(Node*)
void RUBY::create_command(Node*, const_String_or_char_ptr)
4RUBY
SWIGSEXP 1
-typemaplang
csym:previousSibling
typepass:visit
%p%c
#%d#
#%d=
#<DOH %s %p>
typescope
_wrap.cxx
S-Exp Options (available with -sexp)
     -typemaplang <lang> - Typemap language
;;; Lisp parse tree produced by SWIG
4Sexp
-builder
-buildersources
-buildercflags
-builderldflags
-builderverbositylevel
-builderflagscript
-gatewayxml
SWIGSCILAB 1
scilab.swg
feature:scilab:const
scilabconstcode
(SWIG_GatewayParameters) {
return SWIG_OK;
table = [table;
"%s","%s";
  '%s'; ..
(SWIG_GatewayParameters) {
$mininputarguments
$maxinputarguments
$minoutputarguments
$maxoutputarguments
int argv[%d] = {
return SWIG_ERROR;
lib%s
builder.sce
#include "addfunction.h"
#define MODULE_NAME L"%s"
mode(-1);
lines(0);
originaldir = pwd();
cd(builddir);
ilib_verbose(%s);
libs = [];
cflags = [];
cflags = cflags + " %s";
ldflags = "%s";
ldflags = ldflags + " %s";
ldflags = [];
exec("%s");
files = "%s";
files($ + 1) = "%s";
table = [
%s_gateway.xml
<!--
<GATEWAY name="%s">
loader.sce
[bOK, ilib] = c_link('%s');
if bOK then
  ulink(ilib);
list_functions = [..
%s_Init
SWIG_this
SWIG_ptr
  return SWIG_OK;
ierr = 0;
if ~isempty(table) then
  if ierr <> 0 then
    err_msg = lasterror();
  end
cd(originaldir);
  error(ierr, err_msg);
return 0;
<module>
int C2F(%s)() {
  Rhs = Max(0, Rhs);
    if(pvApiCtx == NULL) {
</GATEWAY>
clear %s_path;
clear bOK;
clear ilib;
clear list_functions;
 Scilab options (available with -scilab)
      -builder                        - Generate a Scilab builder script
      -buildercflags <cflags>         - Add <cflags> to the builder compiler flags
      -builderflagscript <file>       - Set the Scilab script <file> to use by builder to configure the build flags
      -builderldflags <ldflags>       - Add <ldflags> to the builder linker flags
      -buildersources <files>         - Add the (comma separated) files <files> to the builder sources
      -builderverbositylevel <level>  - Set the builder verbosity level to <level> (default 0: off, 2: high)
      -gatewayxml <gateway_id>        - Generate gateway xml with the given <gateway_id>
Identifier name '%s' exceeds 24 characters and has been truncated to '%s'.
SWIG_CheckInputArgument(pvApiCtx, 0, 0);
SWIG_CheckOutputArgument(pvApiCtx, 1, 1);
SWIG_Scilab_SetApiContext(pvApiCtx);
SWIG_Scilab_SetOutputPosition(%d);
static GenericTable Tab[] = {
 {(Myinterfun)sci_gateway, (GT)%s, (char *)"%s"}
if (wcscmp(pwstFuncName, L"%s") == 0) { addCFunction((wchar_t *)L"%s", &%s, (wchar_t *)MODULE_NAME); }
<PRIMITIVE gatewayId="%s" primitiveId="%d" primitiveName="%s"/>
SWIG_CheckInputArgument(pvApiCtx, 1, 1);
SWIG_CheckInputArgument(pvApiCtx, $mininputarguments, $maxinputarguments);
SWIG_CheckInputArgumentAtLeast(pvApiCtx, $mininputarguments-1);
SWIG_CheckOutputArgument(pvApiCtx, $minoutputarguments, $maxoutputarguments);
SWIG_Scilab_SetFuncName(fname);
if (SWIG_NbInputArgument(pvApiCtx) > %d) {
return %s(SWIG_GatewayArguments);
int argc = SWIG_NbInputArgument(pvApiCtx)
Scierror(999, _("No matching function for overload"));
Wrapping functions names for member '%s.%s' will exceed 24 characters, so member name has been truncated to '%s'.
Wrapping functions names for member '%s.%s' will exceed 24 characters, please rename the container of member '%s'.
#ifndef SWIGSCILAB
#define SWIGSCILAB
#endif
#include "c_gateway_prototype.h"
int %s(wchar_t *pwstFuncName) {
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------- */
builddir = get_absolute_file_path('builder.sce');
cflags = cflags + getCompilationFlags();
ldflags = ldflags + getLinkFlags();
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
This file was automatically generated by SWIG (http://www.swig.org).
Do not make changes to this file unless you know what you are doing - modify
the SWIG interface file instead.
%s_path = get_absolute_file_path('loader.sce');
int SWIG_CreateScilabVariables(void *_pvApiCtx) {
  ierr = execstr("ilib_build(''%s'', table, files, libs, [], ldflags, cflags);", 'errcatch');
  if (*(Tab[Fin-1].f) != NULL) {
      pvApiCtx = (StrCtx *)MALLOC(sizeof(StrCtx));
    pvApiCtx->pstName = (char *)Tab[Fin-1].name;
    (*(Tab[Fin-1].f))(Tab[Fin-1].name,(GatefuncH)Tab[Fin-1].F);
#if SWIG_SCILAB_VERSION >= 600
addinter(fullfile(%s_path, '%s' + getdynlibext()), '%s', list_functions);
6SCILAB
-chicken
-allegrocl
ALLEGROCL
SWIG_FEATURES
-tcl
-nolang
--help
Target Language Options
CHICKEN
-clisp
CLISP
-cffi
CFFI
-csharp
-guile
Guile
-java
Java
-javascript
Javascript
-lua
-modula3
Modula 3
-mzscheme
Mzscheme
-ocaml
Ocaml
-octave
Octave
-perl
Perl
-perl5
-php
-php4
-php5
-pike
Pike
-python
Python
R (aka GNU S)
-ruby
Ruby
-scilab
Scilab
-sexp
Lisp S-Expressions
-tcl8
-uffi
Common Lisp / UFFI
-xml
     %-15s - Generate %s wrappers
swigtclrun.h
tclerrors.swg
tclapi.swg
tclrun.swg
SWIGINTERN int
objv[%d]
,(void *)0
if (objc > %d) {
,&%s
p.void
,SWIGTYPE%s
%s::%s 
(Tcl_GetObjResult(interp))
return TCL_OK;
return TCL_ERROR;
", (swig_wrapper_func) 
{ SWIG_prefix "
, NULL},
SWIGINTERN int
int argc = objc-1;
) == TCL_ERROR) SWIG_fail;
SWIGINTERN const char *
Tcl_Obj *value = 0
if (value) {
Tcl_DecrRefCount(value);
return "%s";
Tcl_Obj *name1o = 0
name1o
Tcl_DecrRefCount(name1o);
if (!value) SWIG_fail;
", 0, (swig_variable_func) 
-pkgversion
-itcl
-nosafe
SWIGTCL 1
SWIGTCL8 1
tcl8.swg
static swig_attribute swig_
_attributes[] = {
static swig_method swig_
_methods[] = {
SWIGINTERN void swig_delete_
Ptr::constructor $ptr
Ptr {
itcl::class 
  inherit 
  protected variable thisown
  protected variable swigobj
  protected method 
      r {set $var [
    switch -exact -- $op {
      w {
_[set var]_get $swigobj]}
  constructor { ptr } {
  } {
    set thisown 0
    set swigobj $ptr
    set d_func delete_
  destructor {
  constructor { } {
" } {
    if { [info class] == "::
static swig_class *swig_
static const char * swig_
, swig_delete_
_attributes, swig_
_methods, swig_
_bases,
  constructor { 
} { 
} } 
::new_
Ptr::constructor [
Ptr::constructor [new_
    set thisown 1
{ "-
0 },
  public variable 
_swig_getset 
 rw [list 
    trace variable 
    set 
 $swigobj
%(lower)s
%(title)s_Init
%s%s.itcl
package require Itcl
#define SWIG_init    %s
#define SWIG_prefix  "%s::"
#define SWIG_namespace "%s"
#define SWIG_prefix  "%s"
#define SWIG_version "%s"
{0, 0, 0}
{0,0,0,0}
{0,0,0,0,0,0}
return TCL_OK;
*** Unable to open 'tclerrors.swg'
*** Unable to open 'tclapi.swg'
*** Unable to open 'tclrun.swg'
	 Tcl_CreateObjCommand(interp, SWIG_prefix "%s", (swig_wrapper_func) %s, (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
return %s(clientData, interp, objc, argv - 1);
Tcl_Obj *CONST *argv = objv+1;
Tcl_SetResult(interp,(char *) "Wrong number or type of arguments for overloaded function '%s'.\n"
"  Possible C/C++ prototypes are:\n"%s, TCL_STATIC);
if (SWIG_GetArgs(interp, objc, objv,
(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2, int flags) {
Tcl_SetVar2(interp,name1,name2,Tcl_GetStringFromObj(value,NULL), flags);
(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2 SWIGUNUSED, int flags) {
name1o = Tcl_NewStringObj(name1,-1);
value = Tcl_ObjGetVar2(interp, name1o, 0, flags);
SWIGINTERN const char *swig_readonly(ClientData clientData SWIGUNUSED, Tcl_Interp *interp SWIGUNUSED, char *name1 SWIGUNUSED, char *name2 SWIGUNUSED, int flags SWIGUNUSED) {
return "Variable is read-only";
(swig_variable_func) swig_readonly},
Tcl 8 Options (available with -tcl)
     -itcl           - Enable ITcl support
     -nosafe         - Leave out SafeInit module function.
     -prefix <name>  - Set a prefix <name> to be prepended to all names
     -namespace      - Build module into a Tcl 8 namespace
     -pkgversion     - Set package version
_swig_getset {var name1 name2 op} {
_${var}_set $swigobj [set $var]}
    if { $thisown && ([info command $d_func] != "") } {
      $d_func $swigobj
    # This constructor will fail if called directly
      error "No constructor for class 
static swig_class _wrap_class_
_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_
" "[namespace tail [info class]]" ] } {
    if { [string equal -nocase "
#ifndef SWIGTCL
#define SWIGTCL
#endif
static swig_command_info swig_commands[] = {
static swig_var_info swig_variables[] = {
static swig_const_info swig_constants[] = {
SWIGEXPORT int %(title)s_SafeInit(Tcl_Interp *interp) {
    return SWIG_init(interp);
4TCL8
Nothing known about '%s'.
{ self->%s(
{ return self->%s(
); }
_SWIG_0
%s_%d
%s + 1
(%s) + %d
virtenumvalue
See definition of '%s'.
Base class '%s' undefined.
(%s *)%s
previous wrap of '%s'.
../../Source/Modules/typepass.cxx
strcmp(Char(nodeType(c)), "enumitem") == 0
Base class '%s' has no name as it is an empty template instantiated with '%%template()'. Ignored.
The %%template directive must be written before '%s' is used as a base class and be declared with a name.
'%s' is not a valid base class.
Base class '%s' is incomplete.
Only forward declaration '%s' was found.
'%s' must be defined before it is used as a base class.
Maybe you forgot to instantiate '%s' using %%template.
    *newmemory = SWIG_CAST_NEW_MEMORY;
    return (void *) new %s(*(%s *)$from);
Base class '%s' of '%s' is not similarly marked as a smart pointer.
Derived class '%s' of '%s' is not similarly marked as a smart pointer.
Recursive scope inheritance of '%s'.
Nothing known about base class '%s'. Ignored.
Template '%s' was already wrapped,
virtual int TypePass::enumDeclaration(Node*)
8TypePass
SWIGUFFI 1
uffi.swg
#.(%s "%s" :type :type)
:pointer-void
(swig-defun "%s"
  :returning %s
#| varargs |#
(%s %s %s)
(swig-def-struct "%s"
Out of memory
UFFI Options (available with -uffi)
     -identifier-converter <type or funcname> - 
                       Specifies the type of conversion to do on C identifiers
                       to convert them to symbols. There are two built-in
                       converters: 'null' and 'lispify'. The default is
                       'null'. If you supply a name other than one of the
                       built-ins, then a function by that name will be
                       called to convert identifiers to symbols.
Unsupported data type: %s (was: %s)
  (#.(%s "%s" :type :slot) %s)
;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp; Base: 10; package: %s -*-
(defpackage :%s
  (:use :common-lisp :uffi))
(in-package :%s)
(eval-when (compile load eval)
  (defparameter *swig-identifier-converter* '%s))
4UFFI
SWIGXML 1
-xmllang
-xmllite
&amp;
&lt;
&quot;
&#10;
</baselist >
<%s id="%ld" addr="%p" >
</%ssitem >
</%s >
typetab
parmlist
<parm id="%ld">
</parm >
</attributelist >
<?xml version="1.0" ?> 
XML Options (available with -xml)
     -xmllang <lang> - Typedef language
     -xmllite        - More lightweight version of XML
     ------
     deprecated (use -o): -xml <output.xml> - Use <output.xml> as output file (extension .xml mandatory)
<attributelist id="%ld" addr="%p" >
<attribute name="module" value="%s" id="%ld" addr="%p" />
<baselist id="%ld" addr="%p" >
<base name="%s" id="%ld" addr="%p" />
<%ssitem id="%ld" addr="%p" >
<attribute name="%s" value="%s" id="%ld" addr="%p" />
<attribute name="%s" value="%p" id="%ld" addr="%p" />
3XML
../../Source/Preprocessor/cpp.c
Unterminated call invoking macro '%s'
Illegal macro argument name '%s'
Variable length macro argument must be last parameter
Illegal character in macro argument name
Missing ')' in macro parameters
Unterminated character constant
Missing identifier for #ifdef.
Missing identifier for #ifndef.
Unexpected tokens after #else directive.
Unexpected tokens after #endif directive.
Could not evaluate expression '%s'
Missing expression for #elif.
CPP #error "%s". Use the -cpperraswarn option to continue swig processing.
Both includeall and importall are defined: using includeall.
%%includefile "%s" %%beginfile
%%importfile "%s" %%beginfile
cpp debug: level = %d, startlevel = %d
Unknown SWIG preprocessor directive: %s (if this is a block of target language code, delimit it with %%{ and %%})
%%extern is deprecated. Use %%import instead.
Missing #endif for conditional starting here
Missing %%endoffile for file inclusion block starting here
Missing %%enddef for macro starting here
Unterminated %%{ ... %%} block
Macro '%s' expects %d arguments
Macro '%s' expects 1 argument
Macro '%s' expects no arguments
/*@SWIG:%s,%d,%s@*/%s/*@SWIG@*/
No arguments given to defined()
Unterminated call to '%s'
Unable to find '%s'
else
endif
*expanded*
ifdef
ifndef
swigmacro
undef
%include
%extern
%define
%line
__LINE__
__FILE__
#elif
__VA_ARGS__
Macro '%s' redefined,
previous definition of '%s'.
SWIGIMPORTED 1
Unterminated string constant
%%constant %s = %s;
%%constant %s = %s; /*%s*/
Misplaced #else.
Extraneous #endif.
Error: '%s'
Missing expression for #if.
Misplaced #elif.
CPP #warning, "%s".
CPP #error "%s".
SWIGIMPORTED
SWIG 
cpperraswarn=
Unknown SWIG pragma: %s
%%import
%sfile%s%s%s"%s" %%beginfile
enddef
Unterminated comment
nowarn=
`%s`
macro_additional_lines >= 0
expand_macro
find_args
Preprocessor_replace
Preprocessor_undef
Preprocessor_define
../../Source/Preprocessor/expr.c
Syntax error: attempt to apply unary operator to string
Missing left-hand side for binary operator
Can't mix strings and integers in expression
Syntax error: bad binary operator for strings
Internal error in expression evaluator.
Syntax error: expected operator
sp > 0
stack[sp - 1].op == EXPR_OP
Right-hand side is not value
Syntax error: bad operator
scan
Expected an expression
Missing ')'
Syntax error
Extra ')'
reduce_op
Preprocessor_expr
%s = (%s) &%s_defvalue
%s = (%s) &%s_defrvalue
void *%s = 0
%s = (%s) %s
(this)->
*this
SWIGTEMPLATEDISAMBIGUATOR 
enum $unnamed
%s = (%s) &
%s = (%s) &%s
%s = (%s)
calloc(1, sizeof(%s))
new %s(
if (%s) *(%s)&%s%s = %s
if (%s) %s%s = %s
%s (%s%s)
$wrapname
$overname
$decl
$fulldecl
$parentclasssymname
$parentclassname
SWIGINTERN %s
q(const)
(*(this))->
(*(%s const *)this)->
(*this)->
qname
} else {
if (upcall) {
(%s*)(%s)->operator ->()
feature:nounref
$this
feature:noref
feature:ref
free((char *) %s);
delete %s;
../../Source/Swig/cwrap.c
classNode != 0
$comparison
darg->
%s = %s;
%s::SWIGTEMPLATEDISAMBIGUATOR %s(
if (%s && sizeof(int) == sizeof(%s%s)) *(int*)(void*)&(%s%s) = %s
Swig::DirectorPureVirtualException::raise("%s::%s");
(%s const *)((%s const *)%s)->operator ->()
if (sizeof(int) == sizeof(%s)) *(int*)(void*)&(%s) = %s;
Swig_directorclass
%s(%d) 
%s(999999) 
%s:%d
%s:EOF
Warning
%s: %s %%d: 
%s: %s: 
[EMPTY]
[NULL]
%%extend definition of '%s'.
Identifier '%s' redefined by %%extend (ignored),
%%extend defined for an undeclared class %s.
Fragment '%s' not found.
Bad section '%s' in %%fragment declaration for code fragment '%s'
../../Source/Swig/getopt.c
argc > 0
marked
(n >= 0) && (n < numargs)
swig error : Unrecognized option %s
Use 'swig -help' for available options.
Must specify an input file. Use -help for available options.
SWIG : Unable to parse command line options.
Swig_check_options
Swig_check_marked
Swig_mark_arg
Swig_init_args
../../Source/Swig/include.c
filename
  Open: %s
lastpath
pdirectories
pdirname
Swig_read_file
Swig_open_file
Swig_search_path_any
Swig_last_file
Swig_push_directory
Swig_add_directory
%1024s
%%.%ds
%s Version %s
externc 
_SS_
_S%c_
_S%02X_
PCRE Version: %s
escape
upper
lower
lctitle
utitle
typecode
schemify
strip
regex
lowercamelcase
undercase
firstuppercase
firstlowercase
Command encoder fails attempting '%s'.
/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version %s
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */
%s This file was automatically generated by SWIG (http://www.swig.org).
%s Do not make changes to this file unless you know what you are doing--modify
%s the SWIG interface file instead.
Cannot create directory %s: %s
Cannot create directory %s: it may already exist but not be a directory
Cannot create subdirectory %s under the base directory %s. Either the base does not exist as a directory or it is not readable.
PCRE capture replacement failed while matching "%s" using "%s" - request for group %d is greater than the number of captures %d.
Unrecognized escape character '%c' in the replacement string "%s".
Invalid regex substitution: '%s'.
PCRE compilation failed: '%s' in '%s':%i.
PCRE execution failed: error %d while matching "%s" using "%s".
notmatch
notregexmatch
attrlist
matchlist
start
_wrap_%f
%n%c_%m
%n%v_get
%n%v_set
copy_%n%c
delete_%n%c
disown_%n%c
*::%s::%s
*::%s
targetfmt
fullname
sourcefmt
regextarget
targetname
continue
 const
%s(%s)%s
Invalid regex "%s": compilation failed at %d: %s
Matching "%s" against regex "%s" failed: %d
../../Source/Swig/scanner.c
n <= l
s && txt
Unterminated string
Unterminated block
Unterminated code block
Unterminated wide string
/*@SWIG@*/
(nt >= 0) && (nt < SWIG_MAXTOKENS)
Syntax error. Extraneous '%%}'
Unterminated wide character constant
Unterminated wide character literal
retract
Scanner_pushtoken
Scanner_push
Scanner_clear
DelScanner
unsigned int
unsigned short
unsigned long
unsigned char
unsigned long long
).p.
).r.
enum SWIGTYPE
a().
a(ANY).
f(ANY).SWIGTYPE
m(CLASS).SWIGTYPE
../../Source/Swig/stype.c
)>%s
enum ::
SwigType_default_deduce
SYMBOL TABLES start  =======================================
SYMBOL TABLES finish =======================================
SYMBOL TABLES SUMMARY start  =======================================
SYMBOL TABLES SUMMARY finish =======================================
SYMBOLS start  =======================================
SYMBOLS finish =======================================
CSYMBOLS start  =======================================
CSYMBOLS finish =======================================
Declaration of '%s' shadows template parameter,
previous template parameter declaration '%s'.
  %s (%s)
csymtab
symboltable
../../Source/Swig/symbol.c
ccurrent
current_symtab
Getattr(nn, "sym:overname")
__SWIG_%d
use_inherit==1
!Getattr(n, "sym:overname")
Swig_symbol_remove
Swig_symbol_clookup_no_inherit
Swig_symbol_clookup_local_check
Swig_symbol_clookup_local
Swig_symbol_clookup_check
Swig_symbol_clookup
Swig_symbol_add
Swig_symbol_popscope
Swig_symbol_setscope
%s . %s
%s . %s
%-12s - %s
%-12s - "%(escape)-0.80s%s"
%-12s - %p
prevSibling
%s:view
../../Source/Swig/tree.c
+++ %s - %p ----------------------------------------
Fatal error (Swig_require).  Missing attribute '%s' in node '%s'.
Swig_save('%s','%s'): Warning, attribute '%s' was already saved.
Swig_restore
Swig_require
../../Source/Swig/typeobj.c
*c != '.'
check == 0
q(%s).
p.f(
SwigType_isfunctionpointer(t)
m(%s).
SwigType_isarray(t)
a(%s)
Fatal error. SwigType_pop_function applied to non-function.
SwigType_pop_arrays
SwigType_del_array
SwigType_del_memberpointer
SwigType_functionpointer_decompose
SwigType_del_qualifier
SwigType_del_rvalue_reference
SwigType_del_reference
SwigType_del_pointer
SwigType_parmlist
../../Source/Swig/typemap.c
*tmhash == 0
Registering - %s
%s-%s+%s:
%s:warning
  Looking for: %s
_global_
$TYPEMAP
$typemap
$%d_
$dim%d
$parmname
$ltype
$mangle
$descriptor
$*type
$*%d_type
$*ltype
$*%d_ltype
$*mangle
$*%d_mangle
$*descriptor
$*%d_descriptor
$&type
$&%d_type
$&ltype
$&%d_ltype
$&mangle
$&%d_mangle
$&descriptor
$&%d_descriptor
$basetype
$basemangle
$lextype
$%d.
(&$%d)->
  Using: %%%s
  None found
tmap:match
Typemap for %s (%s) : %%%s
typemap(%s) %s
typemap(%s) %s = %s
apply %s { %s }
tmap:%s:match_type
pass
%s:SWIGTYPE
%s:locals
%s:fragment
  Containing: %s
<error in embedded typemap>
$TYPEMAP(
No typemap found for %s
actioncode
Cmp(tmap_method, "out") == 0
Searching for a suitable '%s' typemap for: %s
  Multi-argument typemap found...
Getfile(parms) && Len(Getfile(parms)) > 0
Likely recursive $typemap calls containing %s. Use -debug-tmsearch to debug.
Getfile(node) && Len(Getfile(node)) > 0
Multiple calls to %s might be generated due to
optimal attribute usage in the out typemap.
Method %s usage of the optimal attribute ignored
in the out typemap as the following cannot be used to generate optimal code: %s
---[ typemaps ]--------------------------------------------------------------
-----------------------------------------------------------------------------
typemap_search_multi
split_embedded_typemap
Swig_typemap_lookup_impl
Swig_typemap_lookup_out
set_typemap
../../Source/Swig/typesys.c
scope != current_scope
Type scope '%s' (%p)
    Inherits from '%s' (%p)
%40s -> %s
a(%s).
feature:valuewrapper
feature:novaluewrapper
SwigValueWrapper< %s >
*** '%s' != '%s'
newmemory
SWIGUNUSEDPARM(newmemory)
%sTo%s
$from
    return (void *)((%s) 
 ((%s) x));
static swig_type_info _swigt_
%s{0, 0, 0, 0}};
  {&_swigt_%s, %s, 0, 0},
  {&_swigt_%s, 0, 0, 0},
  &_swigt_%s,
  _swigc_%s,
  NULL
SCOPES start  =======================================
SCOPES finish =======================================
Recursive typedef detected resolving '%s' to '%s' to '%s' and so on...
Bad template type passed to SwigType_remember: %s
*** Internal error. Inconsistent clientdata for type '%s'
static void *%s(void *x, int *%s) {
static void *%s(void *x, int *SWIGUNUSEDPARM(newmemory)) {
/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
static swig_type_info *swig_type_initial[] = {
static swig_cast_info *swig_cast_initial[] = {
/* -------- TYPES TABLE (BEGIN) -------- */
static swig_cast_info _swigc_%s[] = {
"%s", "%s", 0, 0, (void*)%s, 0};
static swig_type_info _swigt_%s = {"%s", 0, 0, 0, 0, 0};
static swig_cast_info _swigc_%s[] = {{&_swigt_%s, 0, 0, 0},{0, 0, 0, 0}};
#define SWIGTYPE%s swig_types[%d]
/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
static swig_type_info *swig_types[%d];
static swig_module_info swig_module = {swig_types, %d, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)
/* -------- TYPES TABLE (END) -------- */
SwigType_remember_clientdata
SwigType_using_scope
SwigType_inherit_scope
;*3$"
zPLR
swig3.0
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.gcc_except_table
.init_array
.fini_array
.jcr
.dynamic
.got.plt
.data
.bss
.gnu_debuglink
