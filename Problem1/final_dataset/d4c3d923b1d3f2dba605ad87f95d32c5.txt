/lib64/ld-linux-x86-64.so.2
libselinux.so.1
_ITM_deregisterTMCloneTable
__gmon_start__
_Jv_RegisterClasses
_ITM_registerTMCloneTable
_init
security_get_boolean_active
_fini
libelf.so.1
elf_version
gelf_getshdr
gelf_getdyn
gelf_getehdr
elf_getdata
elf_errmsg
gelf_getrela
elf_begin
gelf_getrel
gelf_getsym
gelf_getphdr
elf_strptr
elf_getscn
elf_kind
elf_end
libc.so.6
fflush
strcpy
sprintf
fopen
strsignal
strncmp
optind
regexec
setregid
perror
closedir
initgroups
strncpy
puts
fork
regfree
readdir_r
setreuid
__stack_chk_fail
realloc
abort
_exit
strpbrk
getpid
kill
strdup
sbrk
__assert_fail
strtol
feof
fgets
getpwnam
calloc
strlen
memset
strstr
strcspn
__errno_location
read
memcmp
vsnprintf
__fprintf_chk
stdout
fputc
regerror
memcpy
fclose
strtoul
malloc
getgid
opendir
__ctype_b_loc
getenv
sscanf
regcomp
optarg
stderr
ioctl
getuid
lsearch
getopt_long
open_memstream
execvp
ptrace
strncat
fileno
usleep
fwrite
gettimeofday
geteuid
atoi
atol
waitpid
localtime
strchr
rindex
getline
qsort
syscall
setvbuf
fcntl
__sprintf_chk
memmove
access
strcmp
strerror
__libc_start_main
stpcpy
vfprintf
__environ
__cxa_atexit
__xstat
_edata
__bss_start
ELFUTILS_1.0
GLIBC_2.3
GLIBC_2.3.4
GLIBC_2.14
GLIBC_2.4
GLIBC_2.2.5
%z_$
%r_$
%j_$
%b_$
%Z_$
%R_$
%J_$
%B_$
%:_$
%2_$
%*_$
%"_$
%z^$
%r^$
%j^$
%b^$
%Z^$
%R^$
%J^$
%B^$
%:^$
%2^$
%*^$
%"^$
%z]$
%r]$
%j]$
%b]$
%Z]$
%R]$
%J]$
%B]$
%:]$
%2]$
%*]$
%"]$
%z\$
%r\$
%j\$
%b\$
%Z\$
%R\$
%J\$
%B\$
%zX$
=^q$
AVAUATSH
[A\A]A^]
AWAVAUATSH
[A\A]A^A_]
<+u?H
<-t1H
</t%H
AWAVAUATSH
[A\A]A^A_]
@8H;E
I8RPI
ATSH
[A\]
<_t>
dH34%(
AWAVAUATSH
dH34%(
[A\A]A^A_]
@ H;E
<;uZH
<[ugH
<=u5H
<(t!
<+u[
<)thH
@ H;E
VAPAQE
@8H;E
dH3<%(
<]t	H
<!u:H
<[uOH
<:u9H
[uFH
<:u0H
<\uSH
<*u,H
<?u,H
<*u3H
<?u/H
<.u/H
dH3<%(
dH3<%(
dH34%(
@(H;E
dH3<%(
dH3<%(
dH3<%(
dH3<%(
@PH9
dH34%(
dH34%(
dH34%(
dH34%(
dH34%(
AWAVAUATSH
@0H;
[A\A]A^A_]
dH3<%(
dH34%(
AWAVAUATSH
[A\A]A^A_]
dH34%(
dH34%(
dH3<%(
ATSH
[A\]
dH34%(
dH34%(
d~)H
dH34%(
@XH;E
ATSH
 [A\]
dH34%(
@ H9
dH3<%(
dH3<%(
dH34%(
>tFH
dH3<%(
dH34%(
AQAPM
AQAPM
dH34%(
AWAVAUATSH
[A\A]A^A_]
@ H9
@ H)
@ H)
?u*H
?u*H
@ H;E
@ H;E
H=@B
H-@B
Do nine men interpret Nine men I nod
dH34%(
HcS H
HcS$H
K$Hc
9w Hc
HcC H
[]A\
	w>H
AUATI
USHc
[]A\A]
ATUI
[]A\
w0USH
~(E1
9kXH
[]A\
ATUH
}+H)
[]A\
[]A\
ATUI
[]A\
ATUHc
[]A\
ATUH
[]A\
D$(1
D$(dH3
ATUH
+t^L
[]A\
t2ATUI
[]A\
AWAVAUATUSH
EhHcC4
{0E1
D9s0
HcC(
s E1
D9s 
HcC,
K$E1
D9s$
HcCX
[]A\A]A^A_
D9{X
[]A\A]A^A_
ATUI
9G0Hc
HcC0H
[]A\
AWAVI
AUATA
OtVH
[]A\A]A^A_
[]A\A]A^A_
[]A\
AWAVH
AUATH
[]A\A]A^A_
<Xu)E
([]A\A]A^A_
_t	E
=_7"
[]A\A]A^A_
<AtB<FH
D$x1
T$xdH3
[]A\
AWAVAUATI
D$81
|$8dH3<%(
H[]A\A]A^A_
E;L$X
D$PH
AWAVAUATUSH
L$(1
-P1"
L$$H
[]A\A]A^A_
8[]A\A]A^A_
AWAVE
AUATI
D$x1
L$(H
t$<H
E;l$X
D$PH
D$PJ
t$<H
D$@E
t$`L
E4$E1
|$@H
9l$<~IH
L$xdH3
[]A\A]A^A_
D$PHc
D$PH
D$$H
|$@H
HcL$
T$HH
|$@H
t$,E1
l$<1
Hc|$<H
T$<I
D$PH
L$HH+L$@L
T$PD
D$PHc
t$@H
D$PH
D$$J
HcT$<H
HcL$
D$PH
D$PH
D$$J
HcD$<H
AWAVI
AUATUS
L$,D
D$8t
D$,I
D$@L
|$`A
|$`I
T$hH
T$HH
t$@H
T$HH
t$@H
\$@H
T$hH
t$`H
D$0H
t$@H
T$HH9
|$`H
|$@H
[]A\A]A^A_
HcD$
D$ L
d$ L
D$ t
T$HH
|$0H
;E }
\$@H
AWAVI
AUATI
D$`L
d$@H
D$ H
D$0H
|$@1
dH34%(
[]A\A]A^A_
D$@H;D$Ht
D$@H;D$Ht
D$HH9D$@t
HcD$0A9F0
|$8H
t$(D
D$HH9D$@t
T$ L
|$`H
T$hD
T$ 1
T$hD
|$`D
2w5H
|$HH9|$@t*H
T$HH
t$@H
|$@H
A;FX
t$0L
HcD$0A9F$
<2wV
H90t
H90t
H90t
H90t
T$0D
\$`L
T$hH
t$`I
H98t
T$hH
|$`H
T$4H
D$4H
H90t
H98t
H90t
H90t
\$`L
T$hH
H98t
H98t
H90t
H90t
H98t
H90t
H90t
H90t
AWAVI
AUATI
D$h1
$t6L
l$(H
T$(H
l$(H
D$(L
T$(H
D$hdH3
x[]A\A]A^A_
}	Nu
H;D$
\$0A
|$0H
Tu\H
T$8H
ta<_t]H
|$0H
Uu2A
|$0H
5yX"
T$(L
L;t$(
D$PH
\$0H
T$XH
|$PH
D$(H
T$8H
L;t$(
|$0H
<Lt]<X
H;L$(
|$0H
L;t$(v)H
|$0H
AUATI
[]A\A]
]A\A]
]A\A]
AWAVI
AUATA
\$@H
d$@<_tu
~;<o
=k@"
[]A\A]A^A_
T$ H
operatorL
l$ H
T$(H
=m?"
-[	"
operator
operatorH
operatorH
T$ H
AWAVI
AUATH
D$(1
>tyH
L$(dH3
8[]A\A]A^A_
AVAUATUI
Eh~B
_u3I
[]A\A]A^
[]A\A]A^
AWAVI
AUATI
D$81
\$ H
|$ A
A9G0
|$ A
Hct$
T$(L
|$ H
L$8dH3
H[]A\A]A^A_
T$(H
AVAUATUS
[]A\A]A^
AWAVAUATI
D$H1
;t.H
L$HdH3
X[]A\A]A^A_
=84"
l$0H
t$(L
D$(H
T$8H
|$0H
AWAV
AUATI
D$pH
D$0H
D$PH
T$ H
t$PH
T$XH9
|$0H
D$(H
|$PH
D$(H
dH3<%(
[]A\A]A^A_
|$pH
T$xH9
|$pH
D$(H)
D$xt=IcVDH
T$xH9
D$xL
T$xH
t$pI
|$pH
T$xH9
D$(H)
A	VHH
T$8H
D$(L
T$8L
|$xH9|$pt1H
|$pH
D$(L)
|$PH
AWAVAUATUSH
t$0H
[]A\A]A^A_
AWAVAUATI
D$H1
;_tqH
L$HdH3
X[]A\A]A^A_
= ""
LcD$
LcD$
AWAVAUATUSH
g<dH
D$H1
G	<D
T$0H
T$0H
|$0H
|$0H
T$0H
|$0H
\$HdH3
X[]A\A]A^A_
|$0H
_u+1
T$0H
|$0H
|$0H
|$0H
L$0H
L$(H
D$(H
|$0H
HcL$
|$0H
MwcH
D;O,}9Mc
D;O,}
AUATE
<VtW<Kt
<KtjA
CP	D
CP	D
]A\A]A^A_
u	<Fu
[]A\A]A^A_
Ot	H
AUATI
[]A\A]
AUATL
t=H=
[]A\A]
<	w`E1
G(;G,}8Hc
<_t"<nt
J(A;J,}
8/u&
tvATUH
[]A\
[]A\
AUATI
[]A\A]
[]A\A]
AWAVAUATUSH
81uFH
8>u3H
[]A\A]A^A_
D9d$
D$8H
D$0H
T$0H
D$8H
D$0H
D$0H
D$0H
D$0H
T$0L
D$HI
\$@E
D$0E
Mcl$
Mcl$
t$PH
t$PL
L$PH
D$hM
D$`L
D;d$
tNH=
t;H=
D$(H
T$ H
T$ H
T$0H
D$8H
D$0H
D$8H
D$ H
tNH=
w&H=
t:H=
t;H=
t;H=
Mcl$
~6I;
t]Hc
gu(A
D$8H
D$8H
D$ H
D$8H
D$8H
tEH=
D$0H
D$0H
T$@H
D$0E
9Fut
D$0H
D$0H
<$=H
D$0H
|$0L
l$8H
D$0H
AWAVA
AUATI
([]A\A]A^A_
(t)H
AWAVAUATUSH
D$81
Lt:H
D$8dH3
H[]A\A]A^A_
tdH=
tBH=
ttE1
tLH=
AWAVAUATI
[]A\A]A^A_
AVAUI
ATUI
 []A\A]A^
AVAUATUSH
:1tLH
 []A\A]A^
ATUA
 []A\
G(;G,}
ATUSH
CH[]A\
$<;w
|$	Nu
ATUH
8Bu8f
[]A\
O,E1
}/Hc
}*Hc
:Bt;[
S8;S<}
K0Hc
AWAVAUATUSH
'v0<D
C8;C<
K0Hc
dH3<%(
[]A\A]A^A_
F<0w
S8;S<
K0Hc
S8;S<
K0Hc
0<	v
S(;S,
S(;S,
S(;S,
S(;S,
S(;S,
S(;S,
S(;S,
K(;K,
:It<H
S8;S<
s0Hc
vuNA
D:	t
0;M,|fH
G(;G,}
uh<.tdH
uB<.t><Rt
Et0H
dH3<%(
)SPH
AVUSH
S(;S,
C8;C<
S0Hc
Bu0H
[]A^
[]A^
S(;S,}:Hc
C8;C<
t<<C
Cty@
;C,H
;C,H
8Jt.1
Yt)H
AWAVAUATA
@80ul
dH34%(
([]A\A]A^A_
K(;K,}
[]A\A]A^A_
tt0H
AUATUSH
<ft8
[]A\A]
[]A\A]
S(;S,
[]A\A]
A:D$
<tt%H
AUATUSH
<Lt~~
<XuhH
:Et(1
dH34%(
[]A\A]
[]A\A]
AWAVI
AUATUSH
dH3<%(
[]A\A]A^A_
F8A;F<
V0Hc
A;F,}(Hc
F8A;F<
V0Hc
St9I
F8A;F<
V0Hc
AVAUATUH
Gt>1
[]A\A]A^
Ltc1
]A\A]A^
[]A\A]A^
Degas are we not drawn onward no In union drawn onward to new eras aged
<$t	H
<Stt<_ti<$
U(;U,}bHc
0<	ww
<.u;
0<	w(
[]A\
ATUSH
<ntv<E
[]A\
ATSL
[A\]
AUATHc
D$(1
t$(dH34%(
8[]A\A]
AWAVAUATI
$<;w*H
F	<D
[A\A]A^A_]
ZtwH
D$(1
\$(dH3
AVAUATSL
dH3<%(
[A\A]A^]
ATUH
}+H)
[]A\
[]A\
ATUH
[]A\
[]A\
ATUI
[]A\
<$Hc
<$H9
[]A\
ATUI
[]A\
AUATA
D$(1
<utmE
t#f.
t$(dH34%(
8[]A\A]
D$X1
\$XdH3
AWAVAUATUSH
D$(1
<Gw\H
D$ H
L$(dH3
8[]A\A]A^A_
0<	w
D$ H
\$ I
tx<O
~J<xt&<yurH
<Nu,
AUATUSH
A<9w
([]A\A]
AUATUSH
<Zt}<XtQM
[]A\A]
[]A\A]
[]A\A]
AUATUS1
D$X1
|$ D
T$ H
l$(H9
|$@H
t$@H
T$HI
|$ H
|$@L
\$XdH3
h[]A\A]
|$@H
t$@I
D$HH9
t	H)
AWAVAUATUSH
D$81
d$ E1
\$8dH3
H[]A\A]A^A_
gfffffffI
t	H)
T$(H
T$ H
|$ H
AWAVI
AUATA
D$81
D$ H
\$8dH3
H[]A\A]A^A_
|$ H
T$(H9
|$ H
guBH
<$thH
tnH)
AWAVA
AUATL
[]A\A]A^A_
stop_non_p_processes: %d terminated?
Sending SIGSTOP to process %u
libltrace.c
HOME
couldn't open program '%s': %s
Try `%s --help' for more information.
Usage: %s [option ...] [command [arg ...]]
Trace library calls of a given program.
  -a, --align=COLUMN  align return values in a secific column.
  -A MAXELTS          maximum number of array elements to print.
  -b, --no-signals    don't print signals.
  -c                  count time and calls, and report a summary on exit.
  -C, --demangle      decode low-level symbol names into user-level names.
  -D, --debug=MASK    enable debugging (see -Dh or --debug=help).
  -Dh, --debug=help   show help on debugging.
  -e FILTER           modify which library calls to trace.
  -f                  trace children (fork() and clone()).
  -F, --config=FILE   load alternate configuration file (may be repeated).
  -h, --help          display this help and exit.
  -i                  print instruction pointer at time of library call.
  -l, --library=LIBRARY_PATTERN only trace symbols implemented by this library.
  -L                  do NOT display library calls.
  -n, --indent=NR     indent output by NR spaces for each call level nesting.
  -o, --output=FILENAME write the trace output to file with given name.
  -p PID              attach to the process with the process ID pid.
  -r                  print relative timestamps.
  -s STRSIZE          specify the maximum string size to print.
  -S                  trace system calls as well as library calls.
  -t, -tt, -ttt       print absolute timestamps.
  -T                  show the time spent inside each call.
  -u USERNAME         run command with the userid, groupid of username.
  -V, --version       output version information and exit.
  -x FILTER           modify which static functions to trace.
Report bugs to ltrace-devel@lists.alioth.debian.org
%s debugging option, --debug=<octal> or -D<octal>:
 number  ref. in source   description
      1   general           Generally helpful progress information
     10   event             Shows every event received by a traced process
     20   process           Shows actions carried upon a traced processes
     40   function          Shows every entry to internal functions
Debugging options are mixed using bitwise-or.
Note that the meanings and values are subject to change.
PATH
Error: filename too long.
COLUMNS
MAIN
^%s$
Rule near '%s' will be ignored: %s.
Unmatched '/' in library name.
options.c
expr[s] == '@'
next[s] == '-' || next[s] == '+'
*libname != 0
Unmatched '/' in symbol name.
(Part of) filter will be ignored: '%s': %s.
Filter '%s' will be ignored.
Filter '%s' will be ignored: %s.
Invalid argument to -%c: '%s'.  Use integer %d..%d.
Invalid argument to -%c: '%s'.  Use integer >=%d.
+cfhiLrStTVbCa:A:D:e:F:l:n:o:p:s:u:x:X:
%s: --debug requires an octal argument
can't open %s for writing: %s
ltrace: malloc
ltrace version 0.7.3.
Copyright (C) 1997-2009 Juan Cespedes <cespedes@debian.org>.
This is free software; see the GNU General Public Licence
version 2 or later for copying conditions.  There is NO warranty.
~/.ltrace.conf
/etc/ltrace.conf
Tacocat
@MAIN
%s: Option -L can't be used with -e or -l.
%s: too few arguments
%s: Options -r and -t can't be used together
parse_filter
align
config
debug
demangle
indent
help
library
output
version
no-signals
failed to init breakpoints %d
failed to initialize process %d: %s
proc.c
pid != 0
failed to clone process %d->%d : %s
rc == 0
open_one_pid(pid=%d)
open_pid(pid=%d)
Cannot attach to pid %u: %s
Cannot obtain tasks of pid %u: %s
tmp->next != NULL
proc != NULL
leader != NULL
detach_task %d from leader %d
remove_proc(pid=%d)
install_event_handler(pid=%d, %p)
proc->event_handler == NULL
destroy_event_handler(pid=%d, %p)
handler != NULL
proc->leader == proc
delayed and/or latent breakpoint pid=%d, %s@%p
bp->libsym == NULL
libsym->latent
activated latent symbol
libsym->delayed
activated delayed symbol
lib->next == NULL
added library %s@%p (%s) to %d
Couldn't insert breakpoint for %s to %d: %s.
Couldn't activate latent symbols for %s in %d: %s.
proc->leader != NULL
proc->breakpoints != NULL
proc_add_breakpoint(pid=%d, %s@%p)
dict_find_entry(proc->breakpoints, bp->addr) == NULL
couldn't enter breakpoint %s@%p to dictionary: %s
proc_remove_breakpoint(pid=%d, %s@%p)
removed == bp
lib != NULL
open_program
process_clone
unlist_process
each_task
change_process_leader
install_event_handler
destroy_event_handler
breakpoint_for_symbol
proc_activate_latent_symbol
proc_activate_delayed_symbol
proc_add_library
check_leader
proc_add_breakpoint
proc_remove_breakpoint
proc_find_symbol
void
uint
long
ulong
char
short
ushort
float
double
array
struct
read_config_file.c
rest == NULL
malloc: %s
bad identifier
bad number
expected non-negative value, got %ld
Number too large: %ld
expected '%c', got '%c'
retval
zero
Unknown length specifier: '%s'
Redefinition of typedef '%s'
Definition of forward '%s' must be a structure.
this_td->own_type
Forward struct can be declared only directly after a typedef.
'format' type in unexpected context
only one 'format' type per function supported
string
format
enum
integral type required as enum argument
malloc enum lens: %s
unknown type around '%s'
type != ARGTYPE_POINTER
type == ARGTYPE_STRUCT
hide
octal
bitvec
bool
guess
expected type argument after the lens
hide(int)
str != NULL
info != NULL
Reading line %d of `%s'
typedef
alloc function: %s
 Skipping line %d
 return_type = %d
syntax error
 name = %s
(re)alloc params: %s
unknown argument type
syntax error around "%s"
void parameter assumed to be 'hide(int)'
fun->num_params < allocd
malloc in init_global_config
addr
file
Reading config file `%s'...
New function: `%s'
parse_arg_type
parse_typedef
alula
parse_nonpointer_type
get_hidden_int
process_line
realloc()
%% time     seconds  usecs/call     calls      function
------ ----------- ----------- --------- --------------------
%3lu.%02lu %4d.%06d %11lu %9d %s
100.00 %4lu.%06lu             %9d total
library.c
last->next == NULL
library_add_symbol
filter.c
type != type
Error when matching %s: %s
library soname
library pathname
matcher->type != matcher->type
symbol name
filter_lib_matcher_name_init
matcher_matches_library
glob.c
regex != NULL
globcomp
type.c
!"Not a simple type!"
info->type == ARGTYPE_STRUCT
(&info->u.entries)->elt_size == sizeof(*(&field))
(&info->u.entries)->elt_size == sizeof(struct struct_field)
(idx) < (&info->u.entries)->size
(i) < (&info->u.entries)->size
alignment != 0
type->type == ARGTYPE_STRUCT || type->type == ARGTYPE_ARRAY
info->type == ARGTYPE_STRUCT || info->type == ARGTYPE_ARRAY
emt < type_struct_size(info)
type_is_integral(type)
info != NULL
type_get_simple
type_struct_add
type_struct_get
type_struct_size
type_struct_destroy
layout_struct
align
type_offsetof
type_element
type_aggregate_size
type_is_signed
type_get_hfa_type
value.c
inferior != NULL
val->inferior != NULL
!"Unexpected value of val->where"
!"Can't offset NODATA."
valp->type->type == ARGTYPE_POINTER
sz != (size_t)-1
sz <= sizeof(value->u.value)
sz != sz
value != NULL
value->type->type == ARGTYPE_STRUCT
value_init
value_reify
value_get_raw_data
value_clone
value_init_element
value_init_deref
value_set_word
value_extract_word
value_pass_by_reference
value_dict.c
_source_vec->elt_size == sizeof(struct value)
_source_vec->elt_size == sizeof(struct named_value)
(&target->numbered)->elt_size == sizeof(struct value)
(&dict->numbered)->elt_size == sizeof(*(val))
(&dict->named)->elt_size == sizeof(*(&element))
num < vect_size(&dict->numbered)
(&dict->numbered)->elt_size == sizeof(struct value)
(num) < (&dict->numbered)->size
(&dict->named)->elt_size == sizeof(struct named_value)
(i) < (&dict->named)->size
val_dict_clone
val_dict_push_next
val_dict_push_named
val_dict_get_num
val_dict_get_name
val_dict_destroy
expr.c
lhs != NULL
!"Invalid value of node kind"
!"Unknown node kind."
expr_is_compile_constant(node)
malloc expr_self
expr_init_up
expr_destroy
expr_eval
expr_eval_constant
vect.c
dtor == NULL
dtor != NULL
count <= vec->allocated
vect_clone
vect_reserve
param.c
!"Unknown value of param flavor!"
param_destroy
printf.c
nargs == 1
self->array.type->type == ARGTYPE_ARRAY
lng <= 2
hlf <= 2
node != NULL
format_type != ARGTYPE_VOID
param_printf_init
form_next_param
param_printf_next
maximum array length seems negative
malloc expr_node_zero
lens.c
lens->format_cb != NULL
lens_format
%#lx
0%lo
lens_default.c
!"unsupported integer width"
\%03o
value->type->type == ARGTYPE_POINTER
(&pointers)->elt_size == sizeof(struct value *)
God A red nugget A fat egg under a dog
(i) < (&pointers)->size
old->type->type == ARGTYPE_POINTER
recurse%s
(&pointers)->elt_size == sizeof(*(&value))
<void>
false
true
%zd-%zd
sz <= sizeof(bv)
format_integer
format_pointer
bitvect_lens_format_cb
lens_enum.c
(&self->entries)->elt_size == sizeof(struct enum_entry)
inf_value->type->type == enum_value->type->type
(&lens->entries)->elt_size == sizeof(struct enum_entry)
(i) < (&lens->entries)->size
(&lens->entries)->elt_size == sizeof(*(&entry))
enum_lens_destroy_cb
enum_values_equal
enum_get
lens_enum_add
%d: queuing event %d for later
events.c
event will be missed: %s
delayed_events == NULL
delayed_events != NULL
dequeuing event %d for %d
next_event()
event: No more traced programs: exiting
event: none (wait received EINTR?)
wait
waiting for %d to stop
event: NEW: pid=%d
event from pid %u
event: EXIT_SIGNAL: pid=%d, signum=%d
event: EXIT: pid=%d, status=%d
process not stopped, is it terminating?
get_instruction_pointer
event: SYSCALL: pid=%d, sysnum=%d
event: SYSRET: pid=%d, sysnum=%d
event: ARCH_SYSCALL: pid=%d, sysnum=%d
event: ARCH_SYSRET: pid=%d, sysnum=%d
syscall_p
event: CLONE: pid=%d, newpid=%d
event: EXEC: pid=%d
event: NONE: pid=%d (wait error?)
event: SIGNAL: pid=%d, signum=%d
event: BREAKPOINT: pid=%d, addr=%p
enque_event
fetch.c
!"Unexpected floating type!"
!"More than six syscall arguments???"
!"Too many return value classes."
pool == POOL_FUNCALL
field != NULL
expr_is_compile_constant(info->u.array_info.length)
info->type != info->type
info->type != ARGTYPE_ARRAY
cls == CLASS_INTEGER
cls == CLASS_X87
!"Unexpected i386 retval type!"
ctx->u.x86_64.num_ret_classes == 1
type != LT_TOF_FUNCTIONR && type != LT_TOF_SYSCALLR
type != LT_TOF_FUNCTION && type != LT_TOF_SYSCALL
cls == context->u.x86_64.ret_classes[i]
allocate_x87
allocate_integer
allocate_sse
flatten_structure
classify
classify_argument
arch_fetch_retval_32
arch_fetch_arg_init_64
arch_fetch_arg_init
arch_fetch_fun_retval
sysnum=%ld %p %d
trace.c
info->type != info->type
arch_type_sizeof
arch_type_alignof
/proc/%d/exe
/proc/%d/status
Tgid:	
State:	
T (stopped)
T (tracing stop)
Unknown process status: %s
process_status %d: %s
/proc/%d/task
find_dynamic_entry()
proc.c
A Santa lives evil at NASA
Couldn't find address for dtag!
found address: %p in dtag %d
crawl_linkmap()
Debug structure or it's linkmap are NULL!
Unable to read link map
Name of mapped library is NULL
linux-vdso.so.1
linux-gate.so.1
linux-vdso32.so.1
linux-vdso64.so.1
Couldn't load ELF object %s: %s
load_debug_struct
This process does not have a debug structure!
arch_check_dbg
Unable to load debug structure!
Linkmap is now consistent
Adding DSO to linkmap
Removing DSO from linkmap
Unexpected debug state!
linkmap_init(%d, dyn_addr=%p)
Eleele
Couldn't find debug structure!
No debug structure or no memory to allocate one!
/proc/%d/auxv
couldn't read %s: %s
Couldn't read SP register: %s
Couldn't read return value: %s
deny_ptrace
The SELinux boolean 'deny_ptrace' is enabled, which may prevent ltrace from
tracing other processes.  You can disable this process attach protection by
issuing 'setsebool deny_ptrace=0' in the superuser context.
Could not attach to process.  If your uid matches the uid of the target
process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try
again as the root user.  For more details, see /etc/sysctl.d/10-ptrace.conf
trace_me: pid=%d
trace.c
PTRACE_TRACEME
trace_pid: waitpid
trace_pid: pid=%d
trace_set_options: pid=%d
PTRACE_SETOPTIONS
untrace_pid: pid=%d
continue_after_signal: pid=%d, signum=%d
continue_process: pid=%d
putting off the continue, events in que.
pid != 0
send_sigstop: add_task_info
send SIGSTOP to %d
Warning: couldn't send SIGSTOP to %d
process stopping done %d
SIGSTOP delivered to %d
suspicious: %d got SIGSTOP, but sigstopped=%d and delivered=%d
continue %d for SIGSTOP delivery
self != NULL
self->super.on_event == process_stopping_on_event
!"Too many atomic singlestep breakpoints!"
PTRACE_SINGLESTEP
%d couldn't continue when handling %s (%p) at %p
PTRACE_CONT
all stopped, now singlestep/cont %d
process_stopping_on_event: pid %d; event type %d; state %d
new task??? %d
%d LT_EV_SYSRET
process_install_stopping_handler: pid=%d
continue_after_breakpoint: pid=%d, addr=%p
process_stopping_handler_create
ltrace_exiting_on_event: pid %d; event type %d
proc->event_handler->on_event == &process_stopping_on_event
malloc exiting handler
process_vfork_on_event: pid %d; event type %d
sbp->libsym == NULL
continue_after_vfork: pid=%d
malloc vfork handler
proc->leader == proc
proc->next == NULL || proc->next->leader != proc
proc->parent != NULL
proc->parent->leader != NULL
continue_after_syscall: don't continue %d
Couldn't install exiting handler for %d.
IREL.%#lx
get_task_info
remove_atomic_breakpoints
atomic_singlestep_add_bp
ltrace_exiting_install_handler
process_vfork_on_event
continue_after_vfork
breakpoints.c
bp != NULL
proc != NULL
proc->breakpoints != NULL
proc->leader == proc
address2bpstruct(pid=%d, addr=%p)
bp->cbs == NULL
rc == 0
proc->pid != 0
bp->enabled >= 0
leader != NULL
leader->breakpoints != NULL
NULL
insert_breakpoint(pid=%d, addr=%p, symbol=%s)
addr != 0
delete_breakpoint(pid=%d, addr=%p)
sbp != NULL
Couldn't turn off the breakpoint %s@%p
enable_bp_cb(pid=%d)
enable_all_breakpoints(pid=%d)
Enabling breakpoints for pid %u...
disable_bp_cb(pid=%d)
disable_all_breakpoints(pid=%d)
breakpoints_init(pid=%d)
proc->filename != NULL
Couldn't initialize entry breakpoint for PID %d.
Some tracing events may be missed.
Borrow or rob
breakpoint_on_hit
breakpoint_on_continue
breakpoint_on_install
breakpoint_on_retract
address2bpstruct
breakpoint_set_callbacks
breakpoint_clone
breakpoint_turn_on
breakpoint_turn_off
insert_breakpoint
delete_breakpoint
breakpoint_name
breakpoint_library
disable_all_breakpoints
entry_breakpoint_init
breakpoints_init
DEBUG: %s:%d: %s
ltrace: malloc
my_demangle(name=%s)
demangle.c
dict_init()
dict.c
malloc()
dict_clear()
dict_enter()
malloc
new dict entry at %p[%d]: (%p,%p)
d != NULL
dict_remove(%p)
dict_find_entry()
dict_apply_to_all()
key1
key2
dict_clone()
key_clone
value_clone
dict_clear
dict_enter
dict_remove
dict_find_entry
dict_key2hash_string
dict_key_cmp_string
Couldn't create symbol for PLT entry: %s
Couldn't read section or header.
ltrace-elf.c
data != NULL
Not enough data to read %ld-byte value at offset %ld.
"%s" is not an ELF file
can't read ELF header of "%s": %s
"%s" is neither an ELF executable nor a shared library
"%s" is ELF from incompatible architecture
close_elf()
(&lte->plt_relocs)->elt_size == sizeof(GElf_Rela)
Couldn't get data of section %s from "%s": %s
Couldn't get header of section #%d from "%s": %s
Couldn't get data of section #%d from "%s": %s
Couldn't load .rel*.plt data.
.rel*.plt size (%lxd) not a multiple of its sh_entsize (%lxd).
(rela_vec)->elt_size == sizeof(*(&rela))
Couldn't get SHT_DYNAMIC: %s
ltelf_read_elf(filename=%s)
Reading ELF from %s...
Couldn't get section #%d from "%s": %s
Couldn't get name of section #%d from "%s": %s
Couldn't get .dynamic data from "%s": %s
.plt
Can't load .plt data
Couldn't find .dynsym or .dynstr in "%s"
%s has no PLT relocations
%s has unknown PLT size
Couldn't get section header from "%s": %s
Couldn't get .rel*.plt data from "%s": %s
Couldn't find .rel*.plt section in "%s"
%s %zd PLT relocations
marking %s latent
libsymp != NULL
(i) < (&lte->plt_relocs)->size
couldn't insert symbols for -x: %s
couldn't get symbol #%zd from %s: %s
version > orig_name
Couldn't store symbol %s.  Tracing may be incomplete.
couldn't translate address of %s@%s: %s
this_sym != NULL
-l matches %s
Couldn't find entry of PIE %s
Couldn't determine base address of %s
Backend initialization failed.
elf_can_read_next
ltelf_destroy
read_relplt
filter_symbol_chain
populate_plt
populate_this_symtab
you must be root to use the -u option
cannot find user `%s'
ltrace: initgroups
ltrace: setregid
ltrace: setreuid
Executing `%s'...
execute_program.c
ltrace: fork
Can't execute `%s': %s
PID=%d
handle_event.c
proc != NULL
ltrace about to exit
handle_event(pid=%d, type=%d)
event: none
[%d] event: signal (%s [%d])
[%d] event: exit (%d)
[%d] event: exit signal (%s [%d])
[%d] event: syscall (%s [%d])
[%d] event: sysret (%s [%d])
[%d] event: arch_syscall (%s [%d])
[%d] event: arch_sysret (%s [%d])
[%d] event: clone (%u)
[%d] event: exec()
[%d] event: breakpoint %p
[%d] event: new process
Error! unknown event?
pending_new(%d)
pending_new_insert(%d)
malloc()
pending_new_remove(%d)
handle_clone(pid=%d)
Error during init of tracing process %d
This process won't be traced.
handle_new(pid=%d)
proc->state == STATE_BEING_CREATED
shortsignal(pid=%d, signum=%d)
UNKNOWN_SIGNAL
sysname(pid=%d, sysnum=%d)
SYS_%d
SYS_%s
arch_sysname(pid=%d, sysnum=%d)
ARCH_%d
ARCH_%s
handle_signal(pid=%d, signum=%d)
--- %s (%s) ---
handle_exit(pid=%d, status=%d)
+++ exited (status %d) +++
handle_exit_signal(pid=%d, signum=%d)
+++ killed by %s +++
handle_syscall(pid=%d, sysnum=%d)
handle_exec(pid=%d)
--- Called exec() ---
couldn't reinitialize process %d after exec
handle_arch_syscall(pid=%d, sysnum=%d)
calc_time_spent(pid=%d)
handle_sysret(pid=%d, sysnum=%d)
event->proc->callstack_depth > 0
event->proc->callstack[d].is_syscall
handle_arch_sysret(pid=%d, sysnum=%d)
handle_breakpoint(pid=%d, addr=%p)
event: breakpoint (%p)
unexpected breakpoint at %p
callstack_push_syscall(pid=%d, sysnum=%d)
%s: Error: call nesting too deep!
callstack_push_symfunc(pid=%d, symbol=%s)
proc->callstack_depth > 0
callstack_pop(pid=%d)
call_handler
handle_new
SIG_0
SIGHUP
SIGINT
SIGQUIT
SIGILL
SIGTRAP
SIGABRT
SIGBUS
SIGFPE
SIGKILL
SIGUSR1
SIGSEGV
SIGUSR2
SIGPIPE
SIGALRM
SIGTERM
SIGSTKFLT
SIGCHLD
SIGCONT
SIGSTOP
SIGTSTP
SIGTTIN
SIGTTOU
SIGURG
SIGXCPU
SIGXFSZ
SIGVTALRM
SIGPROF
SIGWINCH
SIGIO
SIGPWR
SIGSYS
read
write
open
close
stat
fstat
lstat
poll
lseek
mmap
mprotect
munmap
rt_sigaction
rt_sigprocmask
rt_sigreturn
ioctl
pread
pwrite
readv
writev
access
pipe
select
sched_yield
mremap
msync
mincore
madvise
shmget
shmat
shmctl
dup2
pause
nanosleep
getitimer
alarm
setitimer
getpid
sendfile
socket
connect
accept
sendto
recvfrom
sendmsg
recvmsg
shutdown
bind
listen
getsockname
getpeername
socketpair
setsockopt
getsockopt
clone
fork
vfork
execve
exit
wait4
kill
uname
semget
semop
semctl
shmdt
msgget
msgsnd
msgrcv
msgctl
fcntl
flock
fsync
fdatasync
truncate
ftruncate
getdents
getcwd
chdir
fchdir
rename
mkdir
rmdir
creat
link
unlink
symlink
readlink
chmod
fchmod
chown
fchown
lchown
umask
gettimeofday
getrlimit
getrusage
sysinfo
times
ptrace
getuid
syslog
getgid
setuid
setgid
geteuid
getegid
setpgid
getppid
getpgrp
setsid
setreuid
setregid
getgroups
setgroups
setresuid
getresuid
setresgid
getresgid
getpgid
setfsuid
setfsgid
getsid
capget
capset
rt_sigpending
rt_sigtimedwait
rt_sigqueueinfo
rt_sigsuspend
sigaltstack
utime
mknod
uselib
personality
ustat
statfs
fstatfs
sysfs
getpriority
setpriority
sched_setparam
sched_getparam
sched_setscheduler
sched_getscheduler
sched_get_priority_max
sched_get_priority_min
sched_rr_get_interval
mlock
munlock
mlockall
munlockall
vhangup
modify_ldt
pivot_root
_sysctl
prctl
arch_prctl
adjtimex
setrlimit
chroot
sync
acct
settimeofday
mount
umount2
swapon
swapoff
reboot
sethostname
setdomainname
iopl
ioperm
create_module
init_module
delete_module
get_kernel_syms
query_module
quotactl
nfsservctl
getpmsg
putpmsg
afs_syscall
tuxcall
security
gettid
readahead
setxattr
lsetxattr
fsetxattr
getxattr
lgetxattr
fgetxattr
listxattr
llistxattr
flistxattr
removexattr
lremovexattr
fremovexattr
tkill
time
futex
sched_setaffinity
sched_getaffinity
set_thread_area
io_setup
io_destroy
io_getevents
io_submit
io_cancel
get_thread_area
lookup_dcookie
epoll_create
epoll_ctl
epoll_wait
remap_file_pages
getdents64
set_tid_address
restart_syscall
semtimedop
fadvise64
timer_create
timer_settime
timer_gettime
timer_getoverrun
timer_delete
clock_settime
clock_gettime
clock_getres
clock_nanosleep
exit_group
tgkill
utimes
vserver
mbind
set_mempolicy
get_mempolicy
mq_open
mq_unlink
mq_timedsend
mq_timedreceive
mq_notify
mq_getsetattr
kexec_load
waitid
add_key
request_key
keyctl
ioprio_set
ioprio_get
inotify_init
inotify_add_watch
inotify_rm_watch
migrate_pages
openat
mkdirat
mknodat
fchownat
futimesat
newfstatat
unlinkat
renameat
linkat
symlinkat
readlinkat
fchmodat
faccessat
pselect6
ppoll
unshare
set_robust_list
get_robust_list
splice
sync_file_range
vmsplice
move_pages
utimensat
epoll_pwait
signalfd
timerfd_create
eventfd
fallocate
timerfd_settime
timerfd_gettime
accept4
signalfd4
eventfd2
epoll_create1
dup3
pipe2
inotify_init1
preadv
pwritev
rt_tgsigqueueinfo
perf_event_open
recvmmsg
fanotify_init
fanotify_mark
prlimit64
name_to_handle_at
open_by_handle_at
clock_adjtime
syncfs
sendmmsg
setns
getcpu
process_vm_readv
process_vm_writev
waitpid
break
oldstat
umount
stime
oldfstat
stty
gtty
nice
ftime
prof
signal
lock
ulimit
oldolduname
sigaction
sgetmask
ssetmask
sigsuspend
sigpending
oldlstat
readdir
profil
socketcall
olduname
idle
vm86old
sigreturn
sigprocmask
bdflush
_llseek
_newselect
vm86
pread64
pwrite64
ugetrlimit
mmap2
truncate64
ftruncate64
stat64
lstat64
fstat64
lchown32
getuid32
getgid32
geteuid32
getegid32
setreuid32
setregid32
getgroups32
setgroups32
fchown32
setresuid32
getresuid32
setresgid32
getresgid32
chown32
setuid32
setgid32
setfsuid32
setfsgid32
madvise1
fcntl64
sendfile64
statfs64
fstatfs64
fadvise64_64
fstatat64
handle_sysret
callstack_push_syscall
callstack_push_symfunc
callstack_pop
[pid %u] 
%3lu.%06d 
%lu.%06d 
%02d:%02d:%02d.%06d 
%02d:%02d:%02d 
[%p] 
malloc: %s
 <unfinished ...>
 <no return ...>
output.c
!"Invalid param flavor!"
%s->
malloc()
<... %s resumed> 
retval
 <%lu.%06d>
%s:%d: %s: %s
%s: %s
error
warning
fetch_one_param
arch_enable_breakpoint: pid=%d, addr=%p, symbol=%s
breakpoint.c
enable_breakpoint pid=%d, addr=%p, symbol=%s: %s
enable_breakpoint: pid=%d, addr=%p, symbol=%s
arch_disable_breakpoint: pid=%d, addr=%p, symbol=%s
disable_breakpoint pid=%d, addr=%p: %s
disable_breakpoint: pid=%d, addr=%p, symbol=%s
const volatile
const __restrict
const volatile __restrict
 new
none
Oabs
'Read
'Write
'Input
'Output
.Finalize
.Adjust
_elabb
_ada_
<%s>
false
true
JArray1Z
unsigned
__complex
void
bool
wchar_t
long double
int%u_t
-2147483648
__pt__
__tm__
__ps__
_GLOBAL_
{anonymous}
assign_
type
template <
> class
__ct
__dt
operator
operator 
 static
 type_info node
 type_info function
0123456789Qt
__thunk_
 virtual table
_imp__
__imp_
__std__
__sti__
__vtbl__
global constructors keyed to 
global destructors keyed to 
import stub for 
'Elab_Body
_elabs
'Elab_Spec
_size
'Size
_alignment
'Alignment
_assign
.":="
Oand
Omod
Onot
Orem
Oxor
Oadd
Osubtract
Oconcat
Omultiply
Odivide
Oexpon
Demangling disabled
auto
GNU (g++) style demangling
lucid
Lucid (lcc) style demangling
ARM style demangling
HP (aCC) style demangling
EDG style demangling
gnu-v3
java
Java style demangling
gnat
GNAT style demangling
dlang
DLANG style demangling
 delete
 new []
 delete []
plus
Beeb
minus
mult
convert
negate
trunc_mod
trunc_div
truth_andif
truth_orif
truth_not
postincrement
postdecrement
bit_ior
bit_xor
bit_and
bit_not
alshift
arshift
component
indirect
method_call
->()
addr
array
compound
cond
sizeof 
virtual function thunk (delta:%d) for 
Automatic selection based on executable
GNU (g++) V3 ABI-style demangling
[abi:
{default arg#
JArray
VTT for 
construction vtable for 
-in-
typeinfo for 
typeinfo name for 
typeinfo fn for 
non-virtual thunk to 
covariant return thunk to 
java Class for 
guard variable for 
TLS init function for 
TLS wrapper function for 
reference temporary #
hidden alias for 
non-transaction clone for 
_Sat 
_Accum
_Fract
new 
java resource 
decltype (
{parm#
{lambda(
{unnamed type#
 [clone 
 restrict
 const
 transaction_safe
complex 
imaginary 
 __vector(
(anonymous namespace)
string literal
std::allocator
std::basic_string
std::string
std::istream
basic_istream
std::ostream
basic_ostream
std::iostream
basic_iostream
boolean
__float128
unsigned char
unsigned int
unsigned long
unsigned __int128
unsigned short
unsigned long long
decimal32
decimal64
decimal128
half
char16_t
char32_t
decltype(nullptr)
alignof 
const_cast
delete[] 
dynamic_cast
delete 
operator"" 
new[]
reinterpret_cast
static_cast
throw
std::basic_string<char, std::char_traits<char>, std::allocator<char> >
std::basic_istream<char, std::char_traits<char> >
std::basic_ostream<char, std::char_traits<char> >
std::basic_iostream<char, std::char_traits<char> >
extern(C) 
extern(Windows) 
extern(Pascal) 
extern(C++) 
extern(Objective-C) 
pure 
nothrow 
ref 
@property 
@trusted 
@safe 
@nogc 
return 
NINF
-Inf
null
 immutable
 shared
 inout
shared(
const(
immutable(
inout(
delegate
Tuple!(
ubyte
ushort
uint
ulong
ifloat
idouble
ireal
cfloat
cdouble
creal
wchar
dchar
ucent
scope 
out 
lazy 
__ctor
__dtor
~this
init$
__vtblZ
__ClassZ
ClassInfo for 
__postblitMFZ
this(this)
__InterfaceZ
Interface for 
__ModuleInfoZ
ModuleInfo for 
__initZ
_Dmain
D main
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~
 !"#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
%s%sout of memory allocating %lu bytes after a total of %lu bytes
;*3$"
.shstrtab
.interp
.note.ABI-tag
.note.gnu.build-id
.gnu.hash
.dynsym
.dynstr
.gnu.version
.gnu.version_r
.rela.dyn
.rela.plt
.init
.plt.got
.text
.fini
.rodata
.eh_frame_hdr
.eh_frame
.init_array
.fini_array
.jcr
.data.rel.ro
.dynamic
.got.plt
.data
.bss
